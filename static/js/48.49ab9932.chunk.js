(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[48],{617:function(t,e,n){"use strict";n.r(e),e.default=' It is a type of Creational Design Pattern.\n\nBuilder pattern was introduced to solve some of the problems with Factory and Abstract Factory design patterns when the Object contains a lot of attributes.\n\nStatic factories and constructors share a limitation, they dont scale well to large number of optional paramaters.\n\nBuilder pattern solves the issue with large number of optional parameters and inconsistent state by providing a way to build the object step-by-step and provide a method that will actually return the final Object.\n\nLets start coding\n\n```jsx\n\npublic class Employee {\n\t//All final attributes\n\tprivate final int empId;\n\tprivate final String empName;\n\tprivate final double empSalary;\n\tprivate final String empAddress;\n\n\tprivate Employee(EmployeeBuilder builder) {\n\t\tthis.empId = builder.empId;\n\t\tthis.empName = builder.empName;\n\t\tthis.empSalary = builder.empSalary;\n\t\tthis.empAddress = builder.empAddress;\n\t}\n\n\t//All getter, and NO setter to provde immutability\n\tpublic int getEmpId() {\n\t\treturn empId;\n\t}\n\n\tpublic String getEmpName() {\n\t\treturn empName;\n\t}\n\n\tpublic double getEmpSalary() {\n\t\treturn empSalary;\n\t}\n\n\tpublic String getEmpAddress() {\n\t\treturn empAddress;\n\t}\n\n\tpublic static class EmployeeBuilder {\n\t\tprivate int empId;\n\t\tprivate String empName;\n\t\tprivate double empSalary;\n\t\tprivate String empAddress;\n\n\t\tEmployeeBuilder() {\n\n\t\t}\n\n\t\tpublic EmployeeBuilder empId(int empId) {\n\t\t\tthis.empId = empId;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic EmployeeBuilder empName(String empName) {\n\t\t\tthis.empName = empName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic EmployeeBuilder empSalary(double empSalary) {\n\t\t\tthis.empSalary = empSalary;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic EmployeeBuilder empAddress(String empAddress) {\n\t\t\tthis.empAddress = empAddress;\n\t\t\treturn this;\n\t\t}\n\t\t //Return the finally constructed  Employee object\n\t\tpublic Employee build() {\n\t\t\tEmployee emp = new Employee(this);\n\t\t\treturn emp;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn "Employee [empId=" + empId + ", empName=" + empName + ", empSalary=" + empSalary + ", empAddress="\n\t\t\t\t+ empAddress + "]";\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tEmployee emp = new Employee.EmployeeBuilder().empId(149903).empName("Praveen").empSalary(1000000d)\n\t\t\t\t.empAddress("Hyderabad").build();\n\t\tSystem.out.println(emp);\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\nEmployee [empId=149903, empName=Praveen, empSalary=1000000.0, empAddress=Hyderabad]\n```\n\n### Benefits\n\n- Solves the multiple constructor.\n- problem(telescoping constructor).\n- Static inner class(builder class).\n- Internally required constructor.\n- removes the need for setters.\n\n### Limitations\n\n- Immutable.\n- Inner static class.\n- Design first.\n- Complex.\n\n### Builder Design Pattern Example in JDK\n\nSome of the builder pattern example in Java classes are;\n\n- java.lang.StringBuilder#append() (unsynchronized)\n- java.lang.StringBuffer#append() (synchronized)\n- DocumentBuilder\n- Locale.Builder\n\n '}}]);