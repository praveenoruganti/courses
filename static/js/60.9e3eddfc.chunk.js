(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[60],{629:function(t,n,r){"use strict";r.r(n),n.default=" Binary Search is the process of searching an element from sorted array by dividing the search interval in half.\n\nBinary Search is faster than Linear Search.\n\nAlthough Binary Search is a very optimized way of searching a particular element but the array must be sorted on which you want to perform search process.\n\nIf Array is unsorted then we have to perform the sort first and then we can perform binary search.\n\nLet's start coding for binary search\n\n```jsx\npackage com.praveen.search.binary;\n\npublic class BinarySearch {\n\tpublic static void main(String[] args) {\n\t\tint[] arr = { 2, 8, 10, 12, 16, 24, 38, 42, 92, 122 };\n\t\tSystem.out.println(search(arr, 42));\n\t\tSystem.out.println(search(arr, 10));\n\t\tSystem.out.println(search(arr, 100));\n\t\tSystem.out.println(search(arr, 16));\n\n\t}\n\n\tpublic static int search(int[] arr, int target) {\n\n\t\tint start = 0;\n\t\tint end = arr.length - 1;\n\n\t\twhile (start <= end) {\n\n\t\t\tint mid = start + (end - start) / 2;\n\t\t\tif (target < arr[mid]) {\n\t\t\t\tend = mid - 1;\n\t\t\t} else if (target > arr[mid]) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else {\n\t\t\t\treturn mid;\n\t\t\t}\n\n\t\t}\n\n\t\treturn -1;\n\n\t}\n\n}\n\n\n\n```\n\n**Output**\n```jsx\n7\n2\n-1\n4\n```\n\n**Order Agnositic Binary Search**\n\nIf we dont know in which order the array is provided then how we can apply the binary search logic.\n\nHere we go, we just need to compare the first and last element in array and then decide whether array is in ascending or descending order.\n\nLet's code now.\n\n```jsx\npackage com.praveen.search.binary;\n\npublic class OrderAgnosticBS {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 2, 8, 10, 12, 16, 24, 38, 42, 92, 122 }, 42));\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 2, 8, 10, 12, 16, 24, 38, 42, 92, 122 }, 10));\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 2, 8, 10, 12, 16, 24, 38, 42, 92, 122 }, 100));\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 2, 8, 10, 12, 16, 24, 38, 42, 92, 122 }, 16));\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 122, 92, 42, 38, 24, 16, 12, 10, 8, 2 }, 42));\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 122, 92, 42, 38, 24, 16, 12, 10, 8, 2 }, 10));\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 122, 92, 42, 38, 24, 16, 12, 10, 8, 2 }, 100));\n\t\tSystem.out.println(orderAgnosticBS(new int[] { 122, 92, 42, 38, 24, 16, 12, 10, 8, 2 }, 16));\n\t}\n\n\tprivate static int orderAgnosticBS(int[] arr, int target) {\n\n\t\tint start = 0;\n\t\tint end = arr.length - 1;\n\n\t\t// find whether array is ascending or descending\n\t\tboolean isAsc = arr[start] < arr[end];\n\n\t\twhile (start <= end) {\n\n\t\t\tint mid = start + (end - start) / 2;\n\n\t\t\tif (arr[mid] == target) {\n\t\t\t\treturn mid;\n\t\t\t}\n\n\t\t\tif (isAsc) {\n\t\t\t\tif (target < arr[mid]) {\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target > arr[mid]) {\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn -1;\n\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\n7\n2\n-1\n4\n2\n7\n-1\n5\n\n```\n\n`Let's see some programs`\n\n`1.Find the ceiling of a number`\n\n```jsx\npackage com.praveen.search.binary;\n\n/*\n Ceiling -> Find the smallest element in an array greater or equal to target\n */\npublic class Ceiling {\n\n\tpublic static void main(String[] args) {\n\n\t\tSystem.out.println(ceiling(new int[] { 2, 3, 5, 9, 18, 24, 36, 72 }, 55));\n\t\tSystem.out.println(ceiling(new int[] { 2, 3, 5, 9, 18, 24, 36, 72 }, 18));\n\t\tSystem.out.println(ceiling(new int[] { 2, 3, 5, 9, 18, 24, 36, 72 }, 6));\n\n\t}\n\n\tprivate static int ceiling(int[] arr, int target) {\n\n\t\tint start = 0;\n\t\tint end = arr.length - 1;\n\n\t\twhile (start <= end) {\n\t\t\tint mid = start + (end - start) / 2;\n\n\t\t\tif (target == arr[mid]) {\n\t\t\t\treturn target;\n\t\t\t} else if (target > arr[mid]) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else if (target < arr[mid]) {\n\t\t\t\tend = mid - 1;\n\t\t\t}\n\n\t\t}\n\t\treturn arr[start];\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\n72\n18\n9\n```\n\n`2.Find the floor of a number`\n\n```jsx\npackage com.praveen.search.binary;\n\n/*\nFloor -> Find the greater element in an array smaller or equal to target\n*/\npublic class Floor {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(floor(new int[] { 2, 3, 5, 9, 18, 24, 36, 72 }, 55));\n\t\tSystem.out.println(floor(new int[] { 2, 3, 5, 9, 18, 24, 36, 72 }, 18));\n\t\tSystem.out.println(floor(new int[] { 2, 3, 5, 9, 18, 24, 36, 72 }, 6));\n\t}\n\t\n\tprivate static int floor(int[] arr, int target) {\n\n\t\tint start = 0;\n\t\tint end = arr.length - 1;\n\n\t\twhile (start <= end) {\n\t\t\tint mid = start + (end - start) / 2;\n\n\t\t\tif (target == arr[mid]) {\n\t\t\t\treturn target;\n\t\t\t} else if (target > arr[mid]) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else if (target < arr[mid]) {\n\t\t\t\tend = mid - 1;\n\t\t\t}\n\n\t\t}\n\t\treturn arr[end];\n\t}\n\n\n}\n\n```\n\n**Output**\n\n```jsx\n36\n18\n5\n```\n\n`3.Find Smallest Letter Greater Than Target`\n\n```jsx\npackage com.praveen.search.binary;\npublic class NextGreatestLetter {\n\n\tpublic static void main(String[] args) {\n\n\t\tSystem.out.println(nextGreatestLetter(new char[] { 'c', 'f', 'j' }, 'a'));\n\t\tSystem.out.println(nextGreatestLetter(new char[] { 'c', 'f', 'j' }, 'c'));\n\t\tSystem.out.println(nextGreatestLetter(new char[] { 'c', 'f', 'j' }, 'd'));\n\t}\n\n\tprivate static char nextGreatestLetter(char[] letters, char target) {\n\t\tint start = 0;\n\t\tint end = letters.length - 1;\n\t\twhile (start <= end) {\n\t\t\tint middle = start + ((end - start) / 2);\n\t\t\tif (letters[middle] > target) {\n\t\t\t\tend = middle - 1;\n\t\t\t} else {\n\t\t\t\tstart = middle + 1;\n\t\t\t}\n\t\t}\n\t\tif (start == letters.length)\n\t\t\treturn letters[0];\n\t\treturn letters[start];\n\t}\n\n}\n\n```\n\n**Output**\n\n```jsx\nc\nf\nf\n```\n\n`4.Find First and Last Position of Element in Sorted Array`\n\n```jsx\npackage com.praveen.search.binary;\n\nimport java.util.Arrays;\n\npublic class SearchInRange {\n\n\tpublic static void main(String[] args) {\n\n\t\tSystem.out.println(Arrays.toString(searchRange(new int[] {5,7,7,8,8,10},8)));\n\t\tSystem.out.println(Arrays.toString(searchRange(new int[] {5,7,7,8,8,10},6)));\n\t\tSystem.out.println(Arrays.toString(searchRange(new int[] {},0)));\n\t\tSystem.out.println(Arrays.toString(searchRange(new int[] {5,7,7,8,8,10},7)));\n\t}\n\n\tprivate static int[] searchRange(int[] nums, int target) {\n\t\tint[] ans = { -1, -1 };\n\t\tint start = search(nums, target, true);\n\t\tint end = search(nums, target, false);\n\n\t\tans[0] = start;\n\t\tans[1] = end;\n\n\t\treturn ans;\n\n\t}\n\n\tprivate static int search(int[] nums, int target, boolean firstStartIndex) {\n\n\t\tint start = 0;\n\t\tint end = nums.length - 1;\n\t\tint ans = -1;\n\n\t\twhile (start <= end) {\n\t\t\tint mid = start + (end - start) / 2;\n\n\t\t\tif (target == nums[mid]) {\n\t\t\t\tans = mid;\n\t\t\t\tif (firstStartIndex) {\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t}\n\t\t\t} else if (target > nums[mid]) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else if (target < nums[mid]) {\n\t\t\t\tend = mid - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\n\t}\n}\n\n```\n\n**Output**\n\n```jsx\n[3, 4]\n[-1, -1]\n[-1, -1]\n[1, 2]\n\n```\n\n`5.Find position of an element in a sorted array of infinite numbers`\n\n```jsx\npackage com.praveen.search.binary;\n\npublic class InfiniteArray {\n\n\tpublic static void main(String[] args) {\n\n\t\tint[] arr = { 3, 5, 7, 9, 10, 90, 100, 130, 140, 160, 170 };\n\n\t\tSystem.out.println(ans(arr, 10));\n\n\t}\n\n\tprivate static int ans(int[] arr, int target) {\n\t\tint start = 0;\n\t\tint end = 1;\n\t\twhile (target > arr[end]) {\n\n\t\t\tint temp = end + 1;\n\t\t\tend = end + (end - start + 1) * 2;\n\t\t\tstart = temp;\n\n\t\t}\n\n\t\treturn search(arr, target, start, end);\n\t}\n\n\tprivate static int search(int[] arr, int target, int start, int end) {\n\t\twhile (start <= end) {\n\t\t\tint mid = start + (end - start) / 2;\n\n\t\t\tif (target < arr[mid]) {\n\t\t\t\tend = mid - 1;\n\t\t\t} else if (target > arr[mid]) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\n4\n```\n\n`6.Peak Index in a Mountain Array`\n\n```jsx\npackage com.praveen.search.binary;\n\npublic class Mountain {\n\n\tpublic static void main(String[] args) {\n\n\t\tSystem.out.println(peakIndexInMountainArray(new int[] { 0, 1, 0 }));\n\t\tSystem.out.println(peakIndexInMountainArray(new int[] { 0, 2, 1, 0 }));\n\t\tSystem.out.println(peakIndexInMountainArray(new int[] { 0, 10, 5, 2 }));\n\n\t}\n\n\tprivate static int peakIndexInMountainArray(int[] arr) {\n\t\tint start = 0;\n\t\tint end = arr.length - 1;\n\n\t\twhile (start < end) {\n\t\t\tint mid = start + (end - start) / 2;\n\t\t\tif (arr[mid] > arr[mid + 1]) {\n\t\t\t\tend = mid;\n\t\t\t} else {\n\t\t\t\tstart = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn start;\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\n1\n1\n1\n```\n\n`7.Search in Rotated Sorted Array`\n\n```jsx\npackage com.praveen.search.binary;\n\npublic class SearchInRotatedSortedArray {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(search(new int[] { 4, 5, 6, 7, 0, 1, 2 }, 0));\n\t\tSystem.out.println(search(new int[] { 4, 5, 6, 7, 0, 1, 2 }, 3));\n\t\tSystem.out.println(search(new int[] { 1 }, 0));\n\n\t}\n\n\tprivate static int search(int[] nums, int target) {\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\twhile (i <= j) {\n\t\t\tint mid = (i + j) / 2;\n\t\t\tif (nums[mid] == target)\n\t\t\t\treturn mid;\n\t\t\telse if (nums[i] <= nums[mid]) {\n\t\t\t\tif (nums[i] <= target && nums[mid] > target) {\n\t\t\t\t\tj = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\ti = mid + 1;\n\t\t\t\t}\n\t\t\t} else if (nums[mid] <= nums[j]) {\n\t\t\t\tif (nums[mid] < target && nums[j] >= target) {\n\t\t\t\t\ti = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tj = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n\n```\n**Output**\n```jsx\n4\n-1\n-1\n\n```\n\n`8.Split Array Largest Sum`\n\n```jsx\npackage com.praveen.search.binary;\n\npublic class SplitArrayLargestSum {\n\n\tpublic static void main(String[] args) {\n\n\t\tSystem.out.println(splitArray(new int[] { 7, 2, 5, 10, 8 }, 2));\n\t\tSystem.out.println(splitArray(new int[] { 1, 2, 3, 4, 5 }, 2));\n\t\tSystem.out.println(splitArray(new int[] { 1, 4, 4 }, 3));\n\t}\n\n\tprivate static int splitArray(int[] nums, int m) {\n\t\tint start = 0;\n\t\tint end = 0;\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tstart = Math.max(start, nums[i]);\n\t\t\tend += nums[i];\n\t\t}\n\n\t\twhile (start < end) {\n\t\t\tint mid = start + (end - start) / 2;\n\t\t\tint sum = 0;\n\t\t\tint pieces = 1;\n\t\t\tfor (int num : nums) {\n\t\t\t\tif (sum + num > mid) {\n\t\t\t\t\tsum = num;\n\t\t\t\t\tpieces++;\n\t\t\t\t} else {\n\t\t\t\t\tsum += num;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pieces > m) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else {\n\t\t\t\tend = mid;\n\t\t\t}\n\n\t\t}\n\t\treturn end;\n\t}\n\n}\n\n```\n\n**Output**\n\n```jsx\n18\n9\n4\n\n```\n\n`9. Search in 2D Array of equal rows and columns in sorted order`\n\n```jsx\npackage com.praveen.search.binary;\n\nimport java.util.Arrays;\n\npublic class RowColMatrix {\n\tpublic static void main(String[] args) {\n\t\tint[][] arr = { { 10, 20, 30, 40 }, { 15, 25, 35, 45 }, { 28, 29, 37, 49 }, { 33, 34, 38, 50 } };\n\n\t\tSystem.out.println(Arrays.toString(search(arr, 49)));\n\t\tSystem.out.println(Arrays.toString(search(arr, 25)));\n\t}\n\n\tprivate static int[] search(int[][] matrix, int target) {\n\t\tint r = 0;\n\t\tint c = matrix[0].length - 1;\n\n\t\twhile (r < matrix.length && c >= 0) {\n\t\t\tif (matrix[r][c] == target) {\n\t\t\t\treturn new int[] { r, c };\n\t\t\t}\n\t\t\tif (matrix[r][c] < target) {\n\t\t\t\tr++;\n\t\t\t} else {\n\t\t\t\tc--;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { -1, -1 };\n\t}\n}\n```\n\n**Output**\n\n```jsx\n[2, 3]\n[1, 1]\n\n```\n\n`10. Search in Sorted Matrix`\n\n```jsx\npackage com.praveen.search.binary;\n\nimport java.util.Arrays;\n\npublic class SortedMatrix {\n\tpublic static void main(String[] args) {\n\t\tint[][] arr = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };\n\t\tSystem.out.println(Arrays.toString(search(arr, 9)));\n\t}\n\n\tstatic int[] binarySearch(int[][] matrix, int row, int cStart, int cEnd, int target) {\n\t\twhile (cStart <= cEnd) {\n\t\t\tint mid = cStart + (cEnd - cStart) / 2;\n\t\t\tif (matrix[row][mid] == target) {\n\t\t\t\treturn new int[] { row, mid };\n\t\t\t}\n\t\t\tif (matrix[row][mid] < target) {\n\t\t\t\tcStart = mid + 1;\n\t\t\t} else {\n\t\t\t\tcEnd = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { -1, -1 };\n\t}\n\n\tstatic int[] search(int[][] matrix, int target) {\n\t\tint rows = matrix.length;\n\t\tint cols = matrix[0].length;\n\t\tif (cols == 0) {\n\t\t\treturn new int[] { -1, -1 };\n\t\t}\n\t\tif (rows == 1) {\n\t\t\treturn binarySearch(matrix, 0, 0, cols - 1, target);\n\t\t}\n\n\t\tint rStart = 0;\n\t\tint rEnd = rows - 1;\n\t\tint cMid = cols / 2;\n\n\t\twhile (rStart < (rEnd - 1)) {\n\t\t\tint mid = rStart + (rEnd - rStart) / 2;\n\t\t\tif (matrix[mid][cMid] == target) {\n\t\t\t\treturn new int[] { mid, cMid };\n\t\t\t}\n\t\t\tif (matrix[mid][cMid] < target) {\n\t\t\t\trStart = mid;\n\t\t\t} else {\n\t\t\t\trEnd = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (matrix[rStart][cMid] == target) {\n\t\t\treturn new int[] { rStart, cMid };\n\t\t}\n\t\tif (matrix[rStart + 1][cMid] == target) {\n\t\t\treturn new int[] { rStart + 1, cMid };\n\t\t}\n\n\t\tif (target <= matrix[rStart][cMid - 1]) {\n\t\t\treturn binarySearch(matrix, rStart, 0, cMid - 1, target);\n\t\t}\n\t\tif (target >= matrix[rStart][cMid + 1] && target <= matrix[rStart][cols - 1]) {\n\t\t\treturn binarySearch(matrix, rStart, cMid + 1, cols - 1, target);\n\t\t}\n\t\tif (target <= matrix[rStart + 1][cMid - 1]) {\n\t\t\treturn binarySearch(matrix, rStart + 1, 0, cMid - 1, target);\n\t\t} else {\n\t\t\treturn binarySearch(matrix, rStart + 1, cMid + 1, cols - 1, target);\n\t\t}\n\t}\n}\n\n```\n\n**Output**\n\n```jsx\n[2, 2]\n\n``` "}}]);