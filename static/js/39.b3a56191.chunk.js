(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[39],{608:function(n,e,t){"use strict";t.r(e),e.default=' - It is a type of Structural Design Pattern.\n- A Decorator Pattern says that just "attach a flexible additional responsibilities to an object dynamically".\n- In other words, The Decorator Pattern uses composition instead of inheritance to extend the functionality of an object at runtime.\n- The Decorator Pattern is also known as Wrapper.\n\n```jsx\npublic interface MenuItem {\n\n\tpublic double cost();\n\n\tpublic String description();\n\n}\n```\n\n```jsx\npublic class Decorator implements MenuItem{\n\n\tprotected MenuItem beverage;\n\n\tpublic Decorator(MenuItem _beverage){\n\t\tbeverage = _beverage;\n\t}\n\n\t@Override\n\tpublic double cost() {\n\t\treturn beverage.cost();\n\t}\n\n\t@Override\n\tpublic String description() {\n\t\treturn beverage.description();\n\t}\n\n}\n```\n\n```jsx\npublic class Milk extends Decorator{\n\n\tpublic Milk(MenuItem _beverage) {\n\t\tsuper(_beverage);\n\t}\n\n\t@Override\n\tpublic double cost() {\n\t\treturn beverage.cost() + 7.4;\n\t}\n\n\t@Override\n\tpublic String description() {\n\t\treturn beverage.description() + ", Milk";\n\t}\n}\n```\n\n```jsx\npublic class HotChocolate implements MenuItem{\n\n\t@Override\n\tpublic double cost() {\n\t\treturn 20.5;\n\t}\n\n\t@Override\n\tpublic String description() {\n\t\treturn "Hot Chocolate";\n\t}\n\n}\n```\n\n```jsx\npublic class Mocha extends Decorator{\n\n\tpublic Mocha(MenuItem _beverage) {\n\t\tsuper(_beverage);\n\t}\n\n\t@Override\n\tpublic double cost() {\n\t\treturn beverage.cost() + 5.0;\n\t}\n\n\t@Override\n\tpublic String description() {\n\t\treturn beverage.description() + ", Mocha";\n\t}\n\n}\n```\n\n```jsx\npublic class Espresso implements MenuItem{\n\n\t@Override\n\tpublic double cost() {\n\t\treturn 18.0;\n\t}\n\n\t@Override\n\tpublic String description() {\n\t\treturn "Espresso roast";\n\t}\n}\n```\n\n```jsx\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// Order hot chocolate\n\t\tMenuItem beverage = new HotChocolate();\n\n\t\t// add mocha flavor to it\n\t\tbeverage = new Mocha(beverage);\n\n\t\t// get invoice\n\t\tSystem.out.println("Your Order: " + beverage.description());\n\t\tSystem.out.println("Total Cost: " + beverage.cost());\n\n\t}\n\n}\n```\n\n**Output**\n\n```jsx\nYour Order: Hot Chocolate, Mocha\nTotal Cost: 25.5\n\n```\n\n### Limitations\n\n- New class for every feature\n- Number of Objects are more hence more complexity\n- More complex for client\n\n### Decorator pattern examples in JDK\n\n- All subclasses of java.io.InputStream, OutputStream, Reader and Writer have a constructor taking an instance of same type.\n- java.util.Collections, the checkedXXX(), synchronizedXXX() and unmodifiableXXX() methods.\n- HttpServletRequestWrapper and HttpServletResponseWrapper\n- javax.swing.JScrollPane '}}]);