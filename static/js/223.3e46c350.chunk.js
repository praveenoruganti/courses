(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[223],{792:function(e,n,t){"use strict";t.r(n),n.default=' **What is JPA**\n\nThe Java Persistence API provides a specification for persisting, reading, and managing data from your Java object to relational tables in the database.\n\nThe problem with JPA Using Hibernate which we learnt in our earlier article is there are lot of duplication between Repositories.\n\nThe other problem is proliferation of data stores i.e.. many are coming up like SQL, NO SQL etc.\n\nSpring Data JPA provides the abstraction support to handle the above problems.\n\n**What is Spring Data JPA**\n\nProvides repository support for the Java Persistence API(JPA).\n\nThe goal of Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.\n\nSpring Data JPA is not a JPA provider. It is a library/framework that adds an extra layer of abstraction on the top of our JPA provider (like Hibernate).\n\nHibernate is a JPA implementation, while Spring Data JPA is a JPA Data Access Abstraction.\n\n**Lets see how Hibernate,EclipseLink and Spring Data JPA categorizes using below diagram.**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/springdatajpa.jpg)\n\n**Core API**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/springdata-1.jpg)\n\nWhere T represents domain type and ID represents type of domain types id.\n\nAll CRUD methods are transactional by default.\n\n**Add the below dependency in pom.xml and by default Hibernate jars are available in spring data jpa.**\n\n```jsx\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n**Create interface UserRepository by extending JpaRepository<User,Long>**\n\n```jsx\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n\tpublic User findByCity(String city);\n}\n\n```\n\n**Connect to MYSQL database**\n\nLet\'s add the mysql dependency in pom.xml\n\n```jsx\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n**Setup Table in Database**\n\nHere there is no need to create the table manually in database rather it will be done automatically based on jpa property.\n\n**application.yml**\n\n```jsx\nspring:\n  application:\n    name: praveenoruganti-user-service\n  datasource:\n    url: jdbc:mysql://root:password-1@localhost:3306/praveenorugantitech?reconnect=true\n    driverClassName: com.mysql.cj.jdbc.Driver\n  jpa:\n   hibernate:\n     ddl-auto: update\n\nspringdoc:\n   use-fqn: true\n   swagger-ui:\n    doc-expansion: none\n    operationsSorter: method\n#   supportedSubmitMethods: []\n\napp:\n openApiTitle: User Service\n openApiDescription: |\n\n       User Service\n\n\n```\n\n\n**User Entity**\n\n```jsx\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@SuperBuilder\n@Entity\npublic class User {\n\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\n\tprivate Long id;\n\t@Column(name = "FIRSTNAME")\n\tprivate String firstName;\n\t@Column(name = "LASTNAME")\n\tprivate String lastName;\n\tprivate String city;\n\tprivate String email;\n\n}\n\n\n```\n\n**Controller**\n\n```jsx\n@RestController\n@RequestMapping("/api/v1_0")\n@Tag(description = "User Operations", name = "User Operations")\npublic class UserController {\n\n\tprivate final UserRepository userRepository;\n\n\tpublic UserController(UserRepository userRepository) {\n\t\tthis.userRepository = userRepository;\n\t}\n\n\t@GetMapping("/users/{id}")\n\t@Operation(description = "Fetch User by Id", summary = "Fetch User by Id")\n\tpublic User fetchUser(@PathVariable("id") Long userId) {\n\t\treturn userRepository.findById(userId).get();\n\t}\n\n\t@GetMapping("/users/city/{city}")\n\t@Operation(description = "Fetch User by City", summary = "Fetch User by City")\n\tpublic User fetchUserByCity(@PathVariable("city") String city) {\n\t\treturn userRepository.findByCity(city);\n\t}\n\n\t@GetMapping("/users")\n\t@Operation(description = "Fetch All Users", summary = "Fetch All Users")\n\tpublic List<User> fetchUsers() {\n\t\treturn userRepository.findAll();\n\t}\n\n\t@PostMapping("/users")\n\t@Operation(description = "Create User", summary = "Create User")\n\tpublic User createUser(@RequestBody User user) {\n\t\treturn userRepository.save(user);\n\t}\n\n}\n```\n\n**Now lets see Spring Data JPA REST**\n\nTo expose repository as rest we can use Spring Data JPA REST and this is not recommended for production.\n\n**Add the below dependency in pom.xml**\n\n```jsx\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-rest</artifactId>\n</dependency>\n```\n\n**Now add annotation @RepositoryRestResource(path="user") in UserRepository**\n\n```jsx\n@Repository\n@RepositoryRestResource(path="user")\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n\tpublic User findByCity(String city);\n\n}\n```\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/springdatarest.PNG)\n\n**JPA Relationship Mapping**\n\nWhen mapping entities with each other, we describe the relation among entities using OneToOne, OneToMany,ManyToOne or ManyToMany mappings.\n\n**OneToOne**\n\nIt\'s a relationship where a record in one entity(table) is associated with exactly one record in another entity(table).\n\nFor example, A Person has a PAN (Card) is a perfect example of One To One association.\n\nUnidirectional - Person can refer to PAN entity\n\nBidirectional - PAN entity can refer back to Person\n\n```jsx\n@Entity\npublic class Person {\n@Id \nprivate int id;\n\n@OneToOne\n@JoinColumn(name="PAN_ID")\nprivate PAN pan;\n// ...\n}\n@Entity\npublic class PAN {\n@Id \nprivate int id;\n\n@OneToOne(mappedBy="pan")\nprivate Person person;\n// ...\n}\n```\n\nHere @JoinColumn annotation is used to specify the foreign key column relationship details between 2 entities. `name` defines the name of the foreign column.\n\nSome more examples like User - Email, User - Address Country - Capital etc.\n\n**OneToMany**\n\nA OneToMany relationship refers to the relationship between two entities/tables A and B in which one element/row of A may only be linked to many elements/rows of B, but a member of B is linked to only one element/row of A.\n\nThe opposite of OneToMany is ManyToOne relationship.\n\n\nFor example, A Person has many Skill(s), But a skill can not be shared among Person(s). A Skill can belong to utmost One Person. \n\nOne more example could be relationship between Employee and Department where an Department is associated with Collection of Employee(s)\n\nUnidirectional - A Department can directly reference Employee(s) by collection\n\nBidirectional - Each Employee has a reference back to Department\n\nSome more examples are CLASS - Students, Book - Pages etc.\n\n```jsx\n\n@Entity\npublic class Employee {\n@Id private int id;\n@ManyToOne\n@JoinColumn(name="DEPT_ID")\nprivate Department department;\n// ...\n}\n@Entity\npublic class Department {\n@Id private int id;\n@OneToMany(mappedBy="department")\nprivate Collection<Employee> employees;\n// ...\n}\n```\n\n- A many-to-one relationship between two entities is defined by using @ManyToOne Annotation. The child entity, that has the join column , is called the owner of the relationship. The @JoinColumn is used to specify the foreign key column details.\n\n\n- A one-to-many relationship between two entities is defined by using @OneToMany Annotation. mappedBy element indicates the entity that owns the bidirectional relationship.\nUsually, the child entity is one that owns the relationship and the parent entity contains the @OneToMany annotation.\n\n**ManyToMany**\n\nA many-to-many relationship refers to relationship between two entities/tables A and B in which one element/row of A are associated with many elements/rows of B and viceversa.\n\nFor example, One Person Has Many Skills, a Skill is reused between Person(s). \n\nOne more example of this could be relationship between Employee and Project. Each employee can work on multiple Project(s) and each Project can be worked upon by multiple Employee(s). One more example could be relationship between Customer(s) and Product(s) where One or More Customer(s) purchase many different Product(s) and Product(s) can be purchased by different Customer(s)\n\nUnidirectional - A Project can directly reference its Employee(s) by collection\n\nBidirectional - An Employee has Collection of Projects that it relates to.\n\nSome more examples are COURSES - STUDENTS, ORDERS - PRODUCTS etc.\n\n```jsx\n@Entity\npublic class Employee {\n@Id private int id;\n@ManyToMany\nprivate Collection<Project> projects;\n// ...\n}\n@Entity\npublic class Project {\n@Id private int id;\n@ManyToMany(mappedBy="projects")\nprivate Collection<Employee> employees;\n// ...\n}\n```\n\nAssociation or junction table is must to implement a ManyToMany relationship, this separate table connects one line from Employee to one line from Poject using foreign keys. And each primary key of Employee and Project can be copied over multiple times to this table.\n\nHow do we implement ManyToMany mappings with the self entity in JPA?\n\nWe need to maintain two different mappings in the same entity for ManyToMany relationship as shown below \n\n```jsx\n@ManyToMany\n@JoinTable(name="table_friends", joinColumns=@JoinColumn(name="personId"),\ninverseJoinColumns=@JoinColumn(name="friendId"))\nprivate Set<User> friends;\n\n@ManyToMany\n@JoinTable(name="table_friends", joinColumns=@JoinColumn(name="friendId"),\ninverseJoinColumns=@JoinColumn(name="personId"))\nprivate Set<User> friendOf;\n```\n\nIn the above Bidirectional Mapping, One side of relationship will maintain the User\'s list of friends (friends), and the inverse side of relationship will maintain how many people have this User in their friend list (friendOf).\n\nThe Inverse side of the relationship can also be described as \n\n```jsx\n@ManyToMany(mappedBy="friends")\nprivate Set<User> friendOf = new HashSet<User>();\n\n```\n\n**@JoinColumn vs mappedBy**\n\n- mappedBy attribute is used to tell hibernate which entity is the owner side of the relation. This is used mostly in OnetoMany and ManytoOne relationship. This is generally used for bidirectional relationship.\n- @JoinColumn is used for joining the columns and act as foreign key.\n\n\n**JPA Fetch**\n\nBased on fetch configurations that developer has done, JPA allows entities to load the objects with which they have a relationship.\n\nWe can declare the fetch value in the @OneToOne, @OneToMany, @ManyToOne, @ManyToMany annotations. These annotations have an attribute called fetch that serves to indicate the type of the fetch we want to perform. It have two valid values FetchType.EAGER and FetchType.LAZY.\n\nWith LAZY configuration, we are telling JPA that we want to lazily load the relation entities, so when retrieving an entity, its relations will not be loaded until unless we try refer the related entity using getter method. On the Contrary, with EAGER it will load it\'s relation entities as well.\n\nBy default all ToMany relationships are LAZY, while ToOne relationships are EAGER.\n\n\n**Cascade Types**\n\nJPA allows us to propogate entity state changes from Parents to Child entities. This concept is called Cascading in JPA.\n\nThe cascade configuration option accepts an array of CascadeTypes.\n\nThe cascade types supported by JPA are\n\n- CascadeType.PERSIST : means save() or persist() operations cascade to related entities.\n- CascadeType.MERGE : means that related entities are merged when the owning entity is merged.\n- CascadeType.REFRESH : means the child entity also gets reloaded from the database whenever the parent entity is refreshed.\n- CascadeType.REMOVE : means propogates the remove operation from parent to child entity.\n- CascadeType.DETACH : means detach all child entities if a `manual detach` occurs for parent.\n- CascadeType.ALL : is shorthand for all of the above cascade operations.\n\nThere is no default cascade type in JPA. By default, no operation is cascaded.\n\n '}}]);