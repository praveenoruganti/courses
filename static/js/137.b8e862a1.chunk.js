(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[137],{706:function(e,n,t){"use strict";t.r(n),n.default=' ![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/string.PNG)\n\nString is a sequence of characters.\n\nString class is to create and manipulate strings and it is in **java.lang package**.\n\nValue of a String Object once created cannot be modified. Any modification on a String object creates a new String object.\n\n```jsx\nString str3 = "value1";\nstr3.concat("value2");\nSystem.out.println(str3); //value1\n```\nNote that the value of str3 is not modified in the above example. The result should be assigned to a new reference variable (or same variable can be reused). All wrapper class instances are immutable too!\n\n```jsx\nString concat = str3.concat("value2");\nSystem.out.println(concat); //value1value2\n```\n\nThere are 3 types to create a String\n\n- using String literal\n\n  ```jsx\n  String str="Praveen";\n  ```\n\nThis value will be stored in a "String constant pool" \u2013 which is inside the Heap memory. If compiler finds a String literal,it checks if it exists in the pool. If it exists, it is reused.\n\n- using new keyword\n\n  ```jsx\n  String str=new String("Praveen");\n  ```\n\nif new operator is used to create string object, the new object is created on the heap. There will not be any reuse of values.\n\n- using character array\n\n  ```jsx\n  char ch[]={\'P\', \'r\', \'a\', \'v\', \'e\', \'e\', \'n\'};\n  String str=new String(ch) ;\n  ```\n\n## String pool concept\n\n```jsx\nString str="Praveen";\nString str1=new String("Praveen");\nString str2=new String("Kasyap");\n```\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/stringpool.png)\n\na) Stringpool is the special memory region where strings are stored by the JVM\n\nb) As string is immutable in nature, the JVM can optimize the amount of memory allocated for them by storing only one copy of each literal string in the pool. This process is called interning\n\nc) In the above example, we created the string variable str with value Praveen, the JVM searches the pool for a String of equal value. If found the Java compiler will simply return a reference to its memory address without allocating additional memory. If not found, it will be added to the pool(interned) and it\u2019s reference will be returned.\n\nd) In the above example, we created a string str1 with new operatot, the Java compiler will create a new object and store it in the heap space reserved for JVM. Every string created like this will point to a different memory region with its own address.\n\ne) we can manually intern a string in Java stringpool by calling the intern() method on the object we want to intern. Manually interning the string will store it\u2019s reference in the pool and JVM will return this reference when needed.\n\n**String is immutable because of**\n\n- requirement of string pool\n\nIf string is not immutable changing the string with one reference will lead to the wrong value for the other reference.\n\n- allow string to cache the hashcode\n\nThe hashcode of the string is frequently used in Java.\n\nFor example, in a hashtag being immutable guarntees that hashcode will always the same so that it can be cached without worrying the changes that means there is no need to calculate the hashcode everytime it is used. This is more efficient.\n\n- security\n\nString is widely used parameter for many Java classes. For example, network connection, opening files, classloaders, reflection etc.\n\n- safe for multithreading\n\nStringBuffer(Synchronized) and StringBuilder(not Synchronized) class is used to create mutable string.\n\nHere comes == and equals method concept, == is for address comparision and equals for content comparision.\n\n**Let\'s see a sample program**\n\n```jsx\nString a="Praveen";\nString b="Praveen";\nString c= new String("Praveen");\nString d= new Sting("Praveen");\nStringBuffer e= new StringBuffer("Praveen");\nStringBuffer f= new StringBuffer("Praveen");\nStringBuilder g=new StringBuilder("Praveen");\nStringBuilder h=new StringBuilder("Praveen");\nString i=d;\nStringBuffer j=e;\nStringBuilder k=g;\nSystem.out.Println(a==b) ; // true\nSystem.out.Println(a.equals(b)) ; // true\nSystem.out.Println(a==c) ;// false\nSystem.out.Println(a==c.intern()) ;//true\nSystem.out.Println(a.equals(c)) ;//true\nSystem.out.Println(c==d) ;//false\nSystem.out.Println(c.intern() ==d.intern()) ;//true\nSystem.out.Println(c.equals(d)) ;//true\nSystem.out.Println(e==f) ;//false\nSystem.out.Println(e.equals(f)) ;//false\nSystem.out.Println(e.toString().equals(f.toString()) ;//true\nSystem.out.Println(i==d) ;//true\n\n```\n\n**Why should you be careful about String Concatenation(+) operator in Loops?**\n\nConsider the code below:\n\n```jsx\nString s3 = "Value1";\nString s2 = "Value2";\nfor (int i = 0; i < 100000; ++i) {\ns3 = s3 + s2;\n}\n```\nHow many objects are created in memory? More than 100000 Strings are created. This will have a huge performance impact.\n\n**How do you solve above problem?**\n\nThe easiest way to solve above problem is using StringBuffer. On my machine StringBuffer version took 0.5 seconds. String version took 25 Seconds. That\u2019s a 50 fold increase in performance.\n\n```jsx\nStringBuffer s3 = new StringBuffer("Value1");\nString s2 = "Value2";\nfor (int i = 0; i < 100000; ++i) {\ns3.append(s2);\n}\n```\n\nLet\'s see the difference between String, StringBuffer, StringBuilder\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/diff.PNG)\n\n\n '}}]);