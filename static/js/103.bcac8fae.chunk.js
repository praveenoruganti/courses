(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[103],{672:function(n,e,t){"use strict";t.r(e),e.default=' ![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/CountDownLatch.png)\n\n"t.join()" makes the current thread waiting for "t" thread is finished and we can prepare a chain of threads when a thread is waiting for some other. But sometimes CountDownLatch/CyclicBarrier are more convenient.\n\nAlso, to use join(), each thread should have a reference to another thread to call join(). It makes your code a bit dirty especially when you have more than 2 working threads. Sharing of one instance of CountDownLatch/CyclicBarrier looks more clear.\n\nCountDownLatch is to control the execution of threads.\n\nCountDownLatch is a class present in the java.util.concurrent package. It was introduced in java 1.5 release.\n\nCountDownLatch in Java is a kind of synchronizer which allows one Thread to wait for one or more Threads before starts processing.\n\nThis is very crucial requirement and often needed in server side core Java application and having this functionality built-in as CountDownLatch greatly simplifies the development.\n\nCountDownLatch works in latch principle, main thread will wait until Gate is open. One thread waits for n number of threads specified while creating CountDownLatch in Java. Any thread, usually main thread of application, which calls CountDownLatch.await() will wait until count reaches zero or its interrupted by another Thread. All other thread are required to do count down by calling CountDownLatch.countDown() once they are completed or ready to the job. as soon as count reaches zero, Thread awaiting starts running.\n\nOne of the disadvantage of CountDownLatch is that it\u2019s not reusable once count reaches to zero you cannot use CountDownLatch anymore, but don\u2019t worry Java concurrency API has another concurrent utility called CyclicBarrier for such requirements.\n\nThe main difference between CyclicBarrier and CountDownLatch is that CyclicBarrier is reusable and CountDownLatch is not. You can reuse CyclicBarrier by calling reset() method which resets the barrier to its initial state.\n\nCountDownLatch is good for one time event like application/module start-up time and CyclicBarrier can be used to in case of recurrent event e.g. concurrently (re-)calculating each time when the input data changed.\n\nThe key difference is that CountDownLatch separates threads into waiters and arrivers while all threads using a CyclicBarrier perform both roles.\n\nWith a latch, the waiters wait for the last arriving thread to arrive, but those arriving threads don\u2019t do any waiting themselves.\n\nWith a barrier, all threads arrive and then wait for the last to arrive.\n\n**Problem Statement**\n\nJava program requires 3 services namely CacheService, AlertService and ValidationService to be started and ready before application can handle any request.\n\n**Code**\n\n```jsx\npublic class CountDownLatchDemo {\n\npublic static void main(String args[]) {\n    final CountDownLatch latch = new CountDownLatch(3);\n    Thread cacheService = new Thread(new Service("CacheService", 1000, latch));\n    Thread alertService = new Thread(new Service("AlertService", 1000, latch));\n    Thread validationService = new Thread(new Service("ValidationService", 1000, latch));\n\n    cacheService.start(); // separate thread will initialize CacheService\n    alertService.start(); // another thread for AlertService initialization\n    validationService.start();\n\n    // application should not start processing any thread until all service is up\n    // and ready to do there job.\n    // Countdown latch is idle choice here, main thread will start with count 3\n    // and wait until count reaches zero. each thread once up and read will do\n    // a count down. this will ensure that main thread is not started processing\n    // until all services is up.\n\n    // count is 3 since we have 3 Threads (Services)\n\n    try {\n        latch.await(); // main thread is waiting on CountDownLatch to finish\n        System.out.println("All services are up, Application is starting now");\n    } catch (InterruptedException ie) {\n        ie.printStackTrace();\n    }\n    }\n}\n\n/**\n * Service class which will be executed by Thread using CountDownLatch\n * synchronizer.\n */\nclass Service implements Runnable {\n    private final String name;\n    private final int timeToStart;\n    private final CountDownLatch latch;\n\n    public Service(String name, int timeToStart, CountDownLatch latch) {\n        this.name = name;\n        this.timeToStart = timeToStart;\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(timeToStart);\n        } catch (InterruptedException ex) {\n            Logger.getLogger(Service.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        System.out.println(name + " is Up");\n        latch.countDown(); // reduce count of CountDownLatch by 1\n    }\n\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/countdownlatchoutput.png)\n\nBy looking at output of this CountDownLatch example in Java, you can see that Application is not started until all services started by individual Threads are completed.\n\n**Problem Statement**\n\nprint 1\u201310,11\u201320,21\u201330.. so on up to 100 using 10 thread.\n\n**Code**\n\n```jsx\npublic class CountDownLatchExample {\n\npublic static void main(String[] args) {\n    CountDownLatch latch = new CountDownLatch(10);\n    for (int i = 1; i <= 100; i = i + 10) {\n        Printer printer = new Printer(i, i + 9, latch, i * 10);\n        printer.start();\n    }\n    // The main task waits for 10 threads\n    try {\n        latch.await();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    // Main thread has started\n    System.out.println(Thread.currentThread().getName() + " has finished");\n    }\n}\n\nclass Printer extends Thread {\n\nprivate int start;\nprivate int end;\nprivate CountDownLatch latch;\nprivate int delay;\n\npublic Printer(int start, int end, CountDownLatch latch, int delay) {\n    super();\n    this.start = start;\n    this.end = end;\n    this.latch = latch;\n    this.delay = delay;\n}\n\n@Override\npublic void run() {\n    try {\n        Thread.sleep(delay);\n        latch.countDown();\n    for (int i = start; i <= end; i++) {\n        System.out.println(Thread.currentThread().getName() + " : " + i + "\t" + "*");\n    }\n    System.out.println("*****************");\n    } catch (Exception ex) {\n        System.out.println(ex.getLocalizedMessage());\n    }\n\n}\n\n}\n\n```\n\n\n '}}]);