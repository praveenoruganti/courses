(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[43],{612:function(e,t,a){"use strict";a.r(t),t.default=' It is a type of Behavioral Design Pattern.\n\nIn this pattern, we will have base template method; it defines an algorithm with some abstract steps. These steps have to be implemented by sub-classes.\n\nFor example, I have a class called DataRenderer this class is responsible for rendering the data to output console. But to render the data first; we need to read and process it. so we have methods like readData() and processData(). But these methods will be declared as abstract as there are multiple sources from which you can read the data and multiple ways you can process it. But to render the data you need to read and process it, so the algorithm for render() is fixed which is read and process but how to read, from where to read and how to process is left to sub-classes to handle as shown below.\n\n```jsx\npublic abstract class DataRenderer {\n\n\t// algorithm is fixed\n\tpublic final void render() {\n\t\tString data = null;\n\t\tString pData = null;\n\t\tdata = readData();\n\t\tpData = processData(data);\n\t\tSystem.out.println(pData);\n\t}\n\n\tprotected abstract String readData();\n\n\tprotected abstract String processData(String data);\n\n}\n\n```\n\n```jsx\npublic class XMLDataRenderer extends DataRenderer {\n\n\t@Override\n\tprotected String readData() {\n\t\treturn "xml data";\n\t}\n\n\t@Override\n\tprotected String processData(String data) {\n\t\treturn "processed " + data;\n\t}\n\n\n\n}\n```\n\n```jsx\npublic class TextDataRenderer extends DataRenderer {\n\n\t@Override\n\tprotected String readData() {\n\t\treturn "text data";\n\t}\n\n\t@Override\n\tprotected String processData(String data) {\n\t\treturn "processed " + data;\n\t}\n}\n```\n\n```jsx\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tDataRenderer renderer = new XMLDataRenderer();\n\t\trenderer.render();\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\nprocessed xml data\n```\n\nIn the above example the responsibilities of reading and processing the data is left to the sub-classes. render() method remains same calling the methods of your sub-classes.\n\nNow if client wants to render the data, he can create an object of XMLDataRenderer or TextDataRenderer and has to call the render() method which thereby delegate the call to readData() and processData() as per the algorithm shown above.\n\nWe have declared the render() method as final in base class so that the subclasses cannot change the behavior of it.\n\n### Advantages\n\n- There is no code duplication.\n- Code reuse happens with the Template Method pattern as it uses inheritance and not composition. Only a few methods need to be overridden.\n- Flexibility lets subclasses decide how to implement steps in an algorithm.\n\n### Disadvantages\n\n- Debugging and understanding the sequence of flow in the Template Method pattern can be confusing at times. You may end up implementing a method that shouldn\'t be implemented or not implementing an abstract method at all. Documentation and strict error handling has to be done.\n\n\n### Template Method pattern examples in JDK\n- All non-abstract methods of java.io.InputStream, java.io.OutputStream, java.io.Reader and java.io.Writer. e.g. - java.io.InputStream#skip(), java.io.InputStream#read().\n- All non-abstract methods of java.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap. e.g. \u2013 java.util.AbstractList#indexOf(), java.util.Collections#sort(). '}}]);