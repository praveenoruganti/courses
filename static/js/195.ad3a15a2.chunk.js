(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[195],{764:function(e,n,t){"use strict";t.r(n),n.default=' ```jsx\nconst refContainer = useRef(initialValue);\n```\n\n- useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue).\n- The returned object will persist for the full lifetime of the component.\n\nKeep in mind that useRef doesn\'t notify you when its content changes. Mutating the .current property doesn\'t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\nA common use case is to access a child imperatively:\n\n```jsx\nfunction TextInputWithFocusButton() {\n  const inputEl = useRef(null);\n  const onButtonClick = () => {\n    // `current` points to the mounted text input element\n    inputEl.current.focus();\n  };\n  return (\n    <>\n      <input ref={inputEl} type="text" />\n      <button onClick={onButtonClick}>Focus the input</button>\n    </>\n  );\n}\n```\n\nAs you can see in the code above we use the ref property on the input element to set the current value of inputRef to the input element. Now when we click the button it will call focusInput which uses the current value of the inputRef variable to set the focus on the input element.\n\nWhile most use cases for refs lie with referencing DOM elements, refs can also be used for any form of storage that is persisted across component renders. A very common use case for this would be storing the previous value of a state variable.\n\n```jsx\nfunction Component() {\n  const [name, setName] = useState("PraveenOruganti");\n  const previousName = useRef(null);\n  useEffect(() => {\n    previousName.current = name;\n  }, [name]);\n  return (\n    <>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <div>\n        {previousName.current} => {name}\n      </div>\n    </>\n  );\n}\n```\n\nThe above code will update the previousName ref every time the name changes so that it always has the previous value of the name variable stored in it. Refs in React are incredibly useful for accessing and manipulating DOM elements directly. Refs are also amazing at persisting data between renders which is makes it possible to store persisted component data without causing a re-render when it is changed.\n '}}]);