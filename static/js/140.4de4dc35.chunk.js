(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[140],{709:function(e,n,t){"use strict";t.r(n),n.default=" ## JavaScript let\n\nJavaScript let is used to declare variables. Previously, variables were declared using var statements.\n\nThe variables declared using let are block-scoped. This means they are only accessible within a particular block.\n\n```jsx\n// variable declared using let\nlet age=34;\nconsole.log(age); // 34\nage=35;\nconsole.log(age);// 35\n```\n\n## JavaScript const\nThe const statement is used to declare constants in JavaScript.\n```jsx\n// name declared with const cannot be changed\nconst name = 'Praveen Oruganti';\n```\nOnce declared, you cannot change the value of a const variable.\n\n**let and const wrap up**\n\n- The keywords let and const add block scoping in JavaScript.\n- When we declare a variable as let, we cannot re-define or re-declare another let variable with the same name in the same scope (function or block scope) but we can re-assign a value to it.\n- When we declare a variable as const, we cannot re-define or re-declare another const variable with the same name in the same scope (function or block scope). But we can change the values stored in that variable if the variable is of a reference type like an array or object.\n\n## JavaScript Arrow Function\n\nIn the ES6 version, you can use arrow functions to create function expressions.\nFor Example,\n\n```jsx\nfunction add(a,b){\n    return console.log(a+b);\n}\n```\ncan be written as\n```jsx\nconst add = (a, b) => console.log(a + b);\n```\n\n## JavaScript Template Literals\n\nThe template literal has made it easier to include variables inside a string.\nFor example,\n```jsx\nconst greeting = (name) => {\n  const message= 'Hello , '+ name +'!';\n  console.log(message);\n};\n```\nThis can be achieved using template literal.\n\n## Default Parameter Values\nIn the ES6 version, you can pass default values in the function parameters.\nFor example,\n```jsx\nfunction sub(a, b = 0) {\n  return console.log(a - b);\n}\nsub(5, 2); // 7\nsub(5); // 5\n```\n\n## JavaScript Destructuring\n\nThe destructuring syntax makes it easier to assign values to a new variable.\n\nFor example,\n\n```jsx\n// array destructuring\nconst array = [1, 2, 3];\nconst [first, second,third] = array;\nconsole.log(first, third);\n\n// object destructuring\nconst FacebookGroup ={\n    groupName :'Full Stack Development',\n    users : 10000,\n};\nconst {groupName,users} = FacebookGroup;\nconsole.log(groupName,users);\n```\n\n## JavaScript Rest Operator\nYou can use the rest operator to represent an indefinite number of arguments as an array.\nFor example,\n```jsx\nconst add3 =(...numbers) => console.log(numbers.reduce((a,b) => a+b,0));\nadd3(1,2,3,4,5); // 15\n```\n\n### JavaScript Spread Operator\nYou can use the spread syntax ... to copy the items into a single array.\nFor example,\n```jsx\nlet arr1 = ['one', 'two'];\nlet arr2 = [...arr1, 'three', 'four', 'five'];\nconsole.log(arr2); // [\"one\", \"two\", \"three\", \"four\", \"five\"]\n```\nBoth the rest parameter and the spread operator use the same syntax. However, the spread operator is used with arrays (iterable values).\n\n## JavaScript Promises\nA Promise is a special JavaScript object. It produces a value after an asynchronous (aka, async) operation completes successfully, or an error if it does not complete successfully due to time out, network error, and so on.\n\nSuccessful call completions are indicated by the resolve function call, and errors are indicated by the reject function call.\n\n**How to create a Promise**\n\nTo create a promise we need to use the Promise constructor function like this:\n```jsx\nconst promise = new Promise(function(resolve, reject) {\n\n});\n```\nThe Promise constructor takes a function as an argument and that function internally receives resolve and reject as parameters.\n\nThe resolve and reject parameters are actually functions that we can call depending on the outcome of the asynchronous operation.\n\nA Promise goes through three states:\n- Pending: It means the operation is going on.\n- Fulfilled: It means the operation was completed\n- Rejected: It means the operation did not complete and an error can be thrown.\n\nWhen we create a promise, it\u2019s in a pending state. When we call the resolve function, it goes in a fulfilled state and if we call reject it will go in the rejected state.\n\nHowever,\n- To get the result of the successful promise execution, we need to register a callback using .then()\n- To catch the error, we need to register another callback using .catch().\n\n```jsx\npromise.then(function(result) {\n console.log(result);\n}).catch(function(error) {\n console.log(error);\n});\n```\n\nLets see an example with Asynchronous API call,\n\n```jsx\nconst url = \"https://jsonplaceholder.typicode.com/posts\";\n\ngetPosts_Promise().then((posts) => {\n  console.log(posts.length);\n});\n\nfunction getPosts_Promise() {\n  return fetch(url)\n    .then((response) => {\n      return response.json();\n    })\n    .catch((error) => console.log(error));\n};\n\n```\n**Promise chaining**\n\nWe can add multiple .then handlers to a single promise like this:\n```jsx\npromise.then(function(result) {\n console.log('first .then handler');\n return result;\n}).then(function(result) {\n console.log('second .then handler');\n console.log(result);\n}).catch(function(error) {\n console.log(error);\n});\n```\n\n## ES6 Import And Export Syntax\n\nBefore ES6 came into play, we used multiple script tags in a single HTML file to import different JavaScript files like this:\n```HTML\n<script type=\"text/javascript\" src=\"home.js\"><\/script>\n<script type=\"text/javascript\" src=\"profile.js\"><\/script>\n<script type=\"text/javascript\" src=\"user.js\"><\/script>\n```\nSo, if we had a variable with the same name in different JavaScript files, it would create a naming conflict and the value you were expecting would not be the actual value you got.\n\nES6 has fixed this issue with the concept of modules.\n\nEvery JavaScript file we write in ES6 is known as a module. The variables and functions we declare in each file are not available to other files until we specifically export them from that file and import them into another file.\n\nSo the functions and variables defined in the file are private to each file and can\u2019t be accessed outside the file until we export them.\n\n**There are two types of exports:**\n\n- Named Exports: There can be multiple named exports in a single file.\n- Default Exports: There can be only one default export in a single file.\n\n**Named Exports in JavaScript**\n\nTo export a single value as a named export, we export it like this:\n```jsx\nexport const temp = \"This is some dummy text\";\n```\nIf we have multiple things to export, we can write an export statement on a separate line instead of in front of variable declaration. We specify the things to export in curly brackets.\n\n```jsx\nconst temp1 = \"This is some dummy text1\";\nconst temp2 = \"This is some dummy text2\";\nexport { temp1, temp2 };\n```\nNote that the export syntax is not an object literal syntax. So in ES6, to export something we can't use key-value pairs like this:\n\n```jsx\n// This is invalid syntax of export in ES6\nexport { key1: value1, key2: value2 }\n\n```\n\nTo import the things we exported as a named export, we use the following syntax:\n\n```jsx\nimport { temp1, temp2 } from './filename';\n```\n**Note**\n\nWhile importing something from the file, we don't need to add the .js extension to the filename as it's considered by default.\n\n```jsx\n// import from functions.js file from current directory\nimport { temp1, temp2 } from './functions';\n\n// import from functions.js file from parent of current directory\nimport { temp1 } from '../functions';\n```\nOne thing to note is that the name used while exporting has to match the name we use while importing.\n\nThe order in which we import the multiple named exports is not important.\n\nYou can also check out the [Demo](https://praveenoruganti.github.io/courses/demo/js/ES6)\n\n\n\n\n\n\n "}}]);