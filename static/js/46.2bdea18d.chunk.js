(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[46],{615:function(t,e,n){"use strict";n.r(e),e.default=" It is a type of Behavioral Design Pattern.\n\nIt provides a mechanism to change the behavior of an object based on the object's state.\n\n```jsx\npackage com.praveen.designpatterns.behavioral.state;\n\npublic interface MobileAlertState {\n\tvoid alert(AlertStateContext ctx);\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.behavioral.state;\n\npublic class Silent implements MobileAlertState {\n\t@Override\n\tpublic void alert(AlertStateContext ctx) {\n\t\tSystem.out.println(\"silent...\");\n\t}\n\n}\n```\n\n```jsx\npackage com.praveen.designpatterns.behavioral.state;\n\npublic class Vibration implements MobileAlertState {\n\t@Override\n\tpublic void alert(AlertStateContext ctx) {\n\t\tSystem.out.println(\"vibration...\");\n\t}\n\n}\n\n```\n\n\n```jsx\npackage com.praveen.designpatterns.behavioral.state;\n\npublic class AlertStateContext {\n\tprivate MobileAlertState currentState;\n\n\tpublic AlertStateContext() {\n\t\tcurrentState = new Vibration();\n\t}\n\n\tpublic void setState(MobileAlertState state) {\n\t\tcurrentState = state;\n\t}\n\n\tpublic void alert() {\n\t\tcurrentState.alert(this);\n\t}\n}\n\n```\n\n\n```jsx\npackage com.praveen.designpatterns.behavioral.state;\n\npublic class StatePatternTest {\n\n\tpublic static void main(String[] args) {\n\n\t\tAlertStateContext stateContext = new AlertStateContext();\n\t\tstateContext.alert();\n\t\tstateContext.alert();\n\t\tstateContext.setState(new Silent());\n\t\tstateContext.alert();\n\t\tstateContext.alert();\n\t\tstateContext.alert();\n\n\t}\n\n}\n\n```\n\n**Output**\n\n```jsx\nvibration...\nvibration...\nsilent...\nsilent...\nsilent...\n```\n\nThe benefits of using State pattern to implement polymorphic behavior is clearly visible, the chances of error are less and it\u2019s very easy to add more states for additional behavior making it more robust, easily maintainable and flexible. Also State pattern helped in avoiding if-else or switch-case conditional logic in this scenario.\n\n### When to use the State Design Pattern\nUse the State pattern in either of the following cases:\n- An object's behavior depends on its state, and it must change its behavior at run-time depending on that state.\n- Operations have large, multipart conditional statements that depend on the object's state. This state is usually represented by one or more enumerated constants. Often, several operations will contain this same conditional structure. The State pattern puts each branch of the conditional in a separate class. This lets you treat the object's state as an object in its own right that can vary independently from other objects.\n\n\n### State pattern examples in JDK\n- javax.faces.lifecycle.LifeCycle#execute ()\n\n### Strategy vs State Design Pattern\nStrategy Pattern decides on how to perform some action whereas State Pattern decides on when to perform them. "}}]);