(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[146],{715:function(e,n,t){"use strict";t.r(n),n.default=' In JavaScript the code is executed line by line in a sequence so when we run a parallel operation or asynchronous operation like fetching data from backend, JavaScript doesn\'t waits for the response it simply executes the next line of code. we give the asynchronous operation a function to call when it is completed. This function is called a Callback function.\n\n## JavaScript Callbacks\nA callback is a function that is passed to another function. When the first function is done, it will run the second function.\n\n```jsx\nconst url = "https://jsonplaceholder.typicode.com/posts";\n\n// Callback\ngetPosts_Callback(function (error, posts) {\n  if (error) {\n    console.log(error);\n  } else {\n    console.log(posts.length);\n  }\n});\n\nfunction getPosts_Callback(callback) {\n  const xhr = new XMLHttpRequest();\n  xhr.responseType = "json";\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState == XMLHttpRequest.DONE) {\n      callback(null, xhr.response);\n    }\n  };\n  xhr.open("GET", url);\n  try {\n    xhr.send();\n  } catch (error) {\n    callback(error);\n  }\n};\n\n```\nThe problem with callbacks is it creates something called \u201cCallback Hell.\u201d Basically, you start nesting functions within functions within functions, and it starts to get really hard to read the code.\n\nPromises try to fix this nesting problem.\n## JavaScript Promises\nA Promise is a special JavaScript object. It produces a value after an asynchronous (aka, async) operation completes successfully, or an error if it does not complete successfully due to time out, network error, and so on.\n\nSuccessful call completions are indicated by the resolve function call, and errors are indicated by the reject function call.\n\n**How to create a Promise**\n\nTo create a promise we need to use the Promise constructor function like this:\n```jsx\nconst promise = new Promise(function(resolve, reject) {\n\n});\n```\nThe Promise constructor takes a function as an argument and that function internally receives resolve and reject as parameters.\n\nThe resolve and reject parameters are actually functions that we can call depending on the outcome of the asynchronous operation.\n\nA Promise goes through three states:\n- Pending: It means the operation is going on.\n- Fulfilled: It means the operation was completed\n- Rejected: It means the operation did not complete and an error can be thrown.\n\nWhen we create a promise, it\u2019s in a pending state. When we call the resolve function, it goes in a fulfilled state and if we call reject it will go in the rejected state.\n\nHowever,\n- To get the result of the successful promise execution, we need to register a callback using .then()\n- To catch the error, we need to register another callback using .catch().\n\n```jsx\npromise.then(function(result) {\n console.log(result);\n}).catch(function(error) {\n console.log(error);\n});\n```\n\nLets see an example with Asynchronous API call,\n\n```jsx\nconst url = "https://jsonplaceholder.typicode.com/posts";\n\ngetPosts_Promise().then((posts) => {\n  console.log(posts.length);\n});\n\nfunction getPosts_Promise() {\n  return fetch(url)\n    .then((response) => {\n      return response.json();\n    })\n    .catch((error) => console.log(error));\n};\n\n```\nYou can see that it still looks pretty similar. You wrap the whole function in a Promise, and instead of calling the callback, you call resolve (or reject if there is an error). The function returns this Promise object.\n\n### JavaScript Async/Await\nAsync/await is a new approach that was added to JavaScript in ES2017.\nAsync functions are a higher level abstraction over promises.\nAn async function returns a promise.\nIt makes your asynchronous code look more like synchronous/procedural code, which is easier for humans to understand.\nWith one particular caveat: whenever we use the await keyword, we must do so inside a function defined as async .\n\n```jsx\nconst url = "https://jsonplaceholder.typicode.com/posts";\n\ngetPosts_AsyncAwait().then((posts) => {\n  console.log(posts.length);\n});\n\nasync function getPosts_AsyncAwait() {\n  try {\n    const response = await fetch(url);\n    return response.json();\n  } catch (error) {\n    console.log(error);\n  }\n}\n\n```\n\nThe Async/await duo allows us to have a cleaner code and a simple mental model to work with asynchronous code.\n\nYou can check out the [Demo](https://praveenoruganti.github.io/courses/demo/js/Callback)\n\n\n\n '}}]);