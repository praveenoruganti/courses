(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[70],{639:function(t,n,i){"use strict";i.r(n),n.default=" **Complexity Analysis**\n\nThe process of determining how efficient an algorithm is. \n\nComplexity analysis usually involves finding both the time complexity and the space complexity of an algorithm.\n\nComplexity Analysis is efficiently used to determine how good an algorithm is and whether it is better than another one.\n\n**Time Complexity**\n\nA measure of how fast an algorithm runs as the size of the input increases.\n\nit is expressed using Big O notation.\n\n**Note**: Time Complexity != Time taken\n\n**Space Complexity**\n\nA measure of how much auxilary memory an algorithm takes up.\n\nit is expressed using Big O notation.\n\n**What is Big O Notation?**\n\nThe notation used to describe the time complexity and space complexity of algorithms.\n\nVariables used in Big O Notation denotes the size of inputs to algorithms.\n\nFor example, O(n) might be time complexity of an algorithm that traverses through an array of length n; similarly o(n+m) might be the complexity of an algorithm that traverses through an array of length n and through a string of length m.\n\nThe following are the examples of common complexities and their Big O Notations, ordered from fastest to lowest.\n\n- **Constant**: O(1)\n- **Logarithmic**: O(log(n))\n- **Linear**: O(n)\n- **Log-linear**: O(nlog(n))\n- **Quadratic**: O(n^2)\n- **Cubic**: O(n^3)\n- **Exponential**: O(2^n)\n- **Factorial**: O(n!)\n\n**Note** :  Always ignore less dominant terms for example O(n^3 + log(n)) = o(n^3).\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/complexity1.jpg)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/complexity.jpg)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/Complexity.png)\n\n**Notations used in Complexity analysis are**\n\n1. **Omega**\n\n   - This notation gives the tighter lower bound of a given algorithm.\n   - Which means for any given input, running time of a given algorithm will not be less than given time.\n  \n2. **Big O**\n   \n   - This notation gives the tighter upper bound of a given algorithm.\n   - Which means for any given input, running time of a given algorithm will not be greater than given time.\n  \n3. **Theta**\n   \n   - This notation decides whether the lower and upper bound of a given algorithm is same or not.\n   - Which means for any given input, running time of a given algorithm will on an average be equal to given time.\n\n\n**How to measure the codes using Big O?**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/measure.png)\n\n\n**Space Complexity Examples**\n\n```jsx\npackage com.praveen.complexity;\n\npublic class SpaceComplexityExamples {\n\n\t// Space: O(1)\n\tpublic static int example1(int n) {\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\n\t// Space: O(n)\n\tpublic static int[] example2(int[] array) {\n\t\tint n = array.length;\n\t\tint[] result = new int[2 * n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult[i] = array[i];\n\t\t\tresult[n + i] = array[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Space: O(n * m)\n\tpublic static int example3(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint m = matrix[0].length;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tsum += matrix[i][j];\n\t\t\t}\n\t\t}\n\t\tint[] array = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarray[i] = matrix[i][0];\n\t\t}\n\t\treturn sum;\n\t}\n}\n```\n\n**Time Complexity Examples**\n\n```jsx\npackage com.praveen.complexity;\n\npublic class TimeComplexityExamples {\n\n\t// Time: O(n^2)\n\tpublic static boolean hasDuplicates(int[] array) {\n\t\tint n = array.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j && array[i] == array[j]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Time: O(n^2)\n\tpublic static int f(int n) {\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tsum += i * j;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum = sum - i;\n\t\t}\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\n\t// Time: O(n + m)\n\tpublic static int[] union(int[] A, int[] B) {\n\t\tint n = A.length;\n\t\tint m = B.length;\n\t\tint[] C = new int[n + m];\n\t\tint index = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tC[index] = A[i];\n\t\t\tindex++;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tC[index] = B[i];\n\t\t\tindex++;\n\t\t}\n\t\treturn C;\n\t}\n\n\t// Time: O(n * m)\n\tpublic static int matrixSum(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint m = matrix[0].length;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tsum += matrix[i][j];\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\t// Time: O(logn)\n\tpublic static int g(int n) {\n\t\tint result = 0;\n\t\tint i = n;\n\t\twhile (i > 1) {\n\t\t\tresult += i;\n\t\t\ti /= 2;\n\t\t}\n\t\treturn result;\n\t}\n\n}\n\n``` "}}]);