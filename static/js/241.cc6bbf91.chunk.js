(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[241],{810:function(n,t,a){"use strict";a.r(t),t.default=' Bean Validation is the standard for implementing validations in Java ecosystem. It\'s well integrated with SpringBoot.\n\nBelow is the maven dependency that we can add in pom.xml to implement Bean validations in any SpringBoot app.\n\n```jsx\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n\nVery basically, Bean Validation works by defining constraints to the fields of a class by annotating them with certain annotations.\n\nSome of the most common validation annotations are:\n\n- **@NotNull** validates that the annotated property value is not null.\n- **@Size** validates that the annotated property value has a size between the attributes min and max; can be applied to String, Collection, Map, and array properties.\n- **@Min** validates that the annotated property has a value no smaller than the value attribute.\n- **@Max** validates that the annotated property has a value no larger than the value attribute.\n- **@Email** validates that the annotated property is a valid email address.\n- **@NotEmpty** validates that the property is not null or empty; can be applied to String, Collection, Map or Array values.\n- **@NotBlank** can be applied only to text values and validates that the property is not null or whitespace.\n- **@Pattern** to say that a string field is only valid when it matches a certain regular expression.\n\nIn many cases, however, Spring does the validation for us. We don\u2019t even need to create a validator object ourselves. Instead, we can let Spring know that we want to have a certain object validated. This works by using the the @Validated and @Valid annotations.\n\n**@Validated**\n\nThe @Validated annotation is a class-level annotation that we can use to tell Spring to validate parameters that are passed into a method of the annotated class.\n\nLet\'s see an example\n\n```jsx\n\n@RestController\n@RequestMapping("/api/v1_0")\n@Validated\npublic class HelloController {\n  @GetMapping("/hello/{name}")\n  public String sayHelloUser(@PathVariable("name") @NotBlank @Size(max = 20) String name) {\n    return "Hello " + name;\n  }\n}\n\n```\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/validation1.png)\n\n**@Valid**\n\nWe can put the @Valid annotation on method parameters and fields to tell Spring that we want a particular POJO object needs to be validated based on validation annotation configurations.\n\nLet\'s see an example\n\n```jsx\n\n@RestController\n@RequestMapping("/api/v1_0")\n@Validated\npublic class HelloController {\n  @GetMapping("/hello")\n\tpublic HelloResponse sayHello(@RequestBody @Valid User user) {\n\t\treturn HelloResponse.builder().status("Success").appId(user.getAppId()).data(HelloResponseData.builder()\n\t\t\t\t.executed(true).response("Hello " + user.getFirstName() + " " + user.getLastName()).build()).build();\n\t}\n}\n\n```\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/validation3.png)\n\n**Custom Validator**\n\nIf the available constraint annotations do not suffice for our use cases, we might want to create one ourselves.\n\nLet\'s see an example where we will validate the application id.\n\n```jsx\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@SuperBuilder\npublic class User {\n\n\t@AppId\n\t@NotNull\n\tprivate String appId;\n\n\t@Size(max = 10)\n\t@NotBlank\n\tprivate String firstName;\n\n\t@Size(max = 10)\n\t@NotBlank\n\tprivate String lastName;\n}\n\n```\n\n```jsx\n@Target({ ElementType.PARAMETER, ElementType.FIELD })\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = AppIdValidator.class)\n@Documented\npublic @interface AppId {\n\tString message() default "App Id is not valid";\n\n\tClass<?>[] groups() default {};\n\n\tClass<? extends Payload>[] payload() default {};\n\n}\n\n```\n\n```jsx\npublic class AppIdValidator implements ConstraintValidator<AppId, String> {\n\n\tprivate ApplicationConfig applicationConfig;\n\n\t@Inject\n\tpublic AppIdValidator(ApplicationConfig applicationConfig) {\n\t\tthis.applicationConfig = applicationConfig;\n\t}\n\n\t@Override\n\tpublic boolean isValid(final String value, final ConstraintValidatorContext context) {\n\t\treturn applicationConfig.getAppIds() != null && applicationConfig.getAppIds().contains(value);\n\t}\n\n}\n\n```\n\n```jsx\napp:\n appIds:\n   - Test\n```\n\nLet me post the below request\n\n```jsx\n{\n    "appId": "Test1",\n    "firstName":"Praveen",\n    "lastName": "Oruganti"\n}\n```\n\nWe will get the below Constraint Violation Exception as appId is Test1 instead of Test.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/validation5.png)\n '}}]);