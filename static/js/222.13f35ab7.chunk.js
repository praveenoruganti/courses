(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[222],{791:function(n,e,t){"use strict";t.r(e),e.default=' **What is Spring Boot?**\n\nSpring Boot is basically an extension of the Spring framework which eliminates the boilerplate configurations required for setting up a Spring application.\n\n**Features of Spring Boot**\n\n- Create stand-alone Spring applications\n- Provide an embedded HTTP server(such as Embed Tomcat, Jetty or Undertow) so you can get started quickly. No need to install a server separately.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/embedtomcat.jpg)\n\n- Provide opinionated \'starter\' dependencies to simplify your build configuration. Opinionated in the sense, framework choose the configurations.It will configure basic setup for you based on some parameters.\n- Automatically configure Spring and 3rd party libraries whenever possible\n- Provide production-ready features such as metrics, health checks and externalized configuration\n- Absolutely no code generation and no requirement for XML configuration\n- It is highly dependent on the starter templates feature which is very powerful and works flawlessly.\n\n**Spring Vs Spring Boot**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/springvsspringboot.png)\n\n**Spring**\n\n- Dependency Injection Framework\n- Manage lifecycle of java classes(beans)\n- Boiler plate configuration(programmer writes a lot of code to do minimal task)\n- Takes time to have a spring application up and running\n\n**Benefits of Spring Boot**\n\n- Dependency Resolution\n- Minimum Configuration\n- Embedded server for testing\n- Bean auto scan\n- Health metrics\n- Standarization for microservices\n- Cloud support\n- Adapt and support for 3rd party libraries\n\nIn one sentence, Spring Boot is (Spring Framework-XML Configuration)+Integrated server.\n\n**What SpringBoot is NOT!**\n\n- Zero code generation\n- Neither an application server nor a webserver\n\n**Why is it "opinionated"?**\n\nIt makes assumptions on what you need based on dependencies from the classpath. Convention over configuration - pre-configures Spring app by reasonable defaults, which can be overridden.\n\n**How does it work? How does it know what to configure?**\n\nSpring Boot detects the dependencies available on the classpath and configures Spring beans accordingly. There are a number of annotations, examples are @ConditionalOnClass, @ConditionalOnBean, @ConditionalOnMissingBean and @ConditionalOnMissingClass, that allows for applying conditions to Spring configuration classes or Spring bean declaration methods in such classes.\n\n**Examples:**\n\n- A Spring bean is to be created only if a certain dependency is available on the classpath. Use @ConditionalOnClass and supply a class contained in the dependency in question.\n- A Spring bean is to be created only if there is no bean of a certain type or with a certain name created. Use @ConditionalOnMissingBean and specify name or type of bean to check.\n\n**What things affect what Spring Boot sets up?**\n\nThere are a number of condition annotations in Spring Boot each of which can be used to control the creation of Spring beans. The following is a list of the condition annotations in Spring Boot (there are more):\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/annotation.png)\n\n**Creation of Spring Boot Application**\n\n```jsx\n@SpringBootApplication\npublic class MyCoolApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringBootRunner.class);\n\t}\n}\n\n```\n\n**Spring Boot will do the following when you create the application**\n\n- Classpath Scan\n- Default configuration setup\n- Create an appropriate ApplicationContext instance\n- Start embedded application server(for web application)\n\n**Lets see how Spring Boot internally works**\n\n**Starter POM**\n\nMETA-INF/spring.factories\n1.Enable\n2.Disable\n\nBased on @Conditional and @Configuration it will enable the respective component.\n\n**@SpringBootApplication**\n\nThis is a combination of\n\n- @SpringBootConfiguration\n- @EnableAutoConfiguration\n- @ComponentScan\n\n**@SpringBootConfiguration**\n\nIndicates that a class provides Spring Boot application @Configuration. Can be used as an alternative to the Spring\u2019s standard @Configuration annotation so that configuration can be found automatically\n\n**@EnableAutoConfiguration**\n\nThis enables the component at runtime.\nSpring Boot auto-configuration attempts to automatically configure your spring application based on their jar dependencies that you have added.\n\nFor example, in general in Spring MVC, DispatcherServlet and InternalResourceViewResolver will be configured in web.xml or we will go with Java Based configuration.\nIn Spring Boot, DispatcherServlet and InternalResourceViewResolver are autoconfigured to avoid boiler plate configuration.\n\n**@ComponentScan**\n\nThis will be used by Spring IOC container to scan the packages for fetching the bean.\n\n**Why we need main method in Spring Boot application**\n\nSpring Boot Application executes as a standalone application so a main method is necessary and it helps to deploy the application jar in the embedded tomcat.\nSpringApplication.run(\u2026) internal flow\n\n- Create application context\n- Check the application type\n- Register the annotated class beans with the context\n- Creates an instance of TomcatEmbeddedServletContainer and adds the context\n\n**Spring Boot Starters**\n\nStarters are aggregate grouping of multiple dependencies into a single dependency.\n\nIn Spring Boot application, we configure Spring Boot Starter as a dependency in pom.xml. It will automatically adds the spring jars and all other compatible dependencies to the class path of spring application.\n\nMost used starters & dependencies auto configured with them:\n\n- **spring-boot-starter-web**: Spring core, embedded tomcat, spring mvc, jackson, logback\n- **spring-boot-starter-test**: Junit, spring test, mockito\n- **spring-boot-starter-actuator**: Healthcheck, monitoring and metric endpoints\n- **spring-boot-starter-security**: Spring security config, web security\n- **spring-cloud-starter-config**: Spring cloud common, context, config client\n- **spring-boot-starter-oauth2-resource-server**: Spring security core, oauth2, jose\n- **spring-boot-starter-thymeleaf**: Template engine\n- **spring-boot-starter-data-jpa**: Jdbc, hibernate, spring data\n\n\nTo create a Spring Boot Application using Spring Boot support then you have to make your application as a child of Spring Boot parent application\n\nIn pom.xml, we add the following\n\n```jsx\n<parent>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-parent</artifactId>\n\t<version>2.7.0</version>\n\t<relativePath/> <!\u2013 lookup parent from repository \u2013>\n</parent>\n```\n\n**Below are the different ways of running SpringBoot Application**\n\n- Running from an IDE\n- Running as a Packaged Application\n\n**Using STS inbuilt tomcat**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/springboot1.png)\n\n**Running as a Packaged Application**\n\n```jsx\njava -Dserver.port=8080 -jar target/runnerapp.jar\n```\n\nIt is also possible to run a packaged application with remote debugging support enabled. Doing so lets you attach a debugger to your packaged application.\n\n```jsx\njava -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n -jar target/runnerapp.jar\n\n```\n\n\n**How will you run certain business logic at the app startup?**\n\nOften there is a need to execute certain business logic at servlet container startup for e.g. fetching feeds from a remote service, sending a notification about app startup by email, etc.\n\nSpring boot provides two main mechanisms for wiring app startup code. This code will be executed once spring context has been loaded and servlet container is ready to serve requests.\n- Using CommandLineRunner\n- Using ApplicationRunner\n\n\n**Lets see how to use CommandLineRunner**\n\nCommandLineRunner is a simple Spring Boot interface with a run method. Spring Boot will automatically call the run method of all beans implementing this interface after the application context has been loaded.\n\n**Running more than one ApplicationRunner/CommandLineRunner in predefined order**\n\nWe can use @Order(<sequence>) annotation to each ApplicationRunner Bean to run them in specified order.\n\n```jsx\n@SpringBootApplication\npublic class SpringBootRunner {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringBootRunner.class);\n\t\tSystem.out.println("Hello Praveen");\n\t}\n\n}\n\n/*CommandLineRunner with Order Annotation*/\n@Component\n@Order(1)\npublic class SpringBootCommandLineRunner implements CommandLineRunner {\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println("Hi CommandLine Runner");\n\t}\n\n}\n\n/*ApplicationRunner with Order Annotation*/\n@Configuration\n@Order(2)\npublic class SpringBootApplicationRunner implements ApplicationRunner {\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tSystem.out.println("Hello Application Runner");\n\t}\n}\n\n```\n\n```jsx\nHi CommandLine Runner\nHello Application Runner\nHello Praveen\n```\n\nNote: Bean with Order 1 will execute before bean with Order 2.\n\n\nNotice that the run method is called after application context is loaded but before the execution of the main method is complete.\n\nMost console applications will only have a single class that implements CommandLineRunner. If your application has multiple classes that implement CommandLineRunner, the order of execution can be specified using Spring\'s @Order annotation.\n\nIf we configure both Runner but not implements Ordered then by default Annotation based Configuration will be executed first.\n\nWorking process of CommandLineRunner and ApplicationRunner are same, but CommandLineRunner (CLR) holds data in String[] format where as Application (AR) holds data as ApllicationArguments as Option/Non-Option format.\n\n**PostConstruct vs ApplicationRunner**\n\nSpring provides @PostConstruct annotation that can be used for post initialization work on a give component. \nBut @PostConstruct method is invoked after the component has been created by spring container and before entire Spring context have been initialized.\n\nOn the other hand ApplicationRunner code will only run once the entire spring context have been initialized.\n\n\n**Fetch Data from properties file**\n\napplication.properties or application.yml is a primary source input to spring boot (Spring Container).\n\n**application.properties**\n\n- It holds in key=value format\n- Keys are two types\n\na) Spring Boot defined (Predefined) [Reference Link](https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html)\n\nb) Programmer defined\n\nLet\'s see an example\n\napplication.properties\n\n```jsx\nsystem.product.id= 1\nsystem.product.name= Walmart Credit Card\nsystem.product.description= We provide customized walmart credit cards to customers\nsystem.product.code= WCC\n```\n\nNote:\n- Allowed special symbol are dot(.), dash(-) and underscore (_).\n- Key=value both are String type, Spring supports both are String type, Spring supports type conversation (ex String->int) automatically.\n- To read one key-value in code use Legacy syntax : @Value("key")\n\n```jsx\n@Component\n@Data\n@ToString\npublic class SpringBootRunnerWithInputDataUsingValueAnnotation implements CommandLineRunner {\n\t@Value("system.product.id")\n\tprivate int prodId;\n\n\t@Value("system.product.name")\n\tprivate String prodName;\n\n\t@Value("system.product.description")\n\tprivate String prodDesc;\n\n\t@Value("system.product.code")\n\tprivate String prodCode;\n\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println("@Value Annotation" + this);\n\t}\n}\n```\n\n```jsx\n\n@Value Annotation\nSpringBootRunnerWithInputDataUsingValueAnnotation(prodId=1, prodName=Walmart Credit Card, prodDesc=We provide customized walmart credit cards to customers, prodCode=WCC)\n\n```\n\nNote: If key data is mismatched with variable data type, then Spring Container throws Exception : TypeMistchException : Failed to convert value.\n\nWe can also use Environment Object or @ConfigurationProperties to fetch the values from application.properties\n\n**Using Environment Object**\n\n```jsx\n@Component\npublic class SpringBootRunnerWithInputDataUsingEnv implements CommandLineRunner {\n\n\t@Autowired\n\tprivate Environment env;\n\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println("Using Environment");\n\t\tSystem.out.println(env.getProperty("system.product.id"));\n\t\tSystem.out.println(env.getProperty("system.product.name"));\n\t\tSystem.out.println(env.getProperty("system.product.description"));\n\t\tSystem.out.println(env.getProperty("system.product.code"));\n\n\t}\n}\n```\n```jsx\nUsing Environment\n1\nWalmart Credit Card\nWe provide customized walmart credit cards to customers\nWCC\n```\n\n**Using @ConfigurationProperties Annotation**\n\n```jsx\n@Component\n@Data\n@ToString\n@ConfigurationProperties("system.product")\n\npublic class SpringBootRunnerWithInputDataUsingConfigurationProperties implements CommandLineRunner {\n\tprivate int id;\n\n\tprivate String name;\n\n\tprivate String description;\n\n\tprivate String code;\n\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println("@ConfigurationProperties Annotation" + this);\n\t}\n}\n```\n\n\n```jsx\n@ConfigurationProperties Annotation\nSpringBootRunnerWithInputDataUsingConfigurationProperties(id=1, name=Walmart Credit Card, description=We provide customized walmart credit cards to customers, code=WCC)\n```\n\nHere with the complete [code](https://praveenoruganti.github.io/courses/demo/springboot/runnerapp.zip) for your reference. '}}]);