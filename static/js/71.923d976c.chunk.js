(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[71],{640:function(t,e,n){"use strict";n.r(e),e.default=' A linked list is a liner data structure where each element is a separate object. Each element (node) of a list comprises of two items i.e. data and a reference to next node.\n\nThe most powerful feature of linked list is that it is of variable size.\n\n\n**Advantages**\n\n- Dynamic nature.\n- Optimal insertion and deletion.\n- Stacks and Queues can be easily implemented.\n- No memory wastage.\n\n**DisAdvantages**\n\n- More memory usage due to address pointer.\n- Slow traversal compared to Arrays.\n- No reverse traversal in singly linked list.\n- No random access.\n\n\n**Linked List vs Array**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/linkedlistvsarrays.jpg)\n\n\n**Linked List Components**\n\n- **Node**: Contains both data and reference to next node\n- **Head**: Reference to first node in the list\n- **Tail**: Reference to last node in the list\n\n**Common Operations in Linked List**\n\n- Creation of Linked List\n- Insertion of Linked List\n- Traversal of Linked List\n- Searching in a Linked List\n- Deletion of a node from Linked List\n- Deletion of Linked List\n\n**Types of Linked List**\n\n- Single Linked List\n- Circular Single Linked List\n- Double Linked List\n- Circular Double Linked List\n\n**Singly Linked List**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/sll.jpg)\n\nIn a singly linked list, each node stores the data of the node and reference of the next node in the list. It doesn\'t store the reference of previous node.\n\nIt is the most basic form of linked list which give the flexibility to add/remove nodes at runtime.\n\nFor example, single linked list fails for multiplayer board game if we are tracking players turn in linked list.\n\n**Singly Linked List Operations**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/lltime.jpg)\n\n- Accessing the head: O(1).\n- Accessing the tail: O(n).\n- Accessing a middle node: O(n).\n- Inserting or removing the head: O(1).\n- Inserting or removing the tail: O(n) to access + O(1).\n- Inserting or removing a middle node: O(n) to access + O(1).\n- Searching for a value: O(n).\n\n\n```jsx\npackage com.praveen.node;\n\npublic  class SingleNode {\n\tprivate int value;\n\tprivate SingleNode next;\n\npublic int getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void setValue(int value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic SingleNode getNext() {\n\t\treturn next;\n\t}\n\n\tpublic void setNext(SingleNode next) {\n\t\tthis.next = next;\n\t}\n\n@Override\npublic String toString() {\n\treturn  value + "";\n}\n\n}\n\n```\n\n\n```jsx\npackage com.praveen.linkedlist;\n\nimport com.praveen.node.SingleNode;\n\npublic class SingleLinkedList {\n\tprivate SingleNode head;\n\tprivate SingleNode tail;\n\tprivate int size;// denotes size of list\n\n\tpublic SingleNode createSingleLinkedList(int nodeValue) {\n\t\thead = new SingleNode();\n\t\tSingleNode node = new SingleNode();\n\t\tnode.setValue(nodeValue);\n\t\tnode.setNext(null);\n\t\thead = node;\n\t\ttail = node;\n\t\tsize = 1;// size =1\n\t\treturn head;\n\t}\n\n\tpublic SingleNode getHead() {\n\t\treturn head;\n\t}\n\n\tpublic void setHead(SingleNode head) {\n\t\tthis.head = head;\n\t}\n\n\tpublic SingleNode getTail() {\n\t\treturn tail;\n\t}\n\n\tpublic void setTail(SingleNode tail) {\n\t\tthis.tail = tail;\n\t}\n\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\n\tpublic void setSize(int size) {\n\t\tthis.size = size;\n\t}\n\n\tpublic void insertInLinkedList(int nodeValue, int location) {\n\t\tSingleNode node = new SingleNode();\n\t\tnode.setValue(nodeValue);\n\t\tif (!existsLinkedList()) { // Linked List does not exists\n\t\t\tSystem.out.println("The linked list does not exist!!");\n\t\t\treturn;\n\t\t} else if (location == 0) {// insert at first position\n\t\t\tnode.setNext(head);\n\t\t\thead = node;\n\t\t} else if (location >= size) {// insert at last position\n\t\t\tnode.setNext(null);\n\t\t\ttail.setNext(node);\n\t\t\ttail = node;\n\t\t} else {// insert at specified location\n\t\t\tSingleNode tempNode = head;\n\t\t\tint index = 0;\n\t\t\twhile (index < location - 1) {// loop till we reach specified node\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t\tindex++;\n\t\t\t} // tempNode currently references to node after which we should insert new node\n\t\t\tSingleNode nextNode = tempNode.getNext(); // this is the immediate next node after new node\n\t\t\ttempNode.setNext(node);// update reference of tempNode to reference to new node\n\t\t\tnode.setNext(nextNode);// update newly added nodes\' next.\n\t\t}\n\t\tsetSize(getSize() + 1);\n\t}\n\n\tpublic boolean existsLinkedList() {\n\t\t// if head is not null retrun true otherwise return false\n\t\treturn head != null;\n\t}\n\n\t// Traverses Linked List\n\tvoid traverseLinkedList() {\n\t\tif (existsLinkedList()) {\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < getSize(); i++) {\n\t\t\t\tSystem.out.print(tempNode.getValue());\n\t\t\t\tif (i != getSize() - 1) {\n\t\t\t\t\tSystem.out.print(" -> ");\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println("Linked List does not exists !");\n\t\t}\n\t\tSystem.out.println("\n");\n\t}\n\n\t// Deletes entire Linked List\n\tvoid deleteLinkedList() {\n\t\tSystem.out.println("\n\nDeleting Linked List...");\n\t\thead = null;\n\t\ttail = null;\n\t\tSystem.out.println("Linked List deleted successfully !");\n\t}\n\n\t// Searches a node with given value\n\tboolean searchNode(int nodeValue) {\n\t\tif (existsLinkedList()) {\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < getSize(); i++) {\n\t\t\t\tif (tempNode.getValue() == nodeValue) {\n\t\t\t\t\tSystem.out.print("Found the node at location: " + i + "\n");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t}\n\t\tSystem.out.print("Node not found!! \n");\n\t\treturn false;\n\t}\n\n\t// Deletes a node having a given value\n\tpublic void deletionOfNode(int location) {\n\t\tif (!existsLinkedList()) {\n\t\t\tSystem.out.println("The linked list does not exist!!");// Linked List does not exists\n\t\t\treturn;\n\t\t} else if (location == 0) { // we want to delete first element\n\t\t\thead = head.getNext();\n\t\t\tsetSize(getSize() - 1);\n\t\t\tif (getSize() == 0) { // if there are no more nodes in this list\n\t\t\t\ttail = null;\n\t\t\t}\n\t\t} else if (location >= getSize()) { // If location is not in range or equal, then delete last node\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < size - 1; i++) {\n\t\t\t\ttempNode = tempNode.getNext(); // temp node points to 2nd last node\n\t\t\t}\n\t\t\tif (tempNode == head) { // if this is the only element in the list\n\t\t\t\ttail = head = null;\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttempNode.setNext(null);\n\t\t\ttail = tempNode;\n\t\t\tsetSize(getSize() - 1);\n\n\t\t} else { // if any inside node is to be deleted\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < location - 1; i++) {\n\t\t\t\ttempNode = tempNode.getNext(); // we need to traverse till we find the location\n\t\t\t}\n\t\t\ttempNode.setNext(tempNode.getNext().getNext()); // delete the required node\n\t\t\tsetSize(getSize() - 1);\n\t\t}\n\n\t}\n\n}\n\n```\n\n\n**Circular Singly Linked List**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/cll.jpg)\n\nIn case of circular singly linked list, the only change that occurs is that the end of the given list is linked back to the front.\n\nFor example, multiplayer board game if we are tracking players turn in linked list.\n\n```jsx\npackage com.praveen.linkedlist;\n\nimport com.praveen.node.SingleNode;\n\npublic class SingleCircularLinkedList {\n\tprivate SingleNode head;\n\tprivate SingleNode tail;\n\tprivate int size;// denotes size of list\n\n\tSingleNode createSingleLinkedList(int nodeValue) {\n\t\thead = new SingleNode();\n\t\tSingleNode node = new SingleNode();\n\t\tnode.setValue(nodeValue);\n\t\tnode.setNext(node);\n\t\thead = node;\n\t\ttail = node;\n\t\tsize = 1;// size =1\n\t\treturn head;\n\t}\n\n\tpublic SingleNode getHead() {\n\t\treturn head;\n\t}\n\n\tpublic void setHead(SingleNode head) {\n\t\tthis.head = head;\n\t}\n\n\tpublic SingleNode getTail() {\n\t\treturn tail;\n\t}\n\n\tpublic void setTail(SingleNode tail) {\n\t\tthis.tail = tail;\n\t}\n\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\n\tpublic void setSize(int size) {\n\t\tthis.size = size;\n\t}\n\n\tvoid insertInLinkedList(int nodeValue, int location) {\n\t\tSingleNode node = new SingleNode();\n\t\tnode.setValue(nodeValue);\n\t\tSystem.out.println("Inserting new node at location: " + location);\n\t\tif (!existsLinkedList()) {\n\t\t\tSystem.out.println("The linked list does not exist!!");\n\t\t\treturn; // Linked List does not exists\n\t\t} else if (location == 0) {// insert at first position\n\t\t\tnode.setNext(head);\n\t\t\thead = node;\n\t\t\ttail.setNext(node); // update tail\n\t\t} else if (location >= size) {// insert at last position\n\t\t\ttail.setNext(node);\n\t\t\ttail = node; // to keep track of last node\n\t\t\ttail.setNext(head); // update tail to circularly point head\n\t\t} else // insert at specified location\n\t\t{\n\t\t\tSingleNode tempNode = head;\n\t\t\tint index = 0;\n\t\t\twhile (index < location - 1) {// loop till we reach specified node\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t\tindex++;\n\t\t\t} // insert new node after tempNode\n\t\t\tnode.setNext(tempNode.getNext());\n\t\t\ttempNode.setNext(node);\n\t\t}\n\t\tsize++;\n\t}\n\n\tpublic boolean existsLinkedList() {\n\t\t// if head is not null retrun true otherwise return false\n\t\treturn head != null;\n\t}\n\n\t// Traverse Linked List\n\tvoid traverseLinkedList() {\n\t\tif (existsLinkedList()) {\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < size; i++) {\n\n\t\t\t\tSystem.out.print(tempNode.getValue());\n\t\t\t\tif (i != size - 1) {\n\t\t\t\t\tSystem.out.print(" -> ");\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t\tSystem.out.println("\n");\n\t\t} else {\n\t\t\tSystem.out.println("\nLinked List does not exists !");\n\t\t}\n\t}\n\n\t// Traverse Linked List\n\tvoid printHeadUsingTail() {\n\t\tif (existsLinkedList()) {\n\t\t\tSystem.out.println("Printing Tail...");\n\t\t\tSystem.out.println(tail.getValue());\n\n\t\t\tSystem.out.println("Printing Head using Head reference...");\n\t\t\tSystem.out.println(head.getValue());\n\n\t\t\tSystem.out.println("Printing Head using Tail reference...");\n\t\t\tSystem.out.println(tail.getNext().getValue());\n\n\t\t} else {\n\t\t\tSystem.out.println("Linked List does not exists");\n\t\t}\n\t}\n\n\t// Delete linked list\n\tvoid deleteLinkedList() {\n\t\tSystem.out.println("\n\nDeleting Linked List...");\n\t\thead = null;\n\t\tif (tail == null) {\n\t\t\tSystem.out.println("Linked List is already deleted, nothing to delete !");\n\t\t\treturn;\n\t\t} else {\n\t\t\ttail.setNext(null);\n\t\t\ttail = null;\n\t\t\tSystem.out.println("Linked List deleted successfully !");\n\t\t}\n\t}\n\n\t// Search given value in Linked List\n\tboolean searchNode(int nodeValue) {\n\t\tif (existsLinkedList()) {\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < size; i++) {\n\n\t\t\t\t// System.out.print(tempNode.value);\n\t\t\t\tif (tempNode.getValue() == nodeValue) {\n\t\t\t\t\tSystem.out.print("Found the node at location: " + i);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t}\n\t\tSystem.out.print("Node not found!! ");\n\n\t\treturn false;\n\t}\n\n\tpublic void deletionOfNode(int location) {\n\t\tif (!existsLinkedList()) {\n\t\t\tSystem.out.println("The linked list does not exist!!");// Linked List does not exists\n\t\t\treturn;\n\t\t} else if (location == 0) { // we want to delete first element\n\t\t\thead = head.getNext();\n\t\t\ttail.setNext(head);\n\t\t\tsetSize(getSize() - 1);\n\t\t\tif (getSize() == 0) { // if there are no more nodes in this list\n\t\t\t\ttail = null;\n\t\t\t}\n\t\t} else if (location >= getSize()) { // If location is not in range or equal, then delete last node\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < size - 1; i++) {\n\t\t\t\ttempNode = tempNode.getNext(); // temp node points to 2nd last node\n\t\t\t}\n\t\t\tif (tempNode == head) { // if this is the only element in the list\n\t\t\t\ttail = head = null;\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttempNode.setNext(head);\n\t\t\ttail = tempNode;\n\t\t\tsetSize(getSize() - 1);\n\n\t\t} else { // if any inside node is to be deleted\n\t\t\tSingleNode tempNode = head;\n\t\t\tfor (int i = 0; i < location - 1; i++) {\n\t\t\t\ttempNode = tempNode.getNext(); // we need to traverse till we find the location\n\t\t\t}\n\t\t\ttempNode.setNext(tempNode.getNext().getNext()); // delete the required node\n\t\t\tsetSize(getSize() - 1);\n\t\t}\n\n\t}\n\n}\n\n```\n\n**Doubly Linked List**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/dll.jpg)\n\nIn case of double linked list each node contains previous and next node references.\n\nThis is useful when we want to move in both direction depending on requirement.\n\nFor example, Music player has next and previous buttons.\n\n**Doubly Linked List Operations**\n\n- Accessing the head: O(1).\n- Accessing the tail: O(1).\n- Accessing a middle node: O(n).\n- Inserting or removing the head: O(1).\n- Inserting or removing the tail: O(1).\n- Inserting or removing a middle node: O(n) to access + O(1).\n- Searching for a value: O(n).\n\n\n```jsx\npackage com.praveen.linkedlist;\n\nimport com.praveen.node.DoubleNode;\n\npublic class DoubleLinkedList {\n\tDoubleNode head;\n\tDoubleNode tail;\n\tint size;// denotes size of list\n\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\n\tpublic void setSize(int size) {\n\t\tthis.size = size;\n\t}\n\n\tDoubleNode createDoubleLinkedList(int nodeValue) {\n\t\thead = new DoubleNode();\n\t\tDoubleNode node = new DoubleNode();\n\t\tnode.setValue(nodeValue);\n\t\tnode.setNext(null);\n\t\tnode.setPrev(null);\n\t\thead = node;\n\t\ttail = node;\n\t\tsize = 1;// size =1\n\t\treturn head;\n\t}\n\n\tvoid insertInLinkedList(int nodeValue, int location) {\n\t\tDoubleNode node = new DoubleNode();\n\t\tnode.setValue(nodeValue);\n\t\tif (!existsLinkedList()) {\n\t\t\tSystem.out.println("The linked list does not exist!!");\n\t\t\treturn; // Linked List does not exists\n\t\t} else if (location == 0) {// insert at first position\n\t\t\tnode.setNext(head);\n\t\t\tnode.setPrev(null);\n\t\t\thead.setPrev(node);\n\t\t\thead = node;\n\t\t} else if (location >= size) {// insert at last position\n\t\t\tnode.setNext(null);\n\t\t\ttail.setNext(node);\n\t\t\tnode.setPrev(tail);\n\t\t\ttail = node; // to keep track of last node\n\t\t} else {// insert at specified location\n\t\t\tDoubleNode tempNode = head;\n\t\t\tint index = 0;\n\t\t\twhile (index < location - 1) {// loop till we reach specified node\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tnode.setPrev(tempNode);\n\t\t\tnode.setNext(tempNode.getNext());\n\t\t\ttempNode.setNext(node);\n\t\t\tnode.getNext().setPrev(node);\n\t\t}\n\t\tsize++;\n\t}\n\n\tpublic boolean existsLinkedList() {\n\t\t// if head is not null retrun true otherwise return false\n\t\treturn head != null;\n\t}\n\n\t// Traverse the linked list from head to last\n\tvoid traverseLinkedList() {\n\t\tif (existsLinkedList()) {\n\t\t\t// System.out.println("Linked List now: ");\n\t\t\tDoubleNode tempNode = head;\n\t\t\tfor (int i = 0; i < size; i++) {\n\n\t\t\t\tSystem.out.print(tempNode.getValue());\n\t\t\t\tif (i != size - 1) {\n\t\t\t\t\tSystem.out.print(" -> ");\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println("Linked List does not exists");\n\t\t}\n\t\tSystem.out.println("\n");\n\t}\n\n\t// Traverse the linked list from head to last\n\tvoid traverseLinkedListInReverseOrder() {\n\t\tif (existsLinkedList()) {\n\t\t\tDoubleNode tempNode = tail;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tSystem.out.print(tempNode.getValue());\n\t\t\t\tif (i != size - 1) {\n\t\t\t\t\tSystem.out.print(" <- ");\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getPrev();\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println("Linked List does not exists");\n\t\t}\n\t\tSystem.out.println("\n");\n\t}\n\n\t// delete whole linked list\n\tvoid deleteLinkedList() {\n\t\tSystem.out.println("\n\nDeleting Linked List...");\n\t\tDoubleNode tempNode = head;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\ttempNode.setPrev(null);\n\t\t\ttempNode = tempNode.getNext();\n\t\t}\n\n\t\thead = null;\n\t\ttail = null;\n\t\tSystem.out.println("Linked List deleted successfully !");\n\t}\n\n\t// Search for a node in linked list\n\tboolean searchNode(int nodeValue) {\n\t\tif (existsLinkedList()) {\n\t\t\tDoubleNode tempNode = head;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tif (tempNode.getValue() == nodeValue) {\n\t\t\t\t\tSystem.out.print("Found the node at locaiton: " + i);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t}\n\t\tSystem.out.print("Node not found!! ");\n\t\treturn false;\n\t}\n\n\t// Deletes a node having a given value\n\tpublic void deletionOfNode(int location) {\n\t\tif (!existsLinkedList()) {\n\t\t\tSystem.out.println("The linked list does not exist!!");// Linked List does not exists\n\t\t\treturn;\n\t\t} else if (location == 0) { // we want to delete first element\n\t\t\tif (getSize() == 1) { // if this is the only node in this list\n\t\t\t\thead = tail = null;\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\thead = head.getNext();\n\t\t\t\thead.setPrev(null);\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t}\n\t\t} else if (location >= getSize()) { // If location is not in range or equal, then delete last node\n\t\t\tDoubleNode tempNode = tail.getPrev(); // temp node points to 2nd last node\n\t\t\tif (tempNode == head) { // if this is the only element in the list\n\t\t\t\ttail = head = null;\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttempNode.setNext(null);\n\t\t\ttail = tempNode;\n\t\t\tsetSize(getSize() - 1);\n\n\t\t} else { // if any inside node is to be deleted\n\t\t\tDoubleNode tempNode = head;\n\t\t\tfor (int i = 0; i < location - 1; i++) {\n\t\t\t\ttempNode = tempNode.getNext(); // we need to traverse till we find the location\n\t\t\t}\n\t\t\ttempNode.setNext(tempNode.getNext().getNext()); // delete the required node\n\t\t\ttempNode.getNext().setPrev(tempNode);\n\t\t\tsetSize(getSize() - 1);\n\t\t}\n\n\t}\n\n}\n\n```\n\n\n**Circular Doubly Linked List**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/dcll.jpg)\n\nIn case of circular doubly single linked list, the only change that occurs is that the end of the given list is linked back to the front of the list and vice versa.\n\nThis is useful when we want to loop through the list indefinitely until the list exists. We want to move both forward and backward.\n\nFor example, ALT+TAB button in Windows.\n\n```jsx\npackage com.praveen.linkedlist;\n\nimport com.praveen.node.DoubleNode;\n\npublic class DoubleCircularLinkedList {\n\tprivate DoubleNode head;\n\tprivate DoubleNode tail;\n\tprivate int size;// denotes size of list\n\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\n\tpublic void setSize(int size) {\n\t\tthis.size = size;\n\t}\n\n\tDoubleNode createDoubleLinkedList(int nodeValue) {\n\t\thead = new DoubleNode();\n\t\tDoubleNode node = new DoubleNode();\n\t\tnode.setValue(nodeValue);\n\t\tnode.setNext(node);\n\t\tnode.setPrev(node);\n\t\thead = node;\n\t\ttail = node;\n\t\tsize = 1;// size =1\n\t\treturn head;\n\t}\n\n\tpublic DoubleNode getHead() {\n\t\treturn head;\n\t}\n\n\tpublic void setHead(DoubleNode head) {\n\t\tthis.head = head;\n\t}\n\n\tpublic DoubleNode getTail() {\n\t\treturn tail;\n\t}\n\n\tpublic void setTail(DoubleNode tail) {\n\t\tthis.tail = tail;\n\t}\n\n\tpublic int getLast() {\n\t\treturn size;\n\t}\n\n\tpublic void setLast(int last) {\n\t\tthis.size = last;\n\t}\n\n\tvoid insertInLinkedList(int nodeValue, int location) {\n\t\tDoubleNode node = new DoubleNode();\n\t\tnode.setValue(nodeValue);\n\t\tif (!existsLinkedList()) {\n\t\t\tSystem.out.println("The linked list does not exist!!");\n\t\t\treturn; // Linked List does not exists\n\t\t} else if (location == 0) {// insert at first position\n\t\t\tnode.setNext(head);\n\t\t\tnode.setPrev(tail);\n\t\t\thead.setPrev(node);\n\t\t\ttail.setNext(node);\n\t\t\thead = node;\n\t\t} else if (location >= size) { // insert at last position\n\t\t\tnode.setNext(head);\n\t\t\tnode.setPrev(tail);\n\t\t\thead.setPrev(node);\n\t\t\ttail.setNext(node);\n\t\t\ttail = node; // to keep track of last node\n\t\t} else {// insert at specified location\n\t\t\tDoubleNode tempNode = head;\n\t\t\tint index = 0;\n\t\t\twhile (index < location - 1) {// loop till we reach specified node\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tnode.setPrev(tempNode);\n\t\t\tnode.setNext(tempNode.getNext());\n\t\t\ttempNode.setNext(node);\n\t\t\tnode.getNext().setPrev(node);\n\t\t}\n\t\tsize++;// one node added so size increments\n\t}\n\n\tpublic boolean existsLinkedList() {\n\t\t// if head is not null retrun true otherwise return false\n\t\treturn head != null;\n\t}\n\n\t// Traverse Linked List\n\tvoid traverseLinkedList() {\n\t\tif (existsLinkedList()) {\n\t\t\tDoubleNode tempNode = head;\n\t\t\tfor (int i = 0; i < size; i++) {\n\n\t\t\t\tSystem.out.print(tempNode.getValue());\n\t\t\t\tif (i != size - 1) {\n\t\t\t\t\tSystem.out.print(" -> ");\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println("Linked List does not exists !");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t// Traverse Linked List reverse order\n\tvoid traverseLinkedListInReverseOrder() {\n\t\tif (existsLinkedList()) {\n\t\t\tDoubleNode tempNode = tail;\n\t\t\tSystem.out.println("\nPrinting Linked list in reverse order...");\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tSystem.out.print(tempNode.getValue());\n\t\t\t\tif (i != size - 1) {\n\t\t\t\t\tSystem.out.print(" <- ");\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getPrev();\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println("Linked List does not exists !");\n\t\t}\n\t}\n\n\t// Traverse Linked List\n\tvoid printHeadUsingTail() {\n\t\tif (existsLinkedList()) {\n\t\t\tSystem.out.println("\n\nPrinting Tail...");\n\t\t\tSystem.out.println(tail.getValue());\n\n\t\t\tSystem.out.println("\nPrinting Head using Head reference...");\n\t\t\tSystem.out.println(head.getValue());\n\n\t\t\tSystem.out.println("\nPrinting Head using Tail reference...");\n\t\t\tSystem.out.println(tail.getNext().getValue());\n\n\t\t} else {\n\t\t\tSystem.out.println("Linked List does not exists");\n\t\t}\n\t}\n\n\t// Deletion of linked list\n\tvoid deleteLinkedList() {\n\t\tSystem.out.println("\n\nDeleting Linked List...");\n\t\tif (tail == null) {\n\t\t\tSystem.out.println("Linked List is already deleted, nothing to delete anymore !");\n\t\t\treturn;\n\t\t} else {\n\t\t\thead.setPrev(null);\n\t\t\ttail.setNext(null);\n\t\t\thead = null;\n\t\t\ttail = null;\n\t\t\tSystem.out.println("Linked List deleted successfully !");\n\t\t}\n\t}\n\n\t// Searching a specified value in linked list\n\tboolean searchNode(int nodeValue) {\n\t\tif (existsLinkedList()) {\n\t\t\tDoubleNode tempNode = head;\n\t\t\ttraverseLinkedList();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tif (tempNode.getValue() == nodeValue) {\n\t\t\t\t\tSystem.out.print("Found the node at location: " + i);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttempNode = tempNode.getNext();\n\t\t\t}\n\t\t}\n\t\tSystem.out.print("Node not found!! ");\n\t\treturn false;\n\t}\n\n\t// Deletes a node having a given value\n\tpublic void deletionOfNode(int location) {\n\t\tif (!existsLinkedList()) {\n\t\t\tSystem.out.println("The linked list does not exist!!");// Linked List does not exists\n\t\t\treturn;\n\t\t} else if (location == 0) { // we want to delete first element\n\t\t\tif (getSize() == 1) { // if this is the only node in this list\n\t\t\t\thead.setNext(null);\n\t\t\t\thead.setPrev(null);\n\t\t\t\thead = tail = null;\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\thead = head.getNext();\n\t\t\t\thead.setPrev(null);\n\t\t\t\ttail.setNext(head);\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t}\n\t\t} else if (location >= getSize()) { // If location is not in range or equal, then delete last node\n\t\t\tif (getSize() == 1) { // if this is the only element in the list\n\t\t\t\thead.setNext(null);\n\t\t\t\thead.setPrev(null);\n\t\t\t\ttail = head = null;\n\t\t\t\tsetSize(getSize() - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttail = tail.getPrev();\n\t\t\ttail.setNext(head);\n\t\t\thead.setPrev(tail);\n\t\t\tsetSize(getSize() - 1);\n\t\t} else { // if any inside node is to be deleted\n\t\t\tDoubleNode tempNode = head;\n\t\t\tfor (int i = 0; i < location - 1; i++) {\n\t\t\t\ttempNode = tempNode.getNext(); // we need to traverse till we find the location\n\t\t\t}\n\t\t\ttempNode.setNext(tempNode.getNext().getNext()); // delete the required node\n\t\t\ttempNode.getNext().setPrev(tempNode);\n\t\t\tsetSize(getSize() - 1);\n\t\t}\n\n\t}\n\n}\n\n```\n\n**How is Linked List stored in memory(RAM)?**\n\nAs you see the below diagram, In Linked List cells will not be stored in contiguous memory location like an Array and it stores in uneven location.\n\n**Linked List Applications**\n\n- Dynamic memory allocation\n- Implemented in stack and queue\n- In undo functionality of softwares\n- Hash tables, Graphs\n\n\n '}}]);