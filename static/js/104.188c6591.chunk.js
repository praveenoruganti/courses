(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[104],{673:function(e,r,a){"use strict";a.r(r),r.default=' ![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/CyclicBarrier.png)\n\nCyclicBarrier in Java is a synchronizer introduced in JDK 5 on java.util.Concurrent package along with other concurrent utility like Counting Semaphore, BlockingQueue, ConcurrentHashMap etc.\n\nCyclicBarrier is similar to CountDownLatch which allows multiple threads to wait for each other (barrier) before proceeding.\n\nCyclicBarrier is a natural requirement for a concurrent program because it can be used to perform final part of the task once individual tasks are completed.\n\nAll threads which wait for each other to reach barrier are called parties, CyclicBarrier is initialized with a number of parties to wait and threads wait for each other by calling CyclicBarrier.await() method which is a blocking method in Java and blocks until all Thread or parties call await().\nIn general calling await() is shout out that Thread is waiting on the barrier.\n\nawait() is a blocking call but can be timed out or Interrupted by other thread.\nIf you look at CyclicBarrier, it also the does the same thing but there is different you cannot reuse CountDownLatch once the count reaches zero while you can reuse CyclicBarrier by calling reset () method which resets Barrier to its initial State.\n\nWhat it implies that CountDownLatch is a good for one-time events like application start-up time and CyclicBarrier can be used to in case of the recurrent event e.g. concurrently calculating a solution of the big problem etc.\n\n**Example**\n\nHere is a simple example of CyclicBarrier in Java on which we initialize CyclicBarrier with 3 parties, means in order to cross barrier, 3 thread needs to call await() method.\nEach thread calls await method in short duration but they don\u2019t proceed until all 3 threads reached the barrier, once all thread reach the barrier, barrier gets broker and each thread started their execution from that point.\n\n**Code**\n\n```jsx\npublic class CyclicBarrierExample {\n    // Runnable task for each thread\n    private static class Task implements Runnable {\n    private CyclicBarrier barrier;\n    public Task(CyclicBarrier barrier) {\n    this.barrier = barrier;\n    }\n\n    @Override\n        public void run() {\n            try {\n\n                System.out.println(Thread.currentThread().getName() + " is waiting on barrier");\n                barrier.await();\n                System.out.println(Thread.currentThread().getName() + " has crossed the barrier");\n\n            } catch (InterruptedException ex) {\n\n                Logger.getLogger(CyclicBarrierExample.class.getName()).log(Level.SEVERE, null, ex);\n\n            } catch (BrokenBarrierException ex) {\n\n                Logger.getLogger(CyclicBarrierExample.class.getName()).log(Level.SEVERE, null, ex);\n\n            }\n\n            }\n\n       }\n\npublic static void main(String args[]) {\n    // creating CyclicBarrier with 3 parties i.e. 3 Threads needs to call await()\n\n    final CyclicBarrier cb = new CyclicBarrier(3, new Runnable() {\n\n    @Override public void run() {\n\n    // This task will be executed once all thread reaches barrier\n    System.out.println("All parties are arrived at barrier, lets play");\n\n    }\n\n    });\n    // starting each of thread\n\n    Thread t1 = new Thread(new Task(cb), "Thread 1");\n    Thread t2 = new Thread(new Task(cb), "Thread 2");\n    Thread t3 = new Thread(new Task(cb), "Thread 3");\n    t1.start();\n    t2.start();\n    t3.start();\n    }\n\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/CyclicBarrieroutput.png)\n\n**When to use CyclicBarrier in Java**\n\nGiven the nature of CyclicBarrier it can be very handy to implement map reduce kind of task similar to fork-join framework of Java 7, where a big task is broken down into smaller pieces and to complete the task you need output from individual small taske.g. to count population of India you can have 4 threads which count population from North, South, East, and West and once complete they can wait for each other, When last thread completed their task, Main thread or any other thread can add result from each zone and print total population.\n\n**You can use CyclicBarrier in Java**\n\n1. To implement multi player game which cannot begin until all player has joined.\n2. Perform lengthy calculation by breaking it into smaller individual tasks, In general, to implement Map reduce technique.\n\n**Important point of CyclicBarrier in Java**\n\n1. CyclicBarrier can perform a completion task once all thread reaches to the barrier, this can be provided while creating CyclicBarrier.\n2. If CyclicBarrier is initialized with 3 parties means 3 thread needs to call await method to break the barrier.\n3. The thread will block on await() until all parties reach to the barrier, another thread interrupt or await timed out.\n4. If another thread interrupts the thread which is waiting on barrier it will throw BrokernBarrierException.\n5. CyclicBarrier.reset() put Barrier on its initial state, other thread which is waiting or not yet reached barrier will terminate with java.util.concurrent.BrokenBarrierException.\n\n\n '}}]);