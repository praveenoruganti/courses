(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[141],{710:function(e,n,t){"use strict";t.r(n),n.default=" Whenever you create a function within another function, you have created a closure. The inner function is the closure. This closure is usually returned so you can use the outer function\u2019s variables at a later time.\n\n```jsx\nfunction outerFunction () {\n  const outer = `I see the outer variable!`\n\n  function innerFunction() {\n    console.log(outer)\n  }\n\n  return innerFunction\n}\n\nouterFunction()() // I see the outer variable!\n```\n\nSince the inner function is returned, you can also shorten the code a little by writing a return statement while declaring the function.\n\n```jsx\nfunction outerFunction () {\n  const outer = `I see the outer variable!`\n\n  return function innerFunction() {\n    console.log(outer)\n  }\n}\n\nouterFunction()() // I see the outer variable!\n```\n\nSince closures have access to the variables in the outer function, they are usually used for two things:\n- To control side effects\n- To create private variables\n\n## Controlling side effects with closures\nSide effects happen when you do something in aside from returning a value from a function. Many things can be side effects, like an Ajax request, a timeout or even a console.log statement:\n\n```jsx\nfunction (x) {\n  console.log('A console.log is a side effect!')\n}\n```\n\nWhen you use closures to control side effects, you\u2019re usually concerned with ones that can mess up your code flow like Ajax or timeouts.\n\nLets go through this with an example to make things clearer.\n\nLets say you want to make a cake for your friend\u2019s birthday. This cake would take a second to make, so you wrote a function that logs made a cake after one second.\n\n```jsx\nfunction makeCake() {\n  setTimeout(_ => console.log(`Made a cake`), 1000)\n}\n```\nAs you can see, this cake making function has a side effect: a timeout.\n\nThat\u2019s how closures are used to reduce side effects \u2013 you create a function that activates the inner closure at your whim.\n\n## Private variables with closures\n\nAs you know by now, variables created in a function cannot be accessed outside the function. Since they can\u2019t be accessed, they are also called private variables.\n\nHowever, sometimes you need to access such a private variable. You can do so with the help of closures.\n\n```jsx\nfunction secret (secretCode) {\n  return {\n    saySecretCode () {\n      console.log(secretCode)\n    }\n  }\n}\n\nconst theSecret = secret('Praveen Oruganti Rocks!!')\ntheSecret.saySecretCode()\n// 'Praveen Oruganti Rocks!!'\n```\nsaySecretCode in this example above is the only function (a closure) that exposes the secretCode outside the original secret function. As such, it is also called a privileged function.\n\n**Note**\n\nGenerally, closures are used for data privacy.\n\n## Summary\n\nWhen you declare a variable in a function, you can only access it in the function. These variables are said to be scoped to the function.\n\nIf you define any inner function within another function, this inner function is called a closure. It retains access to the variables created in the outer function.\n\nYou can also check out the [Demo](https://praveenoruganti.github.io/courses/demo/js/Closure)\n\n\n\n "}}]);