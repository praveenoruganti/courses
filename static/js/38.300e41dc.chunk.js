(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[38],{607:function(e,n,t){"use strict";t.r(n),n.default=" Before deep diving into Design patterns lets see SOLID principles.\n\n## What is the Purpose of SOLID ?\n\n- To make the code more maintainable.\n- To make it easier to quickly extend the system with new functionality without breaking the existing ones.\n- To make the code easier to read and understand, thus spend less time figuring out what it does and more time actually developing the solution.\n- Introduced by Robert Martin(Uncle Bob), named by Michael Feathers.\n\n**5 Class Design principles(SOLID) in java**\n\n**S** : Single Responsibility Principle\n\n**O** :  Open Closed Principle\n\n**L** : Liskov's Substitution Principle\n\n**I** : Interface Segregation Principle\n\n**D** : Dependency Inversion Principle\n\n\n**Single Responsibility Principle(SRP)**\n\nA Class should have one and only reason to change i.e a class should have only one responsibility.\n\nFor example,\n\n```jsx\npublic class UserService{\n\npublic void validate(User user){\n// some logic\n}\npublic void makePayment(User fromUser,User toUser){\n// some logic\n}\n}\n\nWhat changes can be made to better follow SRP?\n\npublic class ValidationUserService{\n\npublic void validate(User user){\n// some logic\n}\n}\n\npublic class BankingUserService{\n\npublic void makePayment(User fromUser,User toUser){\n// some logic\n}\n}\n```\n\nEach class now has a single responsibility when we want to change the payment logic for a user, we only change the BankingUserService.\n\n\n**Open Closed Principle(OCP)**\n\nSoftware components should be open for extension but closed for modification.\n\nFactory pattern is an example for this and please refer my article for the same.\n\nAll existing code remains unchanged and all existing tests continue to pass.\n\n**Liskov's substitution principle**\n\nDerived types must be completely substitutable for their base types.\n\n**Interface Segregation principle**\n\nClients should not be forced to implement unnecessary methods which they will not use.\n\nIts best to granular a flat interface based on the scenario.\n\n**Dependency Inversion principle**\n\nDepends on Abstraction not on concretion for example Stream,BeanFactory etc.\n\n\n## Why Design Patterns?\n\n1. Design patterns are used for solving recursive problems in a software application design.\n2. A design pattern is a description for how to solve a recursive problem.\n3. Design patterns are not a technology or a tool or a language or a platform or a framework.\n4. Design patterns are effective proven solutions for recursive problems.\n\n## How many Design Patterns?\n\nSUN Microsystems constituted a group with four professional with the name of Gang of Four (GOF) to find effective solutions for the recursive problems.\n\nAccording to GOF, they found 23 design patterns as effective solutions for re-occurring problems.\n\nJava design patterns are divided into 3 i.e. Creational, Structural and Behavioral.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/designpatterns.jpg)\n\n### Creational patterns\n\nCreational patterns are ones that create objects for you, rather than having you instantiate objects directly. \n\nThis gives your program more flexibility in deciding which objects need to be created for a given case. \n\n\nHere with the Creational Design Patterns\n\n- **Singleton** : Ensure a class has only one instance, and provide a point of access to it.\n- **Builder** : Separates the construction of the complex object from its representation so that the same construction process can create different representations.\n- **Factory** : Defines an interface for creating an object ,but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\n- **Abstract Factory** : Provide an interface for creating families of related or dependent objects without specifying their concrete classes.\n- **Prototype** : Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.\n\n### Structural patterns\n\nStructural patterns provide different ways to create a class structure, for example using inheritance and composition to create a large object from small objects.\n\nHere with the Structural Design Patterns.\n\n- **Bridge** : Decouple an abstraction from its implementation so that two can vary independently.\n- **Adapter** : Convert the interface of a class into another interface clients expect.\n- **Composite** : Compose objects into three objects to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\n- **Decorator** : Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to sub classing for extending functionality.\n- **Proxy** : Provide a surrogate or placeholder for another object to control access to it.\n- **Facade** : Provide a unified interface to a set of interfaces in a subsystem's Facade defines a higher-level interface that makes the subsystem easier to use.\n- **Flyweight** : Use sharing to support large numbers of fine-grained objects efficiently.\n\n\n### Behavioral patterns\n\nA solution for the ideal interaction between objects and how to provide loose coupling and flexibility.\n\nHere with the behavioral patterns\n\n- **Template Method** : Define the Skelton of an operation, deferring some steps to subclasses. Template method subclasses redefine certain steps of an algorithm without changing the algorithms structure.\n- **Mediator** : It promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.\n- **Strategy** : Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n- **State** : Allow an object to alter its behavior when its internal state changes. the object will appear to change its class.\n- **Chain of Responsibility** : Avoid coupling the sender of a request to it\u2018s receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an objects handles it.\n- **Observer** : Define a one-to-many dependency between objects so that when one object changes state, all it\u2018s dependents are notified and updated automatically.\n- **Command** : Encapsulate a request as an object ,thereby letting parameterize clients with different request, queue or log requests, and support undoable operations.\n- **Visitor** : Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.\n- **Iterator** : Provides a way to access the elements of an aggregate object without exposing its underlying representation.\n- **Interpreter** : Given a language, defining a representation of its grammar along with an interpreter that uses the representation to interpret sentences in the language.\n- **Memento** : Without violating encapsulation, capture and externalize an object\u2018s internal state so that object can be restored to this state later.\n\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/designpatternsrelationships.jpg)\n "}}]);