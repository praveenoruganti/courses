(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[242],{811:function(t,n,e){"use strict";e.r(n),n.default=' Spring Boot provides us tools to handle exceptions beyond simple \u2018try-catch\u2019 blocks. To use these tools, we apply a couple of annotations that allow us to treat exception handling as a cross-cutting concern:\n\n- @ResponseStatus\n- @ExceptionHandler\n- @ControllerAdvice or @RestControllerAdvice\n\nBefore Jumping into the above annotations lets see the challenges with SpringBoot Default Exception Handling.\n\nFor any exception, SpringBoot provides default error like 400 or 500 based on the scenario.\n\n```jsx\n{\n    "timestamp": "2019-11-26T21:54:27.957+00:00",\n    "status": 400,\n    "error": "Bad Request",\n    "path": "/api/v1_0/hello"\n}\n```\n\n```jsx\n{\n  "timestamp": "2019-11-26T21:59:27.957+00:00",\n  "status": 500,\n  "error": "Internal Server Error",\n  "message": "",\n  "path": "/api/v1_0/hello"\n}\n\n\n```\n\nNow lets fix this by creating ExceptionControllerAdvice Class\n\n```jsx\n@RestControllerAdvice\n@Slf4j\npublic class ExceptionControllerAdvice {\n\tprivate ApplicationConfig applicationConfig;\n\n\tpublic ExceptionControllerAdvice(ApplicationConfig applicationConfig) {\n\t\tthis.applicationConfig = applicationConfig;\n\t}\n\n\t@ExceptionHandler(HttpMessageNotReadableException.class)\n\tpublic ResponseEntity<HelloResponse> handleHttpMessageNotReadableException() {\n\t\tMap<String, String> validationErrors = Maps.newHashMap();\n\n\t\tvalidationErrors.put(applicationConfig.getMessageNotReadableError().getCode(),\n\t\t\t\tapplicationConfig.getMessageNotReadableError().getDescription());\n\t\tHelloResponse empResponse = HelloResponse.builder().status(Constants.FAIL)\n\t\t\t\t.appId(InputRequestContextHolder.getAppId())\n\t\t\t\t.errors(ErrorMessage.builder().code(applicationConfig.getClientError().getCode())\n\t\t\t\t\t\t.description(applicationConfig.getClientError().getDescription()).errors(validationErrors)\n\t\t\t\t\t\t.build())\n\t\t\t\t.build();\n\n\t\treturn errorResponse(HttpStatus.BAD_REQUEST, empResponse);\n\n\t}\n\n\t@ExceptionHandler(HttpRequestMethodNotSupportedException.class)\n\tpublic ResponseEntity<HelloResponse> handleHttpMethodNotAllowedException() {\n\t\tMap<String, String> validationErrors = Maps.newHashMap();\n\n\t\tvalidationErrors.put(applicationConfig.getInvalidHttpMethodError().getCode(),\n\t\t\t\tapplicationConfig.getInvalidHttpMethodError().getDescription());\n\t\tHelloResponse empResponse = HelloResponse.builder().status(Constants.FAIL)\n\t\t\t\t.appId(InputRequestContextHolder.getAppId())\n\t\t\t\t.errors(ErrorMessage.builder().code(applicationConfig.getClientError().getCode())\n\t\t\t\t\t\t.description(applicationConfig.getClientError().getDescription()).errors(validationErrors)\n\t\t\t\t\t\t.build())\n\t\t\t\t.build();\n\n\t\treturn errorResponse(HttpStatus.METHOD_NOT_ALLOWED, empResponse);\n\n\t}\n\n\t@ExceptionHandler(ConstraintViolationException.class)\n\tpublic ResponseEntity<HelloResponse> handleValidationErrors(\n\t\t\tConstraintViolationException constraintViolationException) {\n\t\tMap<String, String> validationErrors = Maps.newHashMap();\n\t\tconstraintViolationException.getConstraintViolations().forEach(violationErrors -> {\n\t\t\tString field = ((PathImpl) violationErrors.getPropertyPath()).getLeafNode().asString().trim();\n\t\t\tList<ValidationError> validationErrorList = applicationConfig.getValidationErrors().get(field.trim());\n\t\t\tvalidationErrorList.forEach(validationError -> validationErrors.put(validationError.getCode(),\n\t\t\t\t\treplaceTemplateValues(validationError.getDescription(), field.trim())));\n\t\t});\n\t\tHelloResponse empResponse = HelloResponse.builder().status(Constants.FAIL)\n\t\t\t\t.appId(InputRequestContextHolder.getAppId())\n\t\t\t\t.errors(ErrorMessage.builder().code(applicationConfig.getClientError().getCode())\n\t\t\t\t\t\t.description(applicationConfig.getClientError().getDescription()).errors(validationErrors)\n\t\t\t\t\t\t.build())\n\t\t\t\t.build();\n\n\t\tlog.error(Constants.INPUT_VALIDATION_ERROR, kv(Constants.ERROR_RESPONSE, empResponse),\n\t\t\t\tconstraintViolationException);\n\n\t\treturn errorResponse(HttpStatus.BAD_REQUEST, empResponse);\n\n\t}\n\n\t@ExceptionHandler(RuntimeException.class)\n\tpublic ResponseEntity<HelloResponse> handleInternalServerError(RuntimeException exception) {\n\n\t\tSystem.out.println(applicationConfig);\n\t\tMap<String, String> serverErrors = Maps.newHashMap();\n\t\tserverErrors.put(applicationConfig.getServerErrors().getCode(),\n\t\t\t\tapplicationConfig.getServerErrors().getDescription() + " " + exception.getMessage());\n\t\tHelloResponse empResponse = HelloResponse.builder().status(Constants.FAIL)\n\t\t\t\t.appId(InputRequestContextHolder.getAppId())\n\t\t\t\t.errors(ErrorMessage.builder().code(applicationConfig.getServerError().getCode())\n\t\t\t\t\t\t.description(applicationConfig.getServerError().getDescription()).errors(serverErrors).build())\n\t\t\t\t.build();\n\n\t\tlog.error(Constants.INTERNAL_SERVICE_ERROR, kv(Constants.ERROR_RESPONSE, empResponse), exception);\n\n\t\treturn errorResponse(HttpStatus.INTERNAL_SERVER_ERROR, empResponse);\n\n\t}\n\n\t@ExceptionHandler(MethodArgumentNotValidException.class)\n\tpublic ResponseEntity<HelloResponse> handleClientErrors(\n\t\t\tMethodArgumentNotValidException methodArgumentNotValidException) {\n\t\tMap<String, String> validationErrors = Maps.newHashMap();\n\t\tif (methodArgumentNotValidException.getBindingResult().getGlobalError() != null) {\n\t\t\tpopulateGlobalError(validationErrors, methodArgumentNotValidException.getBindingResult().getGlobalError());\n\t\t}\n\t\tmethodArgumentNotValidException.getBindingResult().getFieldErrors().stream()\n\t\t\t\t.forEach(fieldError -> populateValidationErrors(validationErrors, fieldError));\n\t\tHelloResponse empResponse = HelloResponse.builder().status(Constants.FAIL)\n\t\t\t\t.appId(InputRequestContextHolder.getAppId())\n\t\t\t\t.errors(ErrorMessage.builder().code(applicationConfig.getClientError().getCode())\n\t\t\t\t\t\t.description(applicationConfig.getClientError().getDescription()).errors(validationErrors)\n\t\t\t\t\t\t.build())\n\t\t\t\t.build();\n\n\t\tlog.error(Constants.INPUT_VALIDATION_ERROR, kv(Constants.ERROR_RESPONSE, empResponse),\n\t\t\t\tmethodArgumentNotValidException);\n\n\t\treturn errorResponse(HttpStatus.BAD_REQUEST, empResponse);\n\t}\n\n\tprivate void populateValidationErrors(Map<String, String> validationErrors, FieldError fieldError) {\n\t\tString fieldName = deriveFieldName(fieldError);\n\t\tList<ValidationError> validationErrorsList = applicationConfig.getValidationErrors().get(fieldName);\n\t\tvalidationErrorsList.forEach(validationError -> validationErrors.put(validationError.getCode(),\n\t\t\t\treplaceTemplateValues(validationError.getDescription(), fieldName)));\n\t}\n\n\tprivate String deriveFieldName(FieldError fieldError) {\n\t\tString fieldName = fieldError.getField();\n\t\tif (fieldName.contains(".")) {\n\t\t\tfieldName = StringUtils.substringAfter(fieldName, ".");\n\t\t}\n\t\treturn fieldName;\n\t}\n\n\tprivate void populateGlobalError(Map<String, String> validationErrors, ObjectError fieldError) {\n\n\t\tList<ValidationError> validationErrorsList = applicationConfig.getValidationErrors()\n\t\t\t\t.get(fieldError.getDefaultMessage());\n\t\tvalidationErrorsList.forEach(validationError -> validationErrors.put(validationError.getCode(),\n\t\t\t\treplaceTemplateValues(validationError.getDescription(), fieldError.getDefaultMessage())));\n\n\t}\n\n\tprivate String replaceTemplateValues(String templateMessage, String fieldName) {\n\t\tMap<String, String> validationOverrides = Maps.newHashMap();\n\t\tif (StringUtils.equalsIgnoreCase("appId", fieldName)) {\n\t\t\tvalidationOverrides.put("appIds", StringUtils.join(applicationConfig.getAppIds()));\n\t\t}\n\t\tStringSubstitutor sub = new StringSubstitutor(validationOverrides);\n\t\treturn sub.replace(templateMessage);\n\t}\n\n\tprivate ResponseEntity<HelloResponse> errorResponse(HttpStatus status, HelloResponse empResponse) {\n\t\treturn ResponseEntity.status(status).body(empResponse);\n\t}\n}\n\n```\n\n**HelloController**\n\n```jsx\n@GetMapping("/hello")\npublic HelloResponse sayHello(@RequestBody @Valid User user) {\n\treturn HelloResponse.builder().status("Success").appId(user.getAppId()).data(HelloResponseData.builder()\n\t\t\t.executed(true).response("Hello " + user.getFirstName() + " " + user.getLastName()).build()).build();\n}\n```\n\n**HelloResponse**\n\n```jsx\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@SuperBuilder\npublic class HelloResponse {\n\tprivate String status;\n\tprivate String appId;\n\tprivate HelloResponseData data;\n\tprivate ErrorMessage errors;\n\n}\n\n\n```\n\n**HelloResponseData**\n\n```jsx\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@SuperBuilder\npublic class HelloResponseData {\n\tprivate boolean executed;\n\tprivate String response;\n}\n\n\n```\n\n**ErrorMessage**\n\n```jsx\n@Data\n@SuperBuilder\n@NoArgsConstructor\n\npublic class ErrorMessage {\n\n\tprivate String code;\n\n\tprivate String description;\n\n\tprivate Map<String, String> errors;\n\n}\n\n\n```\n\n**CommonError**\n\n```jsx\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@SuperBuilder\npublic class CommonError {\n\n\tprivate String code;\n\tprivate String description;\n\n}\n\n\n```\n\n**ValidationError**\n\n```jsx\n\n@Data\npublic class ValidationError {\n\tprivate String code;\n\tprivate String description;\n\n}\n\n```\n\n**application.yml**\n\n```jsx\napp:\n appIds:\n   - Test\n validationErrors:\n   name:\n     - code: 400004\n       description: Invalid Name\n   appId:\n     - code: 400005\n       description: Invalid App ID\n   firstName:\n     - code: 400006\n       description: Invalid First Name and it needs to have max 20 characters\n   lastName:\n     - code: 400007\n       description: Invalid Last Name and it needs to have max 20 characters\n\n messageNotReadableError:\n     code: 400001\n     description: Request Json is malformed or invalid\n invalidHttpMethodError:\n     code: 400002\n     description:  Request Method is not allowed\n invalidInputError:\n     code: 400003\n     description:  Dynamic Content type not supported\n clientError:\n    code: 4000\n    description: Input Validation Failure\n businessError:\n    code: 6000\n    description: Business Validation Failure\n serverError:\n    code: 5000\n    description: Internal Server Error\n serverErrors:\n    code: 500001\n    description: Unable to process the request. Please contact support team.\n```\n '}}]);