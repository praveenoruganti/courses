(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[53],{622:function(e,t,n){"use strict";n.r(t),t.default=' - It is a type of structural design pattern.\n- It converts the interface of a class into another interface that a client expects.\n\nSometimes, there could be a scenario when two objects don\u2019t fit together, as they should in-order to get the work done. This situation could arise when we are trying to integrate a legacy code with a new code, or when changing a 3rd party API in the code. This is due to incompatible interfaces of the two objects which do not fit together.\n\nIn other words, Adapter design pattern is one of the structural design patterns and it\u2019s used so that two unrelated interfaces can work together. The object that joins these\nunrelated interfaces is called an Adapter. As a real life example, we can think of a mobile charger as an adapter because mobile battery needs 3 volts to charge but the normal socket produces either 120V (US) or 240V (India). So the mobile charger works as an adapter between mobile charging socket and the wall socket.\n\nIn the adapter pattern, a wrapper class (i.e., the adapter) is used translate requests from it to another class (i.e., the adoptee). In effect, an adapter provides particular interactions with an adoptee that are not offered directly by the adoptee.\n\nThe adapter pattern takes two forms. In the first form, a `class adapter` utilizes inheritance. The class adapter extends the adoptee class and adds the desired methods to\nthe adapter. These methods can be declared in an interface (i.e., the `target` interface).In the second form; an `object adapter` utilizes composition. The object adapter contains an adoptee and implements the target interface to interact with the adoptee.\n\n\n```jsx\npublic interface ITarget {\n\tvoid request();\n}\n```\n\n```jsx\npublic class Adaptee {\n\n\tpublic void specificRequest() {\n\t\tSystem.out.println("In Adaptee");\n\t}\n\n}\n```\n\n```jsx\npublic class Adapter implements ITarget {\n\n\tprivate Adaptee adaptee;\n\n\tAdapter(Adaptee adaptee) {\n\t\tthis.adaptee = adaptee;\n\t}\n\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println("Using Adapter");\n\t this.adaptee.specificRequest();\n\t}\n\n}\n```\n\n```jsx\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tITarget target= new Adapter(new Adaptee());\n\t\ttarget.request();\n\t}\n\n}\n```\n\n**Output**\n\n```jsx\nUsing Adapter\nIn Adaptee\n```\n\n### Benefits\n\n- It allows two or more previously incompatible objects to interact.\n- It allows reusability of existing functionality.\n\n### Limitations\n\n- No new functionalities can be added\n- Multiple Adapters difficult to maintain\n\n### Adapter Design Pattern in JDK\n\n- java.util.Arrays#asList()\n- java.util.Collections#list()\n- java.util.Collections#enumeration()\n- java.io.InputStreamReader(InputStream) (returns a Reader)\n- java.io.OutputStreamWriter(OutputStream) (returns a Writer) '}}]);