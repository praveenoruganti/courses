(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[138],{707:function(n,e,t){"use strict";t.r(e),e.default=' ![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/wrapperclass.PNG)\n\nWrapper classes are object representation of primitive data type.\n\nWrapper classes are immutable.\n\nThese are introduced in Java 5.\n\nThere are 8 wrapper classes in Java and they are part of **java.lang package**.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/wrapperclasses-1.png)\n\n**Why do we need Wrapper Classes in Java?**\n\nA wrapper class wraps (encloses) around a data type and gives it an object appearance.\n\nReasons why we need Wrapper Classes\n- null is a possible value\n- use it in a Collection\n- Methods that support Object like creation from other types.. like String for eg. Integer number2 = new Integer("55");//String\n\n\n**What are the different ways of creating Wrapper Class Instances?**\n\nThe difference is that using the Constructor you will always create a new object, while using valueOf() static method, it may return you a cached value with-in a range.\n\n1. Using a Wrapper Class Constructor\n\n```jsx\nInteger number = new Integer(55);//int\nInteger number2 = new Integer("55");//String\nFloat number3 = new Float(55.0);//double argument\nFloat number4 = new Float(55.0f);//float argument\nFloat number5 = new Float("55.0f");//String\nCharacter c1 = new Character(\'C\');//Only char constructor\n//Character c2 = new Character(124);//COMPILER ERROR\nBoolean b = new Boolean(true);\n//"true" "True" "tRUe" - all String Values give True\n//Anything else gives false\nBoolean b1 = new Boolean("true");//value stored - true\nBoolean b2 = new Boolean("True");//value stored - true\nBoolean b3 = new Boolean("False");//value stored - false\nBoolean b4 = new Boolean("SomeString");//value stored - false\n```\n\n2. Using valueOf Static Methods\n\n```jsx\nInteger hundered = Integer.valueOf(100);\nInteger seven = Integer.valueOf("111", 2);//binary 111 is converted to 7\n```\n\n\n**Autoboxing**\n\nAutomatic conversion of primitive data type to corresponding Wrapper class object.\n\nFor example, converting an int to an Integer, a double to a Double, and so on.\n\n**Unboxing**\n\nAutomatic conversion of Wrapper class object to corresponding primitive data type.\n\nFor example, converting an Integer to an int, a Double to a double, and so on.\n\n**Sample Code**\n\n```jsx\npublic class WrapperClass {\n    public static void main(String args[]) {\n        WrapperClass wc = new WrapperClass();\n        Integer num1 = new Integer(25);\n        Integer num2 = new Integer(50);\n        int num3 = 75;\n        int num4 = 100;\n        System.out.println(" Add Primitive : " + wc.addPrimitive(num1, num2)); // Autoboxing\n        System.out.println(" Add Object : " + wc.addObject(num3, num4)); // Unboxing\n    }\n    public int addPrimitive(int i, int j) {\n        return i + j;\n    }\n    public Integer addObject(Integer i, Integer j) {\n        return i + j;\n    }\n}\n```\n\n**Output**\n\nAdd Primitive : 75\n\nAdd Object : 175\n\n\n**What are the advantages of Auto Boxing?**\n\nAuto Boxing helps in saving memory by reusing already created Wrapper objects. Auto Boxing uses the static valueOf methods. However wrapper classes created using new are not reused.\n\nTwo wrapper objects created using new are not same object.\n\n```jsx\nInteger nineA = new Integer(9);\nInteger nineB = new Integer(9);\nSystem.out.println(nineA == nineB);//false\nSystem.out.println(nineA.equals(nineB));//true\n```\n\nTwo wrapper objects created using boxing are same object.\n\n```jsx\nInteger nineC = 9;\nInteger nineD = 9;\nSystem.out.println(nineC == nineD);//true\nSystem.out.println(nineC.equals(nineD));//true\n```\n\n**What is Casting?**\n\nCasting is used when we want to convert on data type to another.\n\nThere are two types of Casting\n- Implicit Casting\n- Explicit Casting\n\n**What is Implicit Casting?**\n\nImplicit Casting is done by the compiler. Good examples of implicit casting are all the automatic widening conversions i.e. storing smaller values in larger variable types.\n\n```jsx\nint value = 100;\nlong number = value; //Implicit Casting\nfloat f = 100; //Implicit Casting\n```\n\n**What is Explicit Casting?**\n\nExplicit Casting is done through code. Good examples of explicit casting are the narrowing conversions. Storing larger values into smaller variable types;\n\n```jsx\nlong number1 = 25678;\nint number2 = (int)number1;//Explicit Casting\n//int x = 35.35;//COMPILER ERROR\nint x = (int)35.35;//Explicit Casting\n```\nExplicit casting would cause truncation of value if the value stored is greater than the size of the variable.\n\n```jsx\nint bigValue = 280;\nbyte small = (byte) bigValue;\nSystem.out.println(small);//output 24. Only 8 bits remain.\n```\n\n '}}]);