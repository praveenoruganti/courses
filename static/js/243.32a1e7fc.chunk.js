(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[243],{812:function(e,n,t){"use strict";t.r(n),n.default=' Spring Boot is a very helpful framework. It allows us to forget about the majority of the configuration settings, many of which it opinionatedly auto-tunes.\n\nWhen using Spring Boot Starters, Logback is used for logging by default.\n\nLogback is one of the most widely used logging frameworks in the Java Community. It\'s a replacement for its predecessor, Log4j. Logback offers a faster implementation, provides more options for configuration, and more flexibility in archiving old log files.\n\nThe Logback architecture is comprised of three classes: Logger, Appender, and Layout.\n\nA Logger is a context for log messages. This is the class that applications interact with to create log messages.\n\nAppenders place log messages in their final destinations. A Logger can have more than one Appender. We generally think of Appenders as being attached to text files, but Logback is much more potent than that.\n\nLayout prepares messages for outputting. Logback supports the creation of custom classes for formatting messages, as well as robust configuration options for the existing ones.\n\nLet\'s add the logback dependency in pom.xml\n\n```jsx\n<dependency>\n    <groupId>net.logstash.logback</groupId>\n    <artifactId>logstash-logback-encoder</artifactId>\n    <version>6.6</version>\n    </dependency>\n<dependency>\n    <groupId>ch.qos.logback</groupId>\n    <artifactId>logback-access</artifactId>\n</dependency>\n\n```\n\nWhen a file in the classpath has one of the following names, Spring Boot will automatically load it over the default configuration:\n\n- logback-spring.xml\n- logback.xml\n- logback-spring.groovy\n- logback.groovy\n\nLet\'s create [logback.xml](https://praveenoruganti.github.io/courses/demo/springboot/logback.xml) with custom log configuration and place it in resources folder.\n\nLet\'s start our application now.\n\n```jsx\n{"@timestamp":"2019-12-05T18:03:06.156+05:30","severity":"INFO","service":"praveenoruganti-hello-service","thread":"main","class":"c.praveen.hello.HelloServiceApplication","methodName":"logStarted","lineNo":"61","message":"Started HelloServiceApplication in 2.455 seconds (JVM running for 3.329)","stacktrace":""}\n\n```\n\nIt\'s always best to create an AOP Advice class for logging the statements in controller and service classes, Also we can create an AOP Advice class for logging the execution time.\n\nBefore proceeding, lets include AOP dependency in pom.xml\n\n```jsx\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n**AOP Advice class for Logging**\n\n```jsx\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LoggingAspect {\n\n}\n```\n\n```jsx\n@Aspect\n@Component\n@Slf4j\npublic class LoggingAdvice {\n\t@Around("@annotation(com.praveen.hello.aop.LoggingAspect)")\n\tpublic Object logging(ProceedingJoinPoint pjp) throws Throwable {\n\t\tMethodSignature methodSignature = (MethodSignature) pjp.getSignature();\n\t\t// Get intercepted method details\n\t\tString className = methodSignature.getDeclaringType().getSimpleName();\n\t\tString methodName = methodSignature.getName();\n\t\tlog.info(Constants.INITAL_REQUEST +" for " + className + "." + methodName , kv(Constants.REQUEST, constructData(pjp)));\n\t\tObject proceed = pjp.proceed();\n\t\tlog.info(Constants.FINAL_RESPONSE +" for " + className + "." + methodName , kv(Constants.RESPONSE, proceed));\n\t\treturn proceed;\n\t}\n\n\tprivate String constructData(JoinPoint jp) {\n\t\treturn Arrays.asList(jp.getArgs()).stream().map(String::valueOf).collect(Collectors.joining(",", "[", "]"))\n\t\t\t\t.toString();\n\t}\n\n}\n```\n\nLet\'s include @LoggingAspect annotation on top of any method where you want to log the incoming request and outgoing response for a method.\n\n```jsx\n@RestController\n@RequestMapping("/api/v1_0")\n@Validated\n@Tag(description = "Hello Operations", name = "Hello Operations")\npublic class HelloController {\n    @GetMapping("/hello")\n    @LoggingAspect\n    @Operation(description = "Say Hello Based on Name", summary = "Say Hello Based on Name")\n    public String sayHello(@RequestParam("name") @NotBlank @Size(max = 20) String name) {\n        return "Hello " + name;\n    }\n}\n```\n\nNow open browser with URL [http://localhost:8080/api/v1_0/hello?name=Praveen](http://localhost:8080/api/v1_0/hello?name=Praveen) and check the logs.\n\n```jsx\n{"@timestamp":"2019-12-05T18:36:30.341+05:30","severity":"INFO","service":"praveenoruganti-hello-service","thread":"http-nio-8080-exec-1","class":"com.praveen.hello.aop.LoggingAdvice","methodName":"logging","lineNo":"29","message":"Initial Request for HelloController.sayHello","stacktrace":"","Request":"[Praveen]"}\n\n{"@timestamp":"2019-12-05T18:36:30.381+05:30","severity":"INFO","service":"praveenoruganti-hello-service","thread":"http-nio-8080-exec-1","class":"com.praveen.hello.aop.LoggingAdvice","methodName":"logging","lineNo":"31","message":"Final Response for HelloController.sayHello","stacktrace":"","Response":"Hello Praveen"}\n\n```\n\n**AOP Advice class for Execution Time**\n\n```jsx\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TrackExecutionTime {\n\n}\n```\n\n```jsx\n@Aspect\n@Component\n@Slf4j\npublic class ExecutionTimeTrackerAdvice {\n\t@Around("@annotation(com.praveen.hello.aop.TrackExecutionTime)")\n\tpublic Object trackTime(ProceedingJoinPoint pjp) throws Throwable {\n\t\tMethodSignature methodSignature = (MethodSignature) pjp.getSignature();\n\t\t// Get intercepted method details\n\t\tString className = methodSignature.getDeclaringType().getSimpleName();\n\t\tString methodName = methodSignature.getName();\n\t\tfinal StopWatch stopWatch = new StopWatch();\n\t\t// Measure method execution time\n\t\tstopWatch.start();\n\t\tObject result = pjp.proceed();\n\t\tstopWatch.stop();\n\t\t// Log method execution time\n\t\tlog.info("Execution time of " + className + "." + methodName + " :: " + stopWatch.getTotalTimeMillis() + " ms");\n\t\treturn result;\n\t}\n\n}\n\n```\n\nLet\'s include @TrackExecutionTime annotation on top of any method where you want to find the execution time for a particular method.\n\n```jsx\n@RestController\n@RequestMapping("/api/v1_0")\n@Validated\n@Tag(description = "Hello Operations", name = "Hello Operations")\npublic class HelloController {\n    @GetMapping("/hello")\n    @LoggingAspect\n    @TrackExecutionTime\n    @Operation(description = "Say Hello Based on Name", summary = "Say Hello Based on Name")\n    public String sayHello(@RequestParam("name") @NotBlank @Size(max = 20) String name) {\n        return "Hello " + name;\n    }\n}\n```\n\nNow open browser with URL [http://localhost:8080/api/v1_0/hello?name=Praveen](http://localhost:8080/api/v1_0/hello?name=Praveen) and check the logs.\n\n```jsx\n{"@timestamp":"2021-12-05T18:39:38.606+05:30","severity":"INFO","service":"praveenoruganti-hello-service","thread":"http-nio-8080-exec-1","class":"com.praveen.hello.aop.LoggingAdvice","methodName":"logging","lineNo":"29","message":"Initial Request for HelloController.sayHello","stacktrace":"","Request":"[Praveen]"}\n\n{"@timestamp":"2021-12-05T18:39:38.694+05:30","severity":"INFO","service":"praveenoruganti-hello-service","thread":"http-nio-8080-exec-1","class":"com.praveen.hello.aop.LoggingAdvice","methodName":"logging","lineNo":"31","message":"Final Response for HelloController.sayHello","stacktrace":"","Response":"Hello Praveen"}\n\n{"@timestamp":"2021-12-05T18:39:38.694+05:30","severity":"INFO","service":"praveenoruganti-hello-service","thread":"http-nio-8080-exec-1","class":"c.p.hello.aop.ExecutionTimeTrackerAdvice","methodName":"trackTime","lineNo":"28","message":"Execution time of HelloController.sayHello :: 92 ms","stacktrace":""}\n\n```\n '}}]);