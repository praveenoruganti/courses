(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[45],{614:function(t,e,n){"use strict";n.r(e),e.default=' It is a type of Behavioral Design Pattern.\n\nIt is very useful for implementing a family of Algorithms.\n\nWith Strategy Pattern we can select the algorithm at runtime. We can use to select sorting strategy based on input it selects for execution, saving files etc.\n\nOne of the best example of this pattern is Collections.sort () method that takes Comparator parameter. Based on the different implementations of Comparator interfaces, the Objects are getting sorted in different ways.\n\n```jsx\npackage com.praveen.designpatterns.behavioral.strategy;\n\npublic interface PaymentCard {\n\tvoid pay(String buyer, int amount);\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.behavioral.strategy;\n\npublic class CreditCard implements PaymentCard {\n\t@Override\n\tpublic void pay(String buyer, int amount) {\n\t\tSystem.out.println("paying with CreditCard: Buyer = " + buyer + " Amount = " + amount);\n\t}\n}\n```\n\n```jsx\npackage com.praveen.designpatterns.behavioral.strategy;\n\npublic class DebitCard implements PaymentCard {\n\t@Override\n\tpublic void pay(String buyer, int amount) {\n\t\tSystem.out.println("paying with DebitCard: Buyer = " + buyer + " Amount = " + amount);\n\t}\n}\n```\n\n```jsx\npackage com.praveen.designpatterns.behavioral.strategy;\n\npublic class PaymentContext {\n\tprivate final PaymentCard strategy;\n\n\tpublic PaymentContext(PaymentCard strategy) {\n\t\tthis.strategy = strategy;\n\t}\n\n\tpublic void doPayment(String buyer, int amount) {\n\t\tthis.strategy.pay(buyer, amount);\n\t}\n}\n```\n\n```jsx\npackage com.praveen.designpatterns.behavioral.strategy;\n\npublic class StrategyPatternTest {\n\tpublic static void main(String[] args) {\n\n\t\tPaymentContext paymentContext = new PaymentContext(new CreditCard());\n\t\tpaymentContext.doPayment("Praveen", 100);\n\n\t\tpaymentContext = new PaymentContext(new DebitCard());\n\t\tpaymentContext.doPayment("Praveen", 100);\n\n\t}\n}\n\n```\n\n**Output**\n\n```jsx\npaying with CreditCard: Buyer = Praveen Amount = 100\npaying with DebitCard: Buyer = Praveen Amount = 100\n```\n\n### When to use the Strategy Design Pattern\n\nUse the Strategy pattern when:\n- Many related classes differ only in their behavior. Strategies provide a way to configure a class with one of many behaviors.\n- You need different variants of an algorithm. For example, you might define algorithms reflecting different space/time trade-offs. Strategies can be used when these variants are implemented as a class hierarchy of algorithms.\n- An algorithm uses data that clients shouldn\u2019t know about. Use the Strategy pattern to avoid exposing complex, algorithm-specific data structures.\n- A class defines many behaviors, and these appear as multiple conditional statements in its operations. Instead of many conditionals, move related conditional branches into their own Strategy class.\n\n### Strategy pattern examples in JDK\n\n- java.util.Comparator#compare()\n- javax.servlet.http.HttpServlet\n- javax.servlet.Filter#doFilter() '}}]);