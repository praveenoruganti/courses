(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[129],{698:function(e,t,n){"use strict";n.r(t),t.default=' ![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/streamapi.jpg)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/streams.png)\n\nStream API is used to process of collection of objects.\n\nA stream is not a datastructure instead it takes input from Collections,Arrays or I/O channels.\n\nStream will not change the original datastructure rather they produce result based on the pipeline methods.\n\n\n**What is the differences between Java.util.streams and Java.io streams?**\n\njava.util streams meant for processing objects from the collection. Ie, it represents a stream of objects from the collection but Java.io streams meant for processing binary and character data with respect to file. i.e it represents stream of binary data or character data from the file .hence Java.io streams and Java.util streams both are different.\n\n**What is the difference between collection and stream?**\n- If we want to represent a group of individual objects as a single entity then We should go for collection.\n- If we want to process a group of objects from the collection then we should go for streams.\n- We can create a stream object to the collection by using stream() method of Collection interface. stream() method is a default method added to the Collection in 1.8 version.\n\n`default Stream stream()`\n\n```jsx\nList nums = Arrays.asList(1,2,3,4);\nStream s = nums.stream();\n```\n\nStream is an interface present in java.util.stream. Once we got the stream, by using that we can process objects of that collection.\n\n\n**Why we need stream?**\n\n1. We can achieve Functional Programming\n2. Code Reduce\n3. Bulk operation\n4. Parallel streams make it very easy for multithreaded operations\n\n**Stream Pipeline**\n\nA Stream pipeline consist of source, a zero or more intermediate operations and a terminal operation.\n\nSource -> Filter -> Sort -> Map -> Collect\n\n1. Stream Source can be created from \n   - Collections\n   - Lists\n   - Sets\n   - ints\n   - longs\n   - doubles\n   - arrays\n   - lines of a file.\n2. Stream operations will be either terminal or intermediate.\n\n**Intermediate operations**\n\nIntermediate operations such as Filter,Map or sort return a stream so we can multiple intermediate operations.\n\nOrder matters for large datasets: filter first and then sort or map.\n\nFor very large datasets use ParallelStream to enable multiple threads.\n\nIntermediate operations include\n\n - anyMatch()\n - distinct()\n - filter() \n - findFirst()\n - flatMap()\n - map()\n - skip()\n - sorted,limit()\n\n\n**Filtering**\n\nWe can configure a filter to filter elements from the collection based on some boolean condition by using filter()method of Stream interface.\n\n```jsx\npublic Stream filter(Predicate<T> t)\n```\n\nhere (Predicate<T > t ) can be a boolean valued function/lambda expression\n\nFor example,\n```jsx\nStream s = c.stream();\nStream s1 = s.filter(i -> i%2==0);\n```\n\nHence to filter elements of collection based on some Boolean condition we should go for filter() method.\n\n**Mapping**\n\nIf we want to create a separate new object, for every object present in the collection based on our requirement then we should go for map() method of Stream interface.\n\n```jsx\npublic Stream map (Function f);\n```\n\nFor example,\n```jsx\nStream s = c.stream();\nStream s1 = s.map(i-> i+10);\n```\n\n**Terminal operations**\n\nTerminal operations such as forEach,collect or reduce are either void or return a non stream result.\n\nOnly one terminal operation is allowed.\n\nforEach applies the same function to each element.\n\ncollect saves elements into a collection\n\nother options reduce the stream to a single summary element\n\n- collect()\n- count()\n- sorted()\n- max()\n- min()\n- reduce()\n- summaryStatistics()\n\n\n**Processing by collect() method**\n\nThis method collects the elements from the stream and adding to the specified to the collection indicated (specified) by argument.\n\nFor example, To collect only even numbers from the array list\n\n```jsx\nl1.stream().filter(i -> i%2==0).collect(Collectors.toList());\n```\n\nLet\'s see another example, Program for map() and collect() Method\n\n```jsx\nl.Stream().map(s ->s.toUpperCase()).collect(Collectors.toList());\n```\n\n**Processing by count() method**\n\nThis method returns number of elements present in the stream.\n\n```jsx\npublic long count()\n```\n\nFor example,\n\n```jsx\nl.stream().filter(s ->s.length()==5).count();\n```\n\n**Processing by sorted() method**\n\nIf we sort the elements present inside stream then we should go for sorted() method.\n\nthe sorting can either default natural sorting order or customized sorting order specified by comparator.\n\nsorted()- default natural sorting order\n\nsorted(Comparator c)-customized sorting order.\n\nFor example,\n\n```jsx\nList<String> l3=l.stream().sorted().collect(Collectors.toList());\nSystem.out.println("according to default natural sorting order:"+l3);\nList<String> l4=l.stream().sorted((s1,s2) -> -s1.compareTo(s2)).collect(Collectors.toList());\nSystem.out.println("according to customized sorting order:"+l4);\n```\n\n**Processing by min() and max() methods**\n\nmin(Comparator c) - returns minimum value according to specified comparator.\n\nmax(Comparator c) - returns maximum value according to specified comparator.\n\n\nFor example,\n\n```jsx\nString min=l.stream().min((s1,s2) -> s1.compareTo(s2)).get();\nSystem.out.println("minimum value is:"+min);\nString max=l.stream().max((s1,s2) -> s1.compareTo(s2)).get();\nSystem.out.println("maximum value is:"+max);\n```\n\n**Processing by reduce() method**\n\nreduce will take a  BinaryOperator<T> as an argument.\n\nFor example, we need find sum of numbers in a List\n\n```jsx\n\nList<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\nSystem.out.println(nums.stream().reduce((x, y) -> x + y).get());\n```\n\n**Map vs FlatMap**\n\n**Map**\n\nTransforms the elements into something else. It accepts a function to apply to each element and returns a new Stream of values returned by the passed function.\n\nIt takes function object as the parameter e.g.: Function, ToIntFunction, ToIntDoubleFunction, ToLongFunction.\n\n\n**FlatMap**\n\nCombination of Map and Flat operations.So, we first apply map operation on each element and then flattens the result.\n\nSo, if function used by Map is returning a single value, then map is ok. But, if function used by Map operation is returning a stream of list or stream of stream, then we need to use flatmap to get stream of values.\n\n```jsx\nList evens = Arrays.asList(2,4,6);\n\nList odds = Arras.asList(3,5,7);\n\nList primes = Arrays.asList(2,3,5,7,11);\n\nList numbers = Stream.of(evens, odds, primes).flatMap(list -> list.stream()).collect(Collectors.toList());\n\nSystem.out.println(numbers); // [2,4,6,3,5,7,2,3,5,7,11]\n```\n\n\n`Let\'s see some examples`\n\n```jsx\npackage com.praveen.streams.employee;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.DoubleSummaryStatistics;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.ToString;\nimport lombok.experimental.SuperBuilder;\n\n@AllArgsConstructor\n@Data\n@ToString\n@SuperBuilder\nclass Employee {\n\tprivate final int id;\n\tprivate final String name;\n\tprivate final int age;\n\tprivate final String gender;\n\tprivate final String department;\n\tprivate final int yearOfJoining;\n\tprivate final double salary;\n}\n\npublic class EmployeeStreamDemo {\n\n\tpublic static List<Employee> createEmployeeList() {\n\t\tList<Employee> employeeList = new ArrayList<>();\n\t\temployeeList.add(new Employee(111, "Kalpana Chavala", 32, "Female", "HR", 2011, 25000.0));\n\t\temployeeList.add(new Employee(122, "Kiran Badugu", 25, "Male", "Sales And Marketing", 2015, 13500.0));\n\t\temployeeList.add(new Employee(133, "Ravindra Mulakala", 29, "Male", "Infrastructure", 2012, 18000.0));\n\t\temployeeList.add(new Employee(144, "Praneeth Vishnubhotla", 28, "Male", "Product Development", 2014, 32500.0));\n\t\temployeeList.add(new Employee(155, "Geetha Sabesan", 27, "Female", "HR", 2013, 22700.0));\n\t\temployeeList.add(new Employee(166, "Satheesh Nair", 43, "Male", "Security And Transport", 2016, 10500.0));\n\t\temployeeList.add(new Employee(177, "Ravindra Duggempudi", 35, "Male", "Account And Finance", 2010, 27000.0));\n\t\temployeeList.add(new Employee(188, "Praveen Oruganti", 31, "Male", "Product Development", 2015, 34500.0));\n\t\temployeeList.add(new Employee(199, "Swati Ravula", 24, "Female", "Sales And Marketing", 2016, 11500.0));\n\t\temployeeList.add(new Employee(200, "Ganesh Bendandi", 38, "Male", "Security And Transport", 2015, 11000.5));\n\t\temployeeList.add(new Employee(211, "Renuga Maharshi", 27, "Female", "Infrastructure", 2014, 15700.0));\n\t\temployeeList.add(new Employee(222, "Gopi Pavurala", 25, "Male", "Product Development", 2016, 28200.0));\n\t\temployeeList.add(new Employee(233, "Jyothi Kadinda", 27, "Female", "Account And Finance", 2013, 21300.0));\n\t\temployeeList.add(new Employee(244, "Bhavani Vanish", 24, "Male", "Sales And Marketing", 2017, 10700.5));\n\t\temployeeList.add(new Employee(255, "Pradeep Rajulu", 23, "Male", "Infrastructure", 2018, 12700.0));\n\t\temployeeList.add(new Employee(266, "Manish Pandey", 26, "Female", "Product Development", 2015, 28900.0));\n\t\temployeeList.add(new Employee(277, "Kohli Virat", 31, "Male", "Product Development", 2012, 35700.0));\n\n\t\treturn employeeList;\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tList<Employee> employeeList = createEmployeeList();\n\n\t\tSystem.out.println("----------------------------------------------");\n\t\t// Q 1 : How many male and female employees are there in the organization?\n\t\tSystem.out.println("Q 1 : How many male and female employees are there in the organization?");\n\t\tMap<String, Long> noOfMaleAndFemaleEmployees = employeeList.stream()\n\t\t\t\t.collect(Collectors.groupingBy(Employee::getGender, Collectors.counting()));\n\t\tSystem.out.println(noOfMaleAndFemaleEmployees);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 2 : Print the name of all departments in the organization?\n\t\tSystem.out.println("Q 2 : Print the name of all departments in the organization?");\n\t\temployeeList.stream().map(Employee::getDepartment).distinct().forEach(System.out::println);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 3 : What is the average age of male and female employees?\n\t\tSystem.out.println("Q 3 : What is the average age of male and female employees?");\n\t\tMap<String, Double> averageAgeOfMaleAndFemaleEmployee = employeeList.stream()\n\t\t\t\t.collect(Collectors.groupingBy(Employee::getGender, Collectors.averagingInt(Employee::getAge)));\n\t\tSystem.out.println(averageAgeOfMaleAndFemaleEmployee);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 4 : Get the details of highest paid employee in the organization?\n\t\tSystem.out.println("Q 4 : Get the details of highest paid employee in the organization?");\n\t\tOptional<Employee> highestPaidEmployeeWrapper = employeeList.stream()\n\t\t\t\t.collect(Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary)));\n\t\tSystem.out.println(highestPaidEmployeeWrapper.get().getName());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 5 : Get the names of all employees who have joined after 2015?\n\t\tSystem.out.println("Q 5 : Get the names of all employees who have joined after 2015?");\n\t\temployeeList.stream().filter(e -> e.getYearOfJoining() > 2015).map(Employee::getName)\n\t\t\t\t.forEach(System.out::println);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 6 : Count the number of employees in each department?\n\t\tSystem.out.println("Q 6 : Count the number of employees in each department?");\n\t\tMap<String, Long> employeeCountByDepartment = employeeList.stream()\n\t\t\t\t.collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));\n\t\temployeeCountByDepartment.entrySet().forEach(System.out::println);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 7 : What is the average salary of each department?\n\t\tSystem.out.println("Q 7 : What is the average salary of each department?");\n\t\tMap<String, Double> avgSalaryOfDepartments = employeeList.stream().collect(\n\t\t\t\tCollectors.groupingBy(Employee::getDepartment, Collectors.averagingDouble(Employee::getSalary)));\n\n\t\tavgSalaryOfDepartments.entrySet().forEach(System.out::println);\n\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 8 : Get the details of youngest male employee in the product development department?\n\t\tSystem.out.println("Q 8 : Get the details of youngest male employee in the product development department?");\n\t\tOptional<Employee> youngestMaleEmployeeInProductDevelopmentWrapper = employeeList.stream()\n\t\t\t\t.filter(e -> e.getGender().equals("Male") && e.getDepartment().equals("Product Development"))\n\t\t\t\t.min(Comparator.comparingInt(Employee::getAge));\n\t\tSystem.out.println(youngestMaleEmployeeInProductDevelopmentWrapper.get());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 9 : Who has the most working experience in the organization?\n\t\tSystem.out.println("Q 9 : Who has the most working experience in the organization?");\n\t\tOptional<Employee> seniorMostEmployeeWrapper = employeeList.stream()\n\t\t\t\t.sorted(Comparator.comparingInt(Employee::getYearOfJoining)).findFirst();\n\t\tSystem.out.println(seniorMostEmployeeWrapper.get());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 10 : How many male and female employees are there in the sales and marketing team?\n\t\tSystem.out.println("Q 10 : How many male and female employees are there in the sales and marketing team?");\n\t\tMap<String, Long> countMaleFemaleEmployeesInSalesMarketing = employeeList.stream()\n\t\t\t\t.filter(e -> e.getDepartment().equals("Sales And Marketing"))\n\t\t\t\t.collect(Collectors.groupingBy(Employee::getGender, Collectors.counting()));\n\n\t\tSystem.out.println(countMaleFemaleEmployeesInSalesMarketing);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 11 : What is the average salary of male and female employees?\n\t\tSystem.out.println("Q 11 : What is the average salary of male and female employees?");\n\t\tMap<String, Double> avgSalaryOfMaleAndFemaleEmployees = employeeList.stream()\n\t\t\t\t.collect(Collectors.groupingBy(Employee::getGender, Collectors.averagingDouble(Employee::getSalary)));\n\n\t\tSystem.out.println(avgSalaryOfMaleAndFemaleEmployees);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 12 : List down the names of all employees in each department?\n\t\tSystem.out.println("Q 12 : List down the names of all employees in each department?");\n\t\tMap<String, List<Employee>> employeeListByDepartment = employeeList.stream()\n\t\t\t\t.collect(Collectors.groupingBy(Employee::getDepartment));\n\t\temployeeListByDepartment.entrySet().forEach(System.out::println);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 13 : What is the average salary and total salary of the whole organization?\n\t\tSystem.out.println("Q 13 : What is the average salary and total salary of the whole organization?");\n\t\tDoubleSummaryStatistics employeeSalaryStatistics = employeeList.stream()\n\t\t\t\t.collect(Collectors.summarizingDouble(Employee::getSalary));\n\n\t\tSystem.out.println("Average Salary = " + employeeSalaryStatistics.getAverage() + " and Total Salary = "\n\t\t\t\t+ employeeSalaryStatistics.getSum());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 14 : Separate the employees who are younger or equal to 25 years from those employees who are older than 25 years.\n\t\tSystem.out.println(\n\t\t\t\t"Q 14 : Separate the employees who are younger or equal to 25 years from those employees who are older than 25 years.");\n\t\tMap<Boolean, List<Employee>> partitionEmployeesByAge = employeeList.stream()\n\t\t\t\t.collect(Collectors.partitioningBy(e -> e.getAge() > 25));\n\n\t\tpartitionEmployeesByAge.entrySet().forEach(System.out::println);\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 15 : Who is the oldest employee in the organization? What is his age and which department he belongs to?\n\t\tSystem.out.println(\n\t\t\t\t"Q 15 : Who is the oldest employee in the organization? What is his age and which department he belongs to?");\n\t\tOptional<Employee> oldestEmployeeWrapper = employeeList.stream().max(Comparator.comparingInt(Employee::getAge));\n\t\tEmployee oldestEmployee = oldestEmployeeWrapper.get();\n\t\tSystem.out.println("Name : " + oldestEmployee.getName() + "and Age : " + oldestEmployee.getAge()\n\t\t\t\t+ " and Department : " + oldestEmployee.getDepartment());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q 16: Find 3rd Highest salary\n\t\tSystem.out.println("Q 16 : Find 3rd Highest salary?");\n\t\tSystem.out.println(employeeList.stream().map(e -> e.getSalary()).sorted(Comparator.reverseOrder()).skip(2)\n\t\t\t\t.findFirst().get());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q17: Fetch the Employees whose age is greater than 30\n\t\tSystem.out.println("Q 17 : Fetch the Employees whose age is greater than 30?");\n\t\tSystem.out.println(employeeList.stream().filter(emp -> emp.getAge() > 30).collect(Collectors.toList()));\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q18: Count number of employees with age 25?\n\t\tSystem.out.println("Q 18 : Count number of employees with age 25?");\n\t\tSystem.out.println(employeeList.stream().filter(emp -> emp.getAge() == 25).count());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q19: Fetch the employee details with name Nima Roy\n\t\tSystem.out.println("Q 19 : Fetch the employee details with name Gopi Pavurala?");\n\t\tSystem.out.println(\n\t\t\t\temployeeList.stream().filter(emp -> emp.getName().equalsIgnoreCase("Gopi Pavurala")).findAny().get());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q20: Find the maximum age of the employee\n\t\tSystem.out.println("Q 20 : Find the maximum age of the employee?");\n\t\tSystem.out.println(employeeList.stream().mapToInt(Employee::getAge).max().getAsInt());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q21: Sort all the employees on the basis of Age\n\t\tSystem.out.println("Q 21 : Sort all the employees on the basis of Age?");\n\t\tSystem.out.println(employeeList.stream().sorted(Comparator.comparingInt(Employee::getAge)).toList());\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q22: Join all the employee names with ,\n\t\tSystem.out.println("Q 22 : Join all the employee names with ,");\n\t\tSystem.out.println(String.join(", ", employeeList.stream().map(Employee::getName).toList()));\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q23: Find the sum of all employees salary\n\t\tSystem.out.println("Q 23 : Find the sum of all employees salary?");\n\t\tSystem.out.println(employeeList.stream().mapToDouble(Employee::getSalary).sum());\n\t\tSystem.out.println("----------------------------------------------");\n\t\t\n\t\t// Q24: Group them by Employee name\n\t\tSystem.out.println("Q 24 :  Group them by Employee name?");\n\t\tSystem.out.println(employeeList.stream().collect(Collectors.groupingBy(Employee::getName)));\n\t\tSystem.out.println("----------------------------------------------");\n\n\t\t// Q25: Average Salaries based on department\n\t\tSystem.out.println("Q 25 : Average Salaries based on department?");\n\t\tSystem.out.println(employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment)).entrySet()\n\t\t\t\t.stream().collect(Collectors.toMap(entry -> entry.getKey(),\n\t\t\t\t\t\tentry -> entry.getValue().stream().mapToDouble(Employee::getSalary).average().getAsDouble())));\n\t\tSystem.out.println("----------------------------------------------");\n\t\t\n\t\t\n\t}\n\n}\n\n\n\n```\n\n\n '}}]);