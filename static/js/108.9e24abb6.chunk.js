(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[108],{677:function(e,t,n){"use strict";n.r(t),t.default=' ![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/forkjoinpool.PNG)\n\nFork Join Pool introduced in Java 7 and it is a concept to manage concurrent flow of execution using thread pool concept.\n\nIn Java 5 it was introduced with different pattern using Executor Service framework but it is different from Fork Join Pool.\n\nExecutorService is a thread pool where each thread performs a task from the beginning till the end.In ForkJoinPool, each task is splitted into subtask which are executed concurrently by different threads.\n\n**Abbreviation**\n\nFork : split task\n\nJoin :merge task\n\nPool :Repository available active thread.\n\nSuppose I am doing one operation with multiple functions, if I will do it as a single it will take huge time but i need an optimum approach to process in minimal time.\n\nI can use Fork to split my task to multiple thread. Then each thread will execute with task easily with minimal time using CPU pause time.\n\nAfter all thread task completion it will call join method which means only if i merge all thread outputs i can get a proper response.\n\nOnce it is done, it will return to main thread and main thread will take responsibility to finish the job.\n\n```jsx\n//ForkJoinPool Concept\npublic class FolderProcessor extends RecursiveTask<List<String>> {\nprivate static final long serialVersionUID = 1L;\n// This attribute will store the full path of the folder this task is going\n// to process.\nprivate final String path;\n// This attribute will store the name of the extension of the files this\n// task is going to look for.\nprivate final String extension;\n\n// Implement the constructor of the class to initialize its attributes\npublic FolderProcessor(String path, String extension) {\nthis.path = path;\nthis.extension = extension;\n}\n\n// Implement the compute() method. As you parameterized the RecursiveTask\n// class with the List<String> type,\n// this method has to return an object of that type.\n@Override\nprotected List<String> compute() {\n// List to store the names of the files stored in the folder.\nList<String> list = new ArrayList<String>();\n// FolderProcessor tasks to store the subtasks that are going to process\n// the subfolders stored in the folder\nList<FolderProcessor> tasks = new ArrayList<FolderProcessor>();\n// Get the content of the folder.\nFile file = new File(path);\nFile content[] = file.listFiles();\n// For each element in the folder, if there is a subfolder, create a new\n// FolderProcessor object\n// and execute it asynchronously using the fork() method.\nif (content != null) {\nfor (int i = 0; i < content.length; i++) {\nif (content[i].isDirectory()) {\nFolderProcessor task = new FolderProcessor(content[i].getAbsolutePath(), extension);\ntask.fork();\ntasks.add(task);\n}\n// Otherwise, compare the extension of the file with the\n// extension you are looking for using the checkFile() method\n// and, if they are equal, store the full path of the file in\n// the list of strings declared earlier.\nelse {\nif (checkFile(content[i].getName())) {\nlist.add(content[i].getAbsolutePath());\n}\n}\n}\n}\n// If the list of the FolderProcessor subtasks has more than 50\n// elements,\n// write a message to the console to indicate this circumstance.\nif (tasks.size() > 50) {\nSystem.out.printf("%s: %d tasks ran.\n", file.getAbsolutePath(), tasks.size());\n}\n// add to the list of files the results returned by the subtasks\n// launched by this task.\naddResultsFromTasks(list, tasks);\n// Return the list of strings\nreturn list;\n}\n\n// For each task stored in the list of tasks, call the join() method that\n// will wait for its finalization and then will return the result of the\n// task.\n// Add that result to the list of strings using the addAll() method.\nprivate void addResultsFromTasks(List<String> list, List<FolderProcessor> tasks) {\nfor (FolderProcessor item : tasks) {\nlist.addAll(item.join());\n}\n}\n\n// This method compares if the name of a file passed as a parameter ends\n// with the extension you are looking for.\nprivate boolean checkFile(String name) {\nreturn name.endsWith(extension);\n}\n\npublic static void main(String[] args) {\n// Create ForkJoinPool using the default constructor.\nForkJoinPool pool = new ForkJoinPool();\n// Create three FolderProcessor tasks. Initialize each one with a\n// different folder path.\nFolderProcessor system = new FolderProcessor("D:\\Praveen\\Projects\\workspace\\CoreJava", ".java");\nFolderProcessor apps = new FolderProcessor("D:\\Praveen\\Projects\\workspace\\CoreJava\\src\\com\\praveen\\others", ".java");\nFolderProcessor documents = new FolderProcessor("D:\\Praveen\\Projects\\workspace\\CoreJava\\src\\com\\praveen\\threads", ".java");\n// Execute the three tasks in the pool using the execute() method.\npool.execute(system);\npool.execute(apps);\npool.execute(documents);\n// Write to the console information about the status of the pool every\n// second\n// until the three tasks have finished their execution.\ndo {\nSystem.out.printf("-----------------------------------\n");\nSystem.out.printf("Main: Parallelism: %d\n", pool.getParallelism());\nSystem.out.printf("Main: Active Threads: %d\n", pool.getActiveThreadCount());\nSystem.out.printf("Main: Task Count: %d\n", pool.getQueuedTaskCount());\nSystem.out.printf("Main: Steal Count: %d\n", pool.getStealCount());\nSystem.out.printf("-----------------------------------\n");\ntry {\nTimeUnit.SECONDS.sleep(1);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n} while ((!system.isDone()) || (!apps.isDone()) || (!documents.isDone()));\n// Shut down ForkJoinPool using the shutdown() method.\npool.shutdown();\n// Write the number of results generated by each task to the console.\nList<String> results;\nresults = system.join();\nSystem.out.printf("System: %d files found.\n", results.size());\nresults = apps.join();\nSystem.out.printf("Apps: %d files found.\n", results.size());\nresults = documents.join();\nSystem.out.printf("Documents: %d files found.\n", results.size());\n}\n\n}\n\n```\n\n '}}]);