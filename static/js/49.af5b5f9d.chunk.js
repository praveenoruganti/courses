(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[49],{618:function(t,n,e){"use strict";e.r(n),n.default=' - It is a type of Creational Design Pattern.\n- It doesn\'t exposes instantiation or creation logic instead subclass create the object.\n\nFactory design pattern is used when we have a super class with multiple sub-classes and based on input, we need to return one of the sub-classes. This pattern takes out the\nresponsibility of instantiation of a class from client program to the factory class. We can apply Singleton pattern on Factory class or make the factory method static. \n\nSuper class in factory pattern can be an interface or a normal java class.\n\n```jsx\n\npublic interface NotificationExecutor {\n\tpublic void executeNotification();\n}\n\n```\n\n```jsx\n\npublic class EmailNotificationExecutor implements NotificationExecutor {\n\n\t@Override\n\tpublic void executeNotification() {\n\t\tSystem.out.println("Email notification sent");\n\t}\n\n}\n\n\n```\n\n```jsx\n\npublic class SMSNotificationExecutor implements NotificationExecutor {\n\n\t@Override\n\tpublic void executeNotification() {\n\t\tSystem.out.println("SMS notification sent.");\n\t}\n\n}\n\n\n```\n\n```jsx\n\npublic class NoNotificationExecutor implements NotificationExecutor {\n\tprivate String notificationType;\n\n\tNoNotificationExecutor(String notificationType) {\n\t\tthis.notificationType = notificationType;\n\t}\n\t@Override\n\tpublic void executeNotification() {\n\t\tSystem.out.println("Notification Implementation not defined for "+ notificationType);\n\t}\n\n}\n\n\n```\n\n```jsx\n\n\npublic class NotificationExecutorFactory {\n\tpublic static NotificationExecutor getNotificationExecutor(String executorType) {\n\n\t\tswitch (executorType) {\n\t\tcase "Email":\n\t\t\treturn new EmailNotificationExecutor();\n\n\t\tcase "SMS":\n\t\t\treturn new SMSNotificationExecutor();\n\n\t\tdefault:\n\t\t\treturn new NoNotificationExecutor(executorType);\n\n\t\t}\n\n\t}\n}\n\n```\n\n```jsx\n\npublic class NotificationSender {\n\n\tpublic static void main(String[] args) {\n\t\tNotificationExecutorFactory.getNotificationExecutor("Email").executeNotification();\n\t\tNotificationExecutorFactory.getNotificationExecutor("SMS").executeNotification();\n\t\tNotificationExecutorFactory.getNotificationExecutor("FTP").executeNotification();\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\nEmail notification sent\nSMS notification sent.\nNotification Implementation not defined for FTP\n```\n\n### Benefits\n\n- Creation of different types of objects is possible at run time.\n- It separates the object creation logic from the object usage logic.\n- Removes duplicate code. Thus, makes changing or addition to object creation easier.\n\n### Limitations\n\n- The different types of objects created must have the same parent class.\n- The addition of new classes and interfaces could increase the complexity of the code.\n\n### Factory Design Pattern Example in JDK\n\nSome of the factory pattern example in Java classes are;\n\n- Calender.getInstance()\n- NumberFormat.getInstance()\n- DriverManager.getConnection(-,-,-)\n\n '}}]);