(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[238],{807:function(n,e,o){"use strict";o.r(e),e.default=' REST APIs are hard to design so they serve multiple clients well. As each client has their own needs in terms of data searching, filtering and which fields they want, a traditional REST API will provide a single version of an entity and the client has the responsibility of navigating through multiple endpoints and correlate the data on their side to build the data they want.\n\n\nGraphQL was developed by Facebook to overcome the shortcomings they found with REST APIs. It\u2019s a query language for APIs and a runtime for fulfilling those queries with your existing data. By providing a complete and understandable description of the data in your API, clients can leverage that and have the power to ask for exactly what they need. By exposing the schema, it makes it easier to evolve APIs over time. Clients can still navigate the schema the way they need even if you add more fields and relations to it.\n\n\nLet\'s develop a GraphQL API \n\nAdd the below dependency in pom.xml\n\n```jsx\n<dependency>\n    <groupId>io.leangen.graphql</groupId>\n    <artifactId>graphql-spqr-spring-boot-starter</artifactId>\n    <version>0.0.6</version>\n</dependency>\n```\n\nNow create a Food entity class\n\n```jsx\n@Entity\n@Data\n@SuperBuilder\n@AllArgsConstructor\n@NoArgsConstructor\n@ToString\npublic class Food {\n\n\t@Id\n\t@GeneratedValue\n\t@GraphQLQuery(name = "id", description = "A food\'s id")\n\tprivate Long id;\n\n\t@GraphQLQuery(name = "name", description = "A food\'s name")\n\tprivate String name;\n\n}\n\n```\n\nNotice that you are already using GraphQL SPQR (GraphQL Schema Publisher & Query Resolver, pronounced like speaker) annotations (i.e. @GraphQLQuery) on the entity. This is how it will know to expose those entities in the API.\n\n\nCreate the respective repository\n\n```jsx\n@Repository\npublic interface FoodRepository extends JpaRepository<Food, Long> {\n}\n```\n\nIn GraphQL you can either define a query which will only load data, or define a mutation which will also change the underlying data that feeds the API. \n\nFor this sample app, Let\'s define the basic read, save and delete functionality for food entities. For that Let\'s create a service class.\n\n```jsx\n@Service\n@GraphQLApi\npublic class FoodService {\n\n    private final FoodRepository foodRepository;\n\n    public FoodService(FoodRepository foodRepository) {\n        this.foodRepository = foodRepository;\n    }\n\n    @GraphQLQuery(name = "foods") // READ ALL\n    public List<Food> getFoods() {\n        return foodRepository.findAll();\n    }\n\n    @GraphQLQuery(name = "food") // READ BY ID\n    public Optional<Food> getFoodById(@GraphQLArgument(name = "id") Long id) {\n        return foodRepository.findById(id);\n    }\n\n    @GraphQLMutation(name = "saveFood") // CREATE\n    public Food saveFood(@GraphQLArgument(name = "food") Food food) {\n        return foodRepository.save(food);\n    }\n\n    @GraphQLMutation(name = "deleteFood") // DELETE\n    public void deleteFood(@GraphQLArgument(name = "id") Long id) {\n        foodRepository.deleteById(id);\n    }\n\n    @GraphQLQuery(name = "isGood") // Calculated property of Food\n    public boolean isGood(@GraphQLContext Food food) {\n        return !Arrays.asList("Avocado", "Spam").contains(food.getName());\n    }\n\n}\n\n\n```\n\nNow add the below property in application.yml to enable the web UI to test the GraphQL API\n\n```jsx\ngraphql:\n spqr:\n  gui:\n   enabled: true\n```\n\nNow lets open [http://localhost:8080/gui](http://localhost:8080/gui)\n\nLet\'s create a food item called Idli using saveFood\n\n**Request**\n\n```jsx\nmutation {\n  saveFood(food: { name: "Idli" }) {\n    id\n    isGood\n  }\n}\n\nmutation {\n  saveFood(food: { name: "Dosa" }) {\n    id\n    isGood\n  }\n}\n\nmutation {\n  saveFood(food: { name: "Pongal" }) {\n    id\n    isGood\n  }\n}\n\nmutation {\n  saveFood(food: { name: "Chappati" }) {\n    id\n    isGood\n  }\n}\n```\n\n**Response**\n\n```jsx\n{\n  "data": {\n    "saveFood": {\n      "id": 1,\n      "isGood": true\n    }\n  }\n}\n\n{\n  "data": {\n    "saveFood": {\n      "id": 2,\n      "isGood": true\n    }\n  }\n}\n\n{\n  "data": {\n    "saveFood": {\n      "id": 3,\n      "isGood": true\n    }\n  }\n}\n\n{\n  "data": {\n    "saveFood": {\n      "id": 4,\n      "isGood": true\n    }\n  }\n}\n```\n\nNow let\'s fetch the details\n\n**Request**\n\n```jsx\n{\n  foods {\n    id\n    name\n    isGood\n  }\n}\n\n\n```\n\n**Response**\n\n```jsx\n{\n  "data": {\n    "foods": [\n      {\n        "id": 1,\n        "name": "Idli",\n        "isGood": true\n      },\n      {\n        "id": 2,\n        "name": "Dosa",\n        "isGood": true\n      },\n      {\n        "id": 3,\n        "name": "Pongal",\n        "isGood": true\n      },\n      {\n        "id": 4,\n        "name": "Chappati",\n        "isGood": true\n      }\n    ]\n  }\n}\n```\n\nLet\'s perform delete operation\n\n**Request**\n\n```jsx\nmutation {\n  deleteFood(id: 1)\n}\n\n```\n\n**Response**\n\n```jsx\n{\n  "data": {\n    "deleteFood": true\n  }\n}\n\n```\n\nWe can also find a specific food by ID using a query\n\n**Request**\n\n```jsx\n{\n  food(id: 2) {\n    name\n  }\n}\n\n```\n\n**Response**\n```jsx\n{\n  "data": {\n    "food": {\n      "name": "Dosa"\n    }\n  }\n}\n\n```\n\nFor a client to use your GraphQL API, it just needs to call it as a standard HTTP API: send a POST request with the query or mutation and parse the result as JSON.\n\nGraphQL is an exciting framework and an alternative to traditional RESTful endpoints. While offering a lot of flexibility, it can also add some tedious tasks such as maintaining schema files. SPQR aspires to make working with GraphQL easier and less error-prone. '}}]);