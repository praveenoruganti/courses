(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[215],{784:function(e,n,t){"use strict";t.r(n),n.default=' Life of traditional java objects starts on calling new operator which instantiates the object and finalize() method is getting called when the object is eligible for garbage collection. Life cycle of Spring beans are different as compared to traditional java objects.\n\n**Spring framework provides the following ways which can be used to control the lifecycle of  bean**\n\n- InitializingBean and DisposableBean callback interfaces\n- Bean Name, bean factory and Application Context  Aware interfaces for specific behavior\n- custom init() and destroy() methods in bean configuration file\n\n**For annotation based configurations**\n\n@PostConstruct and @PreDestroy annotations\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/spring/springbeanlifecycle.jpg)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/spring/destroy.png)\n\n**Following is sequence of a bean lifecycle in Spring**\n\n- Instantiate: First the spring container finds the bean\u2019s definition from the XML file and instantiates the bean.\n\n- Populate properties: Using the dependency injection, spring populates all of the properties as specified in the bean definition.\n\n- Set Bean Name: If the bean implements BeanNameAware interface, spring passes the bean\u2019s id to setBeanName() method.\n\n- Set Bean factory: If Bean implements BeanFactoryAware interface, spring passes the beanfactory to setBeanFactory() method.\n\n- Pre Initialization: Also called post process of bean. If there are any bean BeanPostProcessors associated with the bean, Spring calls postProcesserBeforeInitialization() method.\n\n- Initialize beans: If the bean implements IntializingBean,its afterPropertySet() method is called. If the bean has init method declaration, the specified initialization method is called.\n\n- Post Initialization: \u2013 If there are any BeanPostProcessors associated with the bean, their postProcessAfterInitialization() methods will be called.\n\n- Ready to use: Now the bean is ready to use by the application\n\n- Destroy: If the bean implements DisposableBean , it will call the destroy() method\n\n**ApplicationContextAware**\n\nApplicationContextAware can be used as an alternative for lookup method injection when a prototype bean is injected to a singleton bean.\n\nLets consider an example,\n\n```jsx\n\n@Component\n@Scope("prototype")\npublic class RequestHandler {\n\n RequestHandler() {\n  System.out.println("In Request Handler Constructor");\n }\n\n public void handleRequest() {\n  System.out.println("Handling request");\n }\n}\n\n@Component\n@Scope("singleton")\npublic class RequestManager implements ApplicationContextAware{\n  private RequestHandler requestHandler;\n  private ApplicationContext applicationContext;\n  public void handleRequest(){\n   requestHandler = getRequestHandler();\n   requestHandler.handleRequest();\n  }\n  // method to return new instance\n  public RequestHandler getRequestHandler() {\n   return applicationContext.getBean("requesthandler", RequestHandler.class);\n  }\n\n  @Override\n  public void setApplicationContext(ApplicationContext applicationContext)\n    throws BeansException {\n   this.applicationContext = applicationContext; \n  }\n }\n\n\n@Configuration\npublic class RequestConfig {\n\n @Bean(name="requestmanager")\n  public RequestManager requestManager(){\n   return new RequestManager();\n }\n \n @Bean(name="requesthandler") \n  public RequestHandler requestHandler(){\n   return new RequestHandler();\n }\n\n}\n\npublic class BeanScopeTest {\n public static void main( String[] args ){  \n        AnnotationConfigApplicationContext context= new AnnotationConfigApplicationContext(RequestConfig.class);\n         RequestManager bean = (RequestManager) context.getBean("requestmanager");\n         bean.handleRequest();\n         bean.handleRequest();\n         bean.handleRequest();\n         context.close();\n     }\n}\n\n```\n**Output**\n```jsx\nIn Request Handler Constructor\n\nHandling request\n\nHandling request\n\nHandling request\n```\n\nLets see an example on other bean life cycle methods\n\n```jsx\n\n@Component\npublic class Employee implements InitializingBean,DisposableBean,BeanNameAware,BeanPostProcessor  {\n  \n private String empName;\n private int empId;\n private double empSal;\n \n Employee(){\n  System.out.println("Employee Constructor invoked");\n }\n \n \n public String getEmpName() {\n  return empName;\n }\n public void setEmpName(String empName) {\n  this.empName = empName;\n }\n public int getEmpId() {\n  return empId;\n }\n public void setEmpId(int empId) {\n  this.empId = empId;\n }\n public double getEmpSal() {\n  return empSal;\n }\n public void setEmpSal(double empSal) {\n  this.empSal = empSal;\n }\n \n @Override\n public void setBeanName(String name) {\n  System.out.println(name +" bean has been initialized." ); \n   \n }\n   \n @Override\n public Object postProcessBeforeInitialization(Object bean, String beanName)\n   throws BeansException {\n  System.out.println("Inside post process before initialization: "+beanName);\n  return bean;\n }\n\n @PostConstruct\n public void init() throws Exception{\n  System.out.println("Post Construct method invoked");\n }\n \n @Override\n public void afterPropertiesSet() throws Exception {\n  System.out.println("After Properties Set method invoked");\n  \n }\n  \n @Override\n public Object postProcessAfterInitialization(Object bean, String beanName)\n   throws BeansException {\n  System.out.println("Inside post process after initialization: "+beanName);\n  return bean;\n } \n\n @PreDestroy\n public void customDestroy() throws Exception{\n  System.out.println("Custom Destroy method invoked");\n }\n \n @Override\n public void destroy() throws Exception {\n  System.out.println("Destroy method  invoked");\n  \n }\n\n @Override\n public String toString() {\n  return "Employee [empName=" + empName + ", empId=" + empId + ", empSal=" + empSal + "]";\n }\n\n \n}\n\n@Configuration\npublic class EmployeeConfig {\n \n @Bean(name="employee")\n public Employee newEmployee() {\n  Employee emp= new Employee();\n  emp.setEmpId(149903);\n  emp.setEmpName("Praveen");\n  emp.setEmpSal(100000000d);\n  \n  return emp;\n  \n }\n\n}\n\npublic class EmployeeTest {\n\n public static void main(String args[]) {\n  AnnotationConfigApplicationContext context= new AnnotationConfigApplicationContext(EmployeeConfig.class);\n  Employee emp= (Employee)context.getBean("employee");\n  System.out.println(emp);\n  //Shut down event is fired when context.close() or context.registerShutdownHook() is invoked.\n  context.close();\n }\n}\n\n\n```\n\n**Output**\n\n```jsx\nEmployee Constructor invoked\n\nemployee bean has been initialized.\n\nPost Construct method invoked\n\nAfter Properties Set method invoked\n\nInside post process before initialization: org.springframework.context.event.internalEventListenerProcessor\n\nInside post process after initialization: org.springframework.context.event.internalEventListenerProcessor\n\nInside post process before initialization: org.springframework.context.event.internalEventListenerFactory\n\nInside post process after initialization: org.springframework.context.event.internalEventListenerFactory\n\nEmployee [empName=Praveen, empId=149903, empSal=1.0E8]\n\nCustom Destroy method invoked\n\nDestroy method  invoked\n\n```\n\n '}}]);