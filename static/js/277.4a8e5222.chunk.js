(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[277],{846:function(e,t,n){"use strict";n.r(t),t.default=' **@Test annotation**\n\nIn order for the methods created in the test class to be recognized as test methods, we mark it with **@Test** annotation as mentioned above.\n\nJunit 5 **@Test** annotation has following characteristics:\n\n- It is applied over methods to mark them as test methods.\n- It is present in org.junit.jupiter.api package.\n- Its visibility can be made public, default and protected.\n\n**@DisplayName annotation**\n\n**DisplayName** annotation is used to provide a custom name for the test class. Usually, By default, JUnit 5 reporting prints the class name in the IDE test report and also while executing test cases. We can use @DisplayName annotation to provide a custom name to test class, that makes it easier to read. Thus, it acts as metadata for our test class.\n\n**DisplayName** annotation is also used to provide a custom name for the @Test methods. Usually, by default, JUnit 5 reporting prints the test methods name in the IDE test report and also while executing test cases. We can use @DisplayName annotation to provide a custom name to Test methods, that makes it easier to read. Thus, it acts as a metadata for our test methods.\n\n\n**@BeforeEach and @AfterEach annotation**\n\nIn Junit 5 for each test, a new instance of test class is created. So, for e.g. if a class has two @Test methods than two instances of test class will be created, one for each test. Thus, the constructor of the test class will be called as many times as there is the number of @Test methods.\n\nMethods annotated with @BeforeEach and @AfterEach as the name suggests are called before each and after each @Test methods. So, if in a test class there are two @Test methods, the @BeforeEach method will be called twice, just before each @Test method and similarly, the @AfterEach method will be called twice, just after each @Test method.\n\nLet\'s see an example,\n\n```jsx\npackage com.praveen.junit;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass LifecycleTest {\n\n\tLifecycleTest() {\n\t\tSystem.out.println("LifecycleTest - Constructor got executed !!!");\n\t}\n\n\t@BeforeEach\n\tvoid beforeEach() {\n\t\tSystem.out.println("LifecycleTest - beforeEach() got executed !!!");\n\t}\n\n\t@Test\n\tvoid testOne() {\n\t\tSystem.out.println("LifecycleTest - testOne() got executed !!!");\n\t}\n\n\t@Test\n\tvoid testTwo() {\n\t\tSystem.out.println("LifecycleTest - testTwo() got executed !!!");\n\t}\n\n\t@AfterEach\n\tvoid afterEach() {\n\t\tSystem.out.println("LifecycleTest - afterEach() got executed !!!");\n\t}\n}\n\n```\n\n**Output**\n\n```jsx\nLifecycleTest - Constructor got executed !!!\nLifecycleTest - beforeEach() got executed !!!\nLifecycleTest - testOne() got executed !!!\nLifecycleTest - afterEach() got executed !!!\nLifecycleTest - Constructor got executed !!!\nLifecycleTest - beforeEach() got executed !!!\nLifecycleTest - testTwo() got executed !!!\nLifecycleTest - afterEach() got executed !!!\n```\n\n\nAs Junit test class has two @Test methods, it executes each of the test methods in a separate instance of the test class. Thus, it picks the first @Test method in random order and \n\n- It initializes the test class by calling its constructor.\n- After that, it executes the @BeforeEach annotated method.\n- After that, it executes the @Test method.\n- After that, it executes the @AfterEach annotated method.\n- Then it picks the second @Test method and executes again from step 1 to 4.\n\nUsually, when we have common setup logic across various test cases, the common initialization code is placed in the @BeforeEach annotated method and cleaned up in @AfterEach annotated method.\n\n**@BeforeAll and @AfterAll annotation**\n\nMethods annotated with @BeforeAll and @AfterAll are static methods because, as the name suggest they are called once before all and once after all @Test methods. So, if in a test class there are two @Test methods, the @BeforeAll method will be called once before all test methods and similarly, the @AfterAll method will be called once, just after all @Test method gets finished.\n\nLet\'s see an example,\n\n```jsx\npackage com.praveen.junit;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass LifecycleTest {\n\n\t@BeforeAll\n\tstatic void beforeAll() {\n\t\tSystem.out.println("LifecycleTest - beforeAll() got executed !!!");\n\t}\n\n\tLifecycleTest() {\n\t\tSystem.out.println("LifecycleTest - Constructor got executed !!!");\n\t}\n\n\t@BeforeEach\n\tvoid beforeEach() {\n\t\tSystem.out.println("LifecycleTest - beforeEach() got executed !!!");\n\t}\n\n\t@Test\n\tvoid testOne() {\n\t\tSystem.out.println("LifecycleTest - testOne() got executed !!!");\n\t}\n\n\t@Test\n\tvoid testTwo() {\n\t\tSystem.out.println("LifecycleTest - testTwo() got executed !!!");\n\t}\n\n\t@AfterEach\n\tpublic void afterEach() {\n\t\tSystem.out.println("LifecycleTest - afterEach() got executed !!!");\n\t}\n\n\t@AfterAll\n\tpublic static void afterAll() {\n\t\tSystem.out.println("LifecycleTest - afterAll() got executed !!!");\n\t}\n}\n\n```\n\n**Output**\n\n```jsx\nLifecycleTest - beforeAll() got executed !!!\nLifecycleTest - Constructor got executed !!!\nLifecycleTest - beforeEach() got executed !!!\nLifecycleTest - testOne() got executed !!!\nLifecycleTest - afterEach() got executed !!!\nLifecycleTest - Constructor got executed !!!\nLifecycleTest - beforeEach() got executed !!!\nLifecycleTest - testTwo() got executed !!!\nLifecycleTest - afterEach() got executed !!!\nLifecycleTest - afterAll() got executed !!!\n```\n\nYou can see in the output of the above test class, that @BeforeAll and @AfterAll has the following properties\n\n- Both are static methods.\n- Both are called once in a test lifecycle.\n- @BeforeAll annotated method being a class level method, it gets called even before the constructor.\n- @AfterAll annotated method being a class level method, it gets called after all methods get executed.\n- @BeforeAll annotated method is used where expensive resource initialization needs to be done such as database connection, server start etc. This resources that can \nbe used by test methods.\n- @AfterAll annotated method is used where expensive resource clean up needs to be done such as, database connection terminates, server stop etc. So that these expensive resources can be cleaned up.\n\nHere with the test lifecycle.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/testing/lifecycle.jpg)\n\n\n**@CsvFileSource annotation**\n\n@CsvFileSource allows you to use CSV files from the classpath. This csv file gets picked up from the classpath at the time of running test case and each line from a CSV file results in one invocation of the parameterized test. We can also provide a number of lines to skip from top to take comma-separated values.\n\nLet\'s see an example,\n\n- Let\u2019s assume that we have to write a parameterized test that takes values from @CsvFileSource.\n- We create a csv file by name, capitals.csv . It has comma-separated values of countries and their capitals.\n- We will keep this csv file on the classpath.\n    `captials.csv`\n    ```jsx\n    Country, Capital\n    India, New Delhi\n    France, Paris\n    United States, Washington D.C.\n    United Kingdom, London\n   ```\n- We create a test class by name, CsvFileSourceTest.java.\n- It contains a test method by name, testWithCsvFileSource method. In order to provide different parameters/values to the same test method, this method is marked as @ParameterizedTest instead of @Test.\n- In order to provide different and multiple values through csv file source we mark this test method with @CsvFileSource annotation. This annotation takes resources which is the path to the csv file and numLinesToSkip which an integer value, to let test method skip those many lines while providing arguments to @ParameterizedTest .\n\nLet\'s see the test class\n\n```jsx\npackage com.praveen.junit.parameterized;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvFileSource;\n\nclass CsvFileSourceTest {\n\n\t@ParameterizedTest\n\t@CsvFileSource(resources = "/capitals.csv", numLinesToSkip = 1)\n\tvoid testWithCsvFileSource(String country, String capital) {\n\t\tassertNotNull(country);\n\t\tassertNotNull(capital);\n\t}\n}\n\n```\n\n\n '}}]);