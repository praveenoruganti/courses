(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[69],{638:function(n,t,e){"use strict";e.r(t),t.default=' **What is a Recursion?**\n\nRecursion is a way of solving a problem by having a function calling itself. \n\nIn Recursion, there must be some condition that will terminate the recursion.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/dsa/recursion1.jpg)\n\n**Properties of Recursion**\n\n- Performing the same operation multiple times with different inputs.\n- In every step, we try smaller inputs to make the problem smaller.\n- Base condition is needed to stop the recursion, otherwise infinite loop will occur.\n\n**Note**:  Space complexity is not constant due to recursive calls. \n\n**Why we need Recursion**\n\n- Because it makes the code easy to write (compared to iterative) whenever a given problem can be broken down into similar sub-problem.\n- Because it is heavily used in Data Structures like Tree, Graph etc.\n- It is heavily used in techniques like `Divide and Conquer`,`Greedy` and `Dynamic Programming` etc.\n\n**Format of a Recursive Function**\n\n- **Recursive Case**: Case where the function recur.\n- **Base Case**: Case where the function does not recur.\n\n`Recursion mainly uses stack memory as you know.`\n\n**Recursive vs Iteration**\n\n- Space Efficient? Recursion \u2013No, Iteration \u2013 Yes\n- Time Efficient? Recursion \u2013No, Iteration \u2013 Yes\n- Ease of Code (to solve sub-problems)? Recursion \u2013Yes, Iteration \u2013 No\n\n**When to use/Avoid Recursion?**\n\n**When to use**\n\n- When we can easily breakdown a problem into similar sub-problem.\n- When we are fine with extra overhead(both time and space) that comes with it.\n- When we need a quick working solution instead of efficient one.\n- When traverse a tree.\n\n**When to Avoid**\n\n- If time and space complexity matter for us.\n\n**Practical use of Recursion**\n\n- Fibonacci Series, Factorial Finding\n- Sorting \u2013 Quick Sort and Merge Sort\n- Binary Search\n- Towers of Hanoi\n- Tree - Traversal/Searching/Insertion/Deletion\n- Graph - DFS(Depth First Search) and BFS(Breadth First Search)\n- Divide and Conquer Algorithms\n- Back Tracking Algorithms\n- Dynamic Programming\n- Stack\n\n`Let\'s see some programs`\n\n**Sum of digits in a number**\n\n```jsx\npackage com.praveen.recursion;\n\npublic class SumOfDigits {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(sumofDigits(123));\n\n\t}\n\n\tpublic static int sumofDigits(int n) {\n\n\t\tif (n == 0 || n < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn n % 10 + sumofDigits(n / 10);\n\t}\n\n}\n```\n\n**Factorial of a number**\n\n```jsx\npackage com.praveen.recursion;\n\nimport java.util.Scanner;\n\npublic class Factorial {\n\n\t public static void main(String args[]) {\n\t\t Scanner s= new Scanner(System.in);\n\t\t System.out.println("Enter number for finding factorial of it");\n\t\t int num=s.nextInt();\n\t\t s.close();\n\t\t System.out.println(factorial(num));\n\t\t\n\t }\n\n\tprivate static int factorial(int num) {\n\t\tif(num==0) {\n\t\t\treturn 1;\n\t\t}else {\n\t\t\treturn num*factorial(num-1);\n\t\t}\n\t}\n}\n```\n\n**Fibonacci Series**\n\n```jsx\npackage com.praveen.recursion;\n\npublic class FibonacciSeries {\n\n\tstatic int n1 = 0, n2 = 1, n3 = 0;\n\n\tstatic void printFibonacci(int count) {\n\t\tif (count > 0) {\n\t\t\tn3 = n1 + n2;\n\t\t\tn1 = n2;\n\t\t\tn2 = n3;\n\t\t\tSystem.out.print(" " + n3);\n\t\t\tprintFibonacci(count - 1);\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint count = 10;\n\t\tSystem.out.print(n1 + " " + n2);// printing 0 and 1\n\t\tprintFibonacci(count - 2);// n-2 because 2 numbers are already printed\n\t}\n}\n```\n\n**Product of Array**\n\n```jsx\npackage com.praveen.recursion;\n\npublic class ProductOfArray {\n\n\tpublic static void main(String[] args) {\n\n\t\tint[] num = { 1, 2, 3, 4, 5 };\n\t\tSystem.out.println(productofArray(num, num.length));\n\n\t}\n\n\tpublic static int productofArray(int[] num, int len) {\n\t\tif (len <= 0)\n\t\t\treturn 1;\n\t\treturn (productofArray(num, len - 1) * num[len - 1]);\n\t}\n}\n```\n\n**Reverse a String**\n\n```jsx\npackage com.praveen.recursion;\n\npublic class ReverseAString {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(reverse("praveen"));\n\n\t}\n\n\tpublic static String reverse(String str) {\n\t\tif (str.isEmpty())\n\t\t\treturn str;\n\t\treturn reverse(str.substring(1)) + str.charAt(0);\n\t}\n\n}\n\n```\n\n**Binary Search**\n\n```jsx\npackage com.praveen.recursion;\n\npublic class BinarySearch {\n\n\tpublic static void main(String[] args) {\n\t\tint[] arr = { 1, 2, 3, 4, 55, 66, 78 };\n\t\tint target = 78;\n\t\tSystem.out.println(search(arr, target, 0, arr.length - 1));\n\n\t}\n\n\tprivate static int search(int[] arr, int target, int s, int e) {\n\t\tif (s > e) {\n\t\t\treturn -1;\n\t\t}\n\t\tint m = s + (e - s) / 2;\n\t\tif (arr[m] == target) {\n\t\t\treturn m;\n\t\t}\n\t\tif (target < arr[m]) {\n\t\t\treturn search(arr, target, s, m - 1);\n\t\t}\n\t\treturn search(arr, target, m + 1, e);\n\t}\n\n}\n\n```\n '}}]);