(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[147],{716:function(e,n,a){"use strict";a.r(n),n.default=' Most of the time, a JavaScript application needs to work with information. Here are two examples:\n\n- An online shop  the information might include goods being sold and a shopping cart.\n- A chat application  the information might include users, messages, and much more.\nVariables are used to store this information.\n\n## A Variable\n\nVariables are used to store some data for later use. In other words, think of them as containers which hold whatever data you put inside them.\n\nTo create a variable in JavaScript, we use the let,const and var keyword based on the scenario.\n\nThe statement below creates (in other words: declares) a variable with the name message:\n\n```jsx\nlet message;\n```\nNow, we can put some data into it by using the assignment operator =:\n\n```jsx\nlet message;\nmessage = \'Hello!\';\nalert(message); // shows the variable content\n```\nWe can also declare multiple variables in one line:\n\n```jsx\nlet user = \'Praveen\', age = 35, message = \'Hello\';\n```\n\nThat might seem shorter, but we don\u2019t recommend it. For the sake of better readability, please use a single line per variable.\n\nThe multiline variant is a bit longer, but easier to read:\n\n```jsx\nlet user = \'Praveen\';\nlet age = 35;\nlet message = \'Hello\';\n```\nWe can also change the value of variable  many times as we want:\n\n```jsx\nlet message;\nmessage = \'Hello!\';\nmessage = \'World!\'; // value changed\nalert(message);\n```\nWhen the value is changed, the old data is removed from the variable:\n\nA variable should be declared only once. Declaring twice triggers an error.\n\n```jsx\nlet message = "This";\n// repeated \'let\' leads to an error\nlet message = "That"; // SyntaxError: \'message\' has already been declared\n```\n\n## Variable naming\n\n**Rules for naming JS Variables**\n\n- Name can  contain letters, digits, or the symbols $ and _\n```jsx\nlet mySubject1,math$; // valid\n```\n- Name cannot start with a digit\n```jsx\nlet 1maths; //invalid\n```\n- Name can start with an _ or $\n```jsx\nlet _subjectMarks,$rankInClass; // valid\n```\n- Names are case sensitive\n```jsx\nlet x, X;\n```\n- Names cannot be reserved keywords.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/js/keywords.PNG)\n```jsx\nlet let; // invalid\nlet var; // invalid\n```\n- When the name contains multiple words, camelCase is commonly used\n```jsx\nlet subjectMarks,rankInClass;\n```\n\nLet see few more examples,\n```jsx\nlet &alpha1 // Invalid\nlet NUM1 // Valid\nlet DATE-5 // Invalid\nlet TotalSum_ // Valid\nlet 12Byby // Invalid\nlet num1 // Valid\nlet super$$ // Valid\nlet Object // Valid\nlet StringNew // Valid\nlet $rankInClass // Valid\n```\n\n## Constants\n\nTo declare a constant (unchanging) variable, use const instead of let:\n\n```jsx\nconst myBirthday = \'18.04.2000\';\n```\n\nVariables declared using const are called \u201cconstants\u201d. They cannot be reassigned. An attempt to do so would cause an error:\n\n```jsx\nconst myBirthday = \'18.04.2000\';\nmyBirthday = \'01.01.2001\'; // error, can\'t reassign the constant!\n```\nWhen a programmer is sure that a variable will never change, they can declare it with const to guarantee and clearly communicate that fact to everyone.\n\n**Uppercase constants**\n\nThere is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution.\n\nSuch constants are named using capital letters and underscores.\n\nFor instance, let\u2019s make constants for colors in so-called \u201cweb\u201d (hexadecimal) format:\n\n```jsx\nconst COLOR_RED = "#F00";\nconst COLOR_GREEN = "#0F0";\nconst COLOR_BLUE = "#00F";\nconst COLOR_ORANGE = "#FF7F00";\n// ...when we need to pick a color\nlet color = COLOR_ORANGE;\nalert(color); // #FF7F00\n```\nBenefits:\n- COLOR_ORANGE is much easier to remember than "#FF7F00".\n- It is much easier to mistype "#FF7F00" than COLOR_ORANGE.\n- When reading the code, COLOR_ORANGE is much more meaningful than #FF7F00.\n\nWhen should we use capitals for a constant and when should we name it normally? Lets make that clear.\n\nBeing a \u201cconstant\u201d just means that a variable\u2019s value never changes. But there are constants that are known prior to execution (like a hexadecimal value for red) and there are constants that are calculated in run-time, during the execution, but do not change after their initial assignment.\n\nFor instance:\n```jsx\nconst pageLoadTime = /* time taken by a webpage to load */;\n```\nThe value of pageLoadTime is not known prior to the page load, so it\u2019s named normally. But it\u2019s still a constant because it doesn\u2019t change after assignment.\n\nIn other words, capital-named constants are only used as aliases for \u201chard-coded\u201d values.\n\n## Name things right\nTalking about variables, there\u2019s one more extremely important thing.\n\nA variable name should have a clean, obvious meaning, describing the data that it stores.\n\nVariable naming is one of the most important and complex skills in programming. A quick glance at variable names can reveal which code was written by a beginner versus an experienced developer.\n\nIn a real project, most of the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it\u2019s much easier to find information that is well-labeled. Or, in other words, when the variables have good names.\n\nPlease spend time thinking about the right name for a variable before declaring it. Doing so will repay you handsomely.\n\nSome good-to-follow rules are:\n- Use human-readable names like userName or shoppingCart.\n- Stay away from abbreviations or short names like a, b, c, unless you really know what you\u2019re doing.\n- Make names maximally descriptive and concise. Examples of bad names are data and value. Such names say nothing. It\u2019s only okay to use them if the context of the code makes it exceptionally obvious which data or value the variable is referencing.\n- Agree on terms within your team and in your own mind. If a site visitor is called a \u201cuser\u201d then we should name related variables currentUser or newUser instead of currentVisitor or newManInTown.\n\n## Summary\n\nWe can declare variables to store data by using the var, let, or const keywords.\n\n- let \u2013 is a modern variable declaration.\n- var \u2013 is an old-school variable declaration. Normally we don\u2019t use it at all, but we\u2019ll cover subtle differences from let in the chapter The old "var", just in case you need them.\n- const \u2013 is like let, but the value of the variable can\u2019t be changed.\n\nVariables should be named in a way that allows us to easily understand what\u2019s inside them.\n\n## var vs let vs const\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/js/varVsletVsconst.PNG)\n\n## Variable Scope\nScope in JavaScript refers to the current context of code, which determines the accessibility of variables to JavaScript. The two types of scope are local and global:\n\n- Global variables are those declared outside of a block\n- Local variables are those declared inside of a block\n\nIn the example below, we will create a global variable.\n```jsx\nvar name="Praveen";\n```\nWe learned that variables can be reassigned. Using local scope, we can actually create new variables with the same name as a variable in an outer scope without changing or reassigning the original value.\n\nIn the example below, we will create a global species variable. Within the function is a local variable with the same name. By sending them to the console, we can see how the variable\u2019s value is different depending on the scope, and the original value is not changed.\n\n```jsx\n// Initialize a global variable\nvar name = "Praveen";\n\nfunction fullName() {\n  // Initialize a local, function-scoped variable\n  var name = "Praveen Oruganti";\n  console.log(name);\n}\n\n// Log the global and local variable\nconsole.log(name); // Praveen\nfullName(); // Praveen Oruganti\nconsole.log(name); // Praveen\n```\nIn this example, the local variable is function-scoped. Variables declared with the var keyword are always function-scoped, meaning they recognize functions as having a separate scope. This locally-scoped variable is therefore not accessible from the global scope.\n\nThe new keywords let and const, however, are block-scoped. This means that a new, local scope is created from any kind of block, including function blocks, if statements, and for and while loops.\n\nTo illustrate the difference between function- and block-scoped variables, we will assign a new variable in an if block using let.\n\n```jsx\nvar fullName = true;\n\n// Initialize a global variable\nlet name = "Praveen";\n\nif (fullName) {\n  // Initialize a block-scoped variable\n  let name = "Praveen Oruganti";\n  // Full Name is Praveen Oruganti\n}\n\n// Name is Praveen\n```\n\nIn this example, the name variable has one value globally (Praveen), and another value locally (Praveen Oruganti). If we were to use var, however, there would be a different result.\n\n```jsx\nvar fullName = true;\n// Use var to initialize a variable\nvar name = "Praveen";\n\nif (fullName) {\n  // Attempt to create a new variable in a block\n  var name = "Praveen Oruganti";\n  // Full Name is Praveen Oruganti\n}\n\n // Name is Praveen Oruganti\n```\nIn the result of this example, both the global variable and the block-scoped variable end up with the same value, Praveen Oruganti. This is because instead of creating a new local variable with var, you are reassigning the same variable in the same scope. var does not recognize if to be part of a different, new scope. It is generally recommended that you declare variables that are block-scoped, as they produce code that is less likely to unintentionally override variable values.\n\n## Hoisting\nIn most of the examples so far, we\u2019ve used var to declare a variable, and we have initialized it with a value. After declaring and initializing, we can access or reassign the variable.\n\nIf we attempt to use a variable before it has been declared and initialized, it will return undefined.\n\n```jsx\n// Attempt to use a variable before declaring it\nconsole.log(num); // undefined\n\n// Variable assignment\nvar num = 100;\n```\n\nHowever, if we omit the var keyword, we are no longer declaring the variable, only initializing it. It will return a ReferenceError and halt the execution of the script.\n\n```jsx\n// Attempt to use a variable before declaring it\nconsole.log(num); // ReferenceError: num is not defined\n\n// Variable assignment without var\nnum = 100;\n```\nThe reason for this is due to hoisting, a behavior of JavaScript in which variable and function declarations are moved to the top of their scope. Since only the actual declaration is hoisted, not the initialization, the value in the first example returns undefined.\n\nTo demonstrate this concept more clearly, below is the code we wrote and how JavaScript actually interpreted it.\n\n```jsx\n// The code we wrote\nconsole.log(num);\nvar num = 100;\n\n// How JavaScript interpreted it\nvar num;\nconsole.log(num);\nnum = 100;\n```\n\nJavaScript saved num to memory as a variable before the execution of the script. Since it was still called before it was defined, the result is undefined and not 100. However, it does not cause a ReferenceError and halt the script. Although the var keyword did not actually change location of the var, this is a helpful representation of how hoisting works. This behavior can cause issues, though, because the programmer who wrote this code likely expects the output of num to be true, when it is instead undefined.\n\nWe can also see how hoisting can lead to unpredictable results in the next example:\n```jsx\n// Initialize num in the global scope\nvar num = 100;\n\nfunction hoist() {\n  // A condition that should not affect the outcome of the code\n  if (false) {\n    var num = 200;\n  }\n  console.log(num); // undefined\n}\n\nhoist();\n```\n\nIn this example, we declared num to be 100 globally. Depending on an if statement, num could change to 200, but since the condition was false it should not have affected the value of num. Instead, num was hoisted to the top of the hoist() function, and the value became undefined.\n\nThis type of unpredictable behavior can potentially cause bugs in a program. Since let and const are block-scoped, they will not hoist in this manner, as seen below.\n\n```jsx\n// Initialize num in the global scope\nlet num = true;\n\nfunction hoist() {\n  // Initialize num in the function scope\n  if (3 === 4) {\n    let num = false;\n  }\n  console.log(num); // true\n}\n\nhoist();\n```\nDuplicate declaration of variables, which is possible with var, will throw an error with let and const.\n\n```jsx\n// Attempt to overwrite a variable declared with var\nvar num = 1;\nvar num = 2;\n\nconsole.log(num); // 2\n```\n\n```jsx\n// Attempt to overwrite a variable declared with let\nlet num1 = 1;\nlet num1 = 2;\n\nconsole.log(num1); // Uncaught SyntaxError: Identifier \'num1\' has already been declared\n```\n\nTo summarize, variables introduced with var have the potential of being affected by hoisting, a mechanism in JavaScript in which variable declarations are saved to memory. This may result in undefined variables in one\u2019s code. The introduction of let and const resolves this issue by throwing an error when attempting to use a variable before declaring it or attempting to declare a variable more than once.\n\nYou can check out the [Demo](https://praveenoruganti.github.io/courses/demo/js/Variables)\n\n\n\n\n '}}]);