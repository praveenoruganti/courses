(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[231],{800:function(e,n,r){"use strict";r.r(n),n.default=' Spring Security offers lots of capabilities to perform JDBC authentication using an existing DataSource configuration. \n\nIn JDBC based authentication user\u2019s authentication and authorization information are stored in the database.\n\nLets consider an example where we will create users with a different role and authenticate & authorized every request based on the logged-in user information stored in the MYSQL database.\n\n**Capture the user information and store the password in hashed form**\n\n```jsx\n@Bean\npublic BCryptPasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n}\n```\n\n**Configure the JDBC authentication by overriding configure(AuthenticationManagerBuilder auth) method of class WebSecurityConfigurerAdapter**\n\n```jsx\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\n  auth.jdbcAuthentication().dataSource(dataSource).passwordEncoder(passwordEncoder());\n}\n\n```\n\n**JdbcUserDetailsManager class is JDBC user management service to perform CRUD operations for both users and groups provided by Spring schema and it holds all the DML (Data Manipulation Language) and DQL (Data Query Language) commands.**\n\n```jsx\n@Bean\npublic JdbcUserDetailsManager jdbcUserDetailsManager() {\n    return new JdbcUserDetailsManager(dataSource);\n}\n```\n\n**Authenticate the request based on the logged-in user role/roles by overriding configure(HttpSecurity http) method**\n\n```jsx\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.csrf().disable().authorizeRequests()\n        .antMatchers("/admin").hasRole(ADMIN)\n        .antMatchers("/user").hasAnyRole(ADMIN, USER)\n        .antMatchers("/", "/register-user").permitAll()\n        .and().formLogin();\n}\n\n```\n\nWe will be developing the sample application based on the below\n\n- /register-user is used to create a new user and it is accessed by everyone.\n- /admin can be accessed by a user has a role \u2018ADMIN\u2019 only.\n- /user is allowed for a user has a role \u2018ADMIN\u2019 or \u2018USER\u2019.\n- / is allowed for everyone.\n\n**Setup Tables in MYSQL DB**\n\n**application.yml**\n\n```jsx\n\nspring:\n datasource:\n    url: jdbc:mysql://root:password-1@localhost:3306/praveenauthdb?reconnect=true \n    driverClassName: com.mysql.cj.jdbc.Driver \n    \n jpa:\n   hibernate:\n     ddl-auto: update  \n\n```\n\n**Tables to be created**\n\n```jsx\nCREATE TABLE users (\n  username VARCHAR(50) NOT NULL,\n  password VARCHAR(100) NOT NULL,\n  enabled TINYINT NOT NULL DEFAULT 1,\n  PRIMARY KEY (username)\n);\n\nCREATE TABLE authorities (\n  username VARCHAR(50) NOT NULL,\n  authority VARCHAR(50) NOT NULL,\n  FOREIGN KEY (username) REFERENCES users(username)\n);\n\nCREATE UNIQUE INDEX ix_auth_username\n  on authorities (username,authority);\n\n```\n\n\nCreate a MyUser model class which holds all the attributes of a user.\n\n```jsx\n@Data\npublic class MyUser {\n\n    private String userName;\n    private String password;\n    private String roles;\n}\n```\n\nUserController class exposes the REST endpoint for the application user. In this controller class, we have created 4 different REST endpoints as follows:\n\n- /register-user is used to create a new user and it is accessed by everyone.\n- /admin can be accessed by a user has a role \u2018ADMIN\u2019 only.\n- /user is allowed for a user has a role \u2018ADMIN\u2019 or \u2018USER\u2019.\n- / is allowed for everyone.\n\n```jsx\n@RestController\npublic class UserController {\n\n    @Autowired\n    private JdbcUserDetailsManager jdbcUserDetailsManager;\n\n    @Autowired\n    private BCryptPasswordEncoder passwordEncoder;\n\n    @PostMapping(value = "/register-user")\n    public void regiter(@RequestBody MyUser myUser) {\n        List<GrantedAuthority> authorities = new ArrayList<>();\n        authorities.add(new SimpleGrantedAuthority(myUser.getRoles()));\n        String encodededPassword = passwordEncoder.encode(myUser.getPassword());\n        User user = new User(myUser.getUserName(), encodededPassword, authorities);\n        jdbcUserDetailsManager.createUser(user);\n    }\n\n    @GetMapping(value = "/admin")\n    public String admin() {\n        return "<h3>Welcome Admin</h3>";\n    }\n\n    @GetMapping(value = "/user")\n    public String user() {\n        return "<h3>Hello User</h3>";\n    }\n\n    @GetMapping(value = "/")\n    public String welcome() {\n        return "<h3>Welcome</h3>";\n    }\n\n}\n\n```\n\nWebSecurityConfig is custom security configuration class which overrides the functionality of Spring Security provided by the WebSecurityConfigurerAdapter class. WebSecurityConfig class authenticate the user by overriding configure(AuthenticationManagerBuilder auth) method through the JDBC and authorized every requested based on logged-in user roles/permission by overriding configure(HttpSecurity http) method.\n\n```jsx\n@Configuration\n@EnableWebSecurity\npublic class ApplicationSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    private static final String ADMIN = "ADMIN";\n    private static final String USER = "USER";\n\n    @Autowired\n    DataSource dataSource;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.jdbcAuthentication().dataSource(dataSource).passwordEncoder(passwordEncoder());\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable().authorizeRequests()\n            .antMatchers("/admin").hasRole(ADMIN)\n            .antMatchers("/user").hasAnyRole(ADMIN, USER)\n            .antMatchers("/", "/register-user").permitAll()\n            .and().formLogin();\n    }\n\n    @Bean\n    public BCryptPasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Bean\n    public JdbcUserDetailsManager jdbcUserDetailsManager() {\n        return new JdbcUserDetailsManager(dataSource);\n    }\n\n}\n\n```\n\nThe DemoSecurityApplication class contains the main method and responsible to start the application.\n\n```jsx\n@SpringBootApplication\npublic class DemoSecurityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoSecurityApplication.class);\n    }\n\n}\n```\n\nTo test the application, start the Spring Boot application by executing the above class and follow the below steps:\n\n**For /register-user page**\n\n1. Open the Postman.\n2. Hit the localhost:8080/register-user using HTTP method POST to register yourself as ROLE_ADMIN or ROLE_USER. JSON\u2019s are provided below:\n\n```jsx\nSample Json for creation of user\n\n    JSON for ADMIN role\n    {\n        "userName":"praveen",\n        "password":"password123",\n        "roles":"ROLE_ADMIN"\n    }\n    JSON for USER role\n    {\n        "userName":"prasad",\n        "password":"password",\n        "roles":"ROLE_USER"\n    }\n\n\n```\n\n**For /admin page**\n\n1. Hit the localhost:8080/admin, it will redirect you to the login page.\n2. Log in with the user has a role "ADMIN" and after successful authentication, it will show you the admin page.\n3. Similarly, try to access the admin URL with user don\u2019t have the role of "ADMIN" (user has a role "USER"), Spring Security will block you to access the /admin page.\n\n**For /user page**\n\n1. Hit the localhost:8080/user, it will redirect you to the login page.\n2. Log in with the user has a role "USER" and after successful authentication, it will show you the user page.\n3. User has a role "ADMIN" can also access it.\n\n**For / page**\n\nSpring Security allows localhost:8080/ URL to be accessed by everyone. It doesn\u2019t require to be authenticated. '}}]);