(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[47],{616:function(e,n,t){"use strict";t.r(n),n.default=' It is a type of Creational Design Pattern.\n\nSometimes it\'s important for some classes to have exactly one instance. There are many objects we only need one instance of them and if we, instantiate more than one, we\'ll run into all sorts of problems like incorrect program behavior, overuse of resources, or inconsistent results.\n\nThere are only two points in the definition of a singleton design pattern,\n- There should be only one instance allowed for a class and\n- We should allow global point of access to that single instance.\n\n\nWe can make singleton class using below 5 approaches and my favourite is static inner class and Enum.\n\n1.  Using Eager Initialization\n\n```jsx\npublic class EagerSingletonExample {\n\n\tprivate static EagerSingletonExample instance = new EagerSingletonExample();\n\n\tprivate EagerSingletonExample() {\n\n\t}\n\n\tpublic static EagerSingletonExample getInstance() {\n\t\treturn instance;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tEagerSingletonExample ese1 = EagerSingletonExample.getInstance();\n\t\tEagerSingletonExample ese2 = EagerSingletonExample.getInstance();\n\t\tif (ese1.equals(ese2)) {\n\t\t\tSystem.out.println("Single Object");\n\t\t} else {\n\t\t\tSystem.out.println("Multiple Objects");\n\t\t}\n\t}\n\n}\n\n```\n\n2. Using Lazy Initialization\n\n```jsx\n\npublic class LazySingletonExample {\n\tprivate static LazySingletonExample instance =null;\n\n\tprivate LazySingletonExample() {\n\n\t}\n\n\tpublic static LazySingletonExample getInstance() {\n\t\tif(instance==null) {\n\t\t\tinstance= new LazySingletonExample();\n\t\t}\n\t\treturn instance;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tLazySingletonExample lse1 = LazySingletonExample.getInstance();\n\t\tLazySingletonExample lse2 = LazySingletonExample.getInstance();\n\t\tif (lse1.equals(lse2)) {\n\t\t\tSystem.out.println("Single Object");\n\t\t} else {\n\t\t\tSystem.out.println("Multiple Objects");\n\t\t}\n\t}\n}\n\n\n```\n\nLazy initialization will be beneficial when we want to delay the initialization until it is not needed. because if we use eager initialization and if initialization fails there is no chance to get the instance further while in lazy initialization we may get it in second chance. In Lazy initialization we will not get instance until we call getInstance() method while in eager initialization it creates instance at the time of class loading.\n\n\n3.  Using Double checked Locking\n\n```jsx\npublic class DoubleCheckedLockSingletonExample {\n\tprivate static volatile DoubleCheckedLockSingletonExample instance =null;\n\n\tprivate DoubleCheckedLockSingletonExample() {\n\n\t}\n\n\tpublic static DoubleCheckedLockSingletonExample getInstance() {\n\t\tif(instance==null) {\n\t\t\tsynchronized(DoubleCheckedLockSingletonExample.class) {\n\t\t\t\tif(instance==null) {\n\t\t\t\t\tinstance= new DoubleCheckedLockSingletonExample();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tDoubleCheckedLockSingletonExample dclse1 = DoubleCheckedLockSingletonExample.getInstance();\n\t\tDoubleCheckedLockSingletonExample dclse2 = DoubleCheckedLockSingletonExample.getInstance();\n\t\tif (dclse1.equals(dclse2)) {\n\t\t\tSystem.out.println("Single Object");\n\t\t} else {\n\t\t\tSystem.out.println("Multiple Objects");\n\t\t}\n\t}\n}\n\n```\n\nSingleton will work properly in multithreaded environment only if eager instantiation has been done because in this case instance creation will happen at the time of class loading only. But for Lazy instantiation we will have to take care of multiple things. If we want to delay the instantiation because of cost, we use to go with lazy.\nFollowing code demonstrates the behavior of Singleton instance when two threads are getting executed by comparing their hash code values. Be careful while running the\nfollowing code as it will work only in Java 8 and later versions.\n\nWhen you run the above program many times you will notice that in multithreaded environment sometimes Singleton principle works but sometimes it violates. Therefore we\nneed to synchronize the getInstance() method.\n\nAfter applying synchronize keyword in the getInstance() method the program will execute properly without any issue but in Java instead of synchronizing whole method we\ncan synchronize only the block of code which is affected while creating instance to escape the extra overhead.\n\nNotice that if a thread sees that instance is null and then it gets the lock of object. At the same time if another thread already has the lock it will create the instance. So to make sure no other thread has already acquired the lock we will apply one more check after acquiring the lock as shown below. This method is called `Double Checked Locking`.\n\nSometimes double checked locking also breaks the Principle of Singleton.\n\nJava runtime publishes half initialized variable. Suppose 2 threads threa1 & thread2 are entering into the code and created the instance. At the same time thread 2 enters and it knows that there is something in variable named as instance (since it is at half initialized state) and it returns the same. Therefore Singleton principle breaks.\n\nTo address this situation use volatile keyword at the time of instance declaration. Value of volatile variable will be published only when the change completes. Change to write operation happens before read operation in volatile variable. In short all threads will see the same value of variable.\n\n\n4.  Using an inner static helper class\n\nBill Pugh came up with a different approach to create the Singleton class using an inner static helper class.\n\n```jsx\n\npublic class InnerClassSingletonExample {\n\n\tprivate InnerClassSingletonExample() {\n\n\t}\n\n\tpublic static class SingletonHolder {\n\t\tprivate static InnerClassSingletonExample instance = new InnerClassSingletonExample();\n\t}\n\n\tpublic static InnerClassSingletonExample getInstance() {\n       return SingletonHolder.instance;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInnerClassSingletonExample icse1= InnerClassSingletonExample.getInstance();\n\t\tInnerClassSingletonExample icse2= InnerClassSingletonExample.getInstance();\n\t\tif(icse1.equals(icse2)) {\n\t\t\tSystem.out.println("Single Object");\n\t\t}else {\n\t\t\tSystem.out.println("Multiple Objects");\n\t\t}\n\n\t}\n\n}\n\n\n```\n\n5.  Using Enum\n\nJoshua Bloch suggests the use of Enum to implement Singleton design pattern as Java ensures that any enum value is instantiated only once in a Java program. Since Java Enum values are globally accessible, so is the singleton. The drawback is that the enum type is somewhat inflexible; for example, it does not allow lazy initialization.\n\n\n```jsx\n\npublic enum EnumSingletonExample {\n\tINSTANCE;\n\tpublic static void main(String args[]) {\n\t\tEnumSingletonExample ese1 = EnumSingletonExample.INSTANCE;\n\t\tEnumSingletonExample ese2 = EnumSingletonExample.INSTANCE;\n\t\tif (ese1.equals(ese2)) {\n\t\t\tSystem.out.println("Single Object");\n\t\t} else {\n\t\t\tSystem.out.println("Multiple Objects");\n\t\t}\n\t}\n\n}\n\n\n```\n\n\n### Benefits\n\n- Limits the objects creations.\n- Reduces the memory required.\n- Reduces garbage collection.\n- Helps in Lazy initialization. That means, an object is not created until we need it and call the getInstance() method.\n- Saves memory as the instances are reused.\n\n### Limitations\n\n- Same object is shared hence the object must be immutable.\n- We can not have class level variables,If we use they will be overridden by other client.\n- Extra code need to write for making it singleton this increases complexity.\n- The getInstance() method is not thread safe, but can be overcome by using synchronized keyword.\n\nSingleton Pattern is generally used for logging,driver objects,caching and threadpool.\n\n### Singleton Design Pattern Example in JDK\n\nSome of the singleton pattern example in Java classes are;\n\n- java.lang.Runtime.getRuntime(): This method gives Runtime class that has only one instance in a JVM.\n- java.lang.System.getSecurityManager(): This method returns a SecurityManager for the current platform.\n- java.awt.Desktop.getDesktop()\n\n '}}]);