(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[132],{701:function(n,e,t){"use strict";t.r(e),e.default=' ## This keyword\n\n1. `this` is to refer to the current instance variable of the class.\n\nFor example,\n\n```jsx\nclass Sample{  \n   int a;   \n   Sample(int a){  \n       this.a=a;  \n   }  \n   void display(){\n       System.out.println("a = "+a);\n   }  \n}  \n \nclass Test{  \n   public static void main(String args[]){  \n       Sample s1=new Sample(10);  \n       s1.display();   \n   }\n} \n```\n\n**Output**\n```jsx\na=10\n```\n\n2. `this`: to call the method of the current class.\n\nThe this keyword can be used to call a method in the current class. If you don\'t use this keyword, the compiler will add it for you when you call the method. \n\nFor example,\n\n```jsx\nclass Sample{  \n   void fun()\n   {\n       System.out.println("hello there");\n   }  \n   void foo(){  \n       System.out.println("hello foo");   \n       this.fun();  \n   }  \n}  \nclass Test{  \n   public static void main(String args[]){  \n       Sample s = new Sample();  \n       s.foo();  \n   }\n}\n\n```\n\n**Output**\n\n```jsx\nhello foo\nhello there\n```\n\n3. `this()` is used to call the constructor of the current class.\n\nFor example,\n\n```jsx\nclass Sample{  \n   Sample()\n   {\n       System.out.println("In default constructor");\n   }\n   Sample(int a)\n   {\n       this();\n       System.out.println("In Parameterised constructor");\n   }  \n}  \nclass Test{  \n   public static void main(String args[]){  \n       Sample s = new Sample(10);    \n   }\n}\n```\n\n**Output**\n```jsx\nIn default constructor\nIn Parameterised constructor\n```\n\n4. `this`: to use as a parameter in a method.\n\n```jsx\nclass Sample{  \n   void fun(Sample obj)\n   {\n       System.out.println("Received the object");\n   }  \n   void foo(){  \n       fun(this); \n   }  \n}  \nclass Test{  \n   public static void main(String args[]){  \n       Sample s = new Sample();  \n       s.foo();  \n   }\n}\n```\n\n**Output**\n```jsx\nReceived the object\n```\n\n5. `this` keyword can be used to get the current instance of a class.\n\n```jsx\nclass Sample{  \n   Sample getObject()\n   {\n       return this;\n   }  \n   void foo(){  \n       System.out.println("Inside foo function")\n   }  \n}  \nclass Test{  \n   public static void main(String args[]){  \n       Sample s = new Sample();  \n       s.getObject().foo();  \n   }\n}\n```\n\n**Output**\n```jsx\nInside foo function\n```\n\n## Final keyword\n\n**Final Variable** : Variable can\'t be reassigned, generally used for creation of constant variables.\n\n```jsx\nfinal int temp = 10;\n```\n\n**Final Methods** : Prevent Method Overriding\n\n```jsx\nclass Sample\n{\n    final void fun()\n    {\n       System.out.println("Inside fun function");\n    }\n}\nclass Test extends Sample \n{ \n   void fun() // COMPILE-ERROR!\n   {\n       //code\n   }\n}\n```\n\n**Final Classes** : Prevent Inheritance\n\n```jsx\nfinal class Sample\n{\n    // code\n}\nclass Test extends Sample // COMPILE-ERROR!\n{ \n   // code \n}\n```\n\n`Note`\n\nIf your class is declared as final it is \ud835\udc2b\ud835\udc1e\ud835\udc1d\ud835\udc2e\ud835\udc27\ud835\udc1d\ud835\udc1a\ud835\udc27\ud835\udc2d to mark your methods final as well, because if your class can\'t be extended by other classes, that means your methods can\'t be overridden.\n\nBe aware that if you mark a mutable variable as \ud835\udc1f\ud835\udc22\ud835\udc27\ud835\udc1a\ud835\udc25, it means that you can\'t change the reference of that variable, but you can still change the state of that variable.\n\n\n## Static keyword\n\n**Static Variable**\n\n- When a variable is declared as a static, then a single copy of the variable is created and shared among all objects at class level.\n- The static variable can be used to refer to the common property of all the objects.\n- We can say static variables are global variables.\n- The static variables get memory only once in the class that is at the time of class loading.\n\nFor example,\n\n```jsx\nclass Test\n{\n   // static variable\n   static int x = fun();\n     \n   // static block\n   static {\n       System.out.println("Inside static block");\n   }\n     \n   // static method\n   static int fun() {\n       System.out.println(Inside fun function");\n       return 10;\n   }\n     \n   public static void main(String[] args)\n   {\n      System.out.println("Value of x : " + x);\n      System.out.println("Inside main method");\n   }\n}\n```\n**Output**\n```jsx\nInside fun function\nInside static block\nValue of x : 10\nInside main method\n```\n\n**Static Block**\n\n- It is executed before the main method at the time of loading of class only.\n- If we want to perform any operation before the main method then we can put that in static block.\n- Static block is basically used to initialize the static data member.\n\nFor example,\n\n```jsx\nclass Test\n{\n   static int x = 25;\n   static int y;\n     \n   // static block\n   static {\n       System.out.println("Inside Static block.");\n       y = x * 4;\n   }\n \n   public static void main(String[] args)\n   {\n      System.out.println("Value of x : " + x);\n      System.out.println("Value of y : " + y);\n   }\n}\n```\n\n**Output**\n```jsx\nInside Static block.\nValue of x : 25\nValue of y : 100\n```\n\n**Static Method**\n\n- A static method can be invoked without the need for creating an instance of a class.\n- A static method can access static data member and can change the value of it.\n- A static method belongs to the class rather than the object of a class.\n\nFor example,\n\n```jsx\nclass Test\n{\n   \n   static int x = 1; // static variable\n   int y = 20; // instance variable\n     \n   \n   static void fun() // static method\n   {\n       x = 20;\n       System.out.println("Inside fun function");\n         \n        y = 10; // compilation error since there is a static reference to the non-static field b\n                 \n        foo();  // compilation error since there is a static reference to the non-static method foo()\n           \n        System.out.println(super.a); // compilation error since we cannot use super in a static context\n   }\n     \n   void foo() // instance method\n   {    \n       System.out.println("Inside foo function");\n   }\n   public static void main(String[] args)\n   {\n       // main method \n   }\n}\n```\n\n**Output**\n\n```jsx\nThe above code results in a compilation error. There are 3 reasons for it.\n\nWe are accessing an instance variable inside a static method and changing its value.\nWe are invoking an instance method inside a static method.\nWe are trying to make use of the super keyword inside a static method.\n```\n\n**Static Classes**\n\nWhen a class is declared with the static keyword, it is said to be a static class. A class can be made static in Java if and only if it is nested inside another class. We can\'t use the static modifier on top-level classes, but we can use it on nested classes. \n\nFor example,\n\n```jsx\npublic class Test {\n \n   private static String str = "Praveen Oruganti Tech";\n \n   // Static class\n   static class Sample {\n       \n       public void display(){ \n         System.out.println(str); \n       }\n   }\n   \n   public static void main(String args[])\n   {\n       Test.Sample obj\n           = new Test.Sample();\n       obj.display();\n   }\n}\n```\n\n**Output**\n```jsx\nPraveen Oruganti Tech\n```\n\n**Why is Java main method static?**\n\n- It is because the object is not required to call the static method.\n- Suppose, the main method is non static, then every time we need to create the object of the class and then only can call the main method and it will lead to problem of extra memory allocation.\n\n\n## Super Keyword\n\nIn Java, the super keyword is a reference variable that refers to parent class instances. With the concept of Inheritance, the term `super` entered the picture.\n\n1. Using super with variables\n\nWhen a derived class and a base class have identical data members, there is uncertainty for the JVM as to which class\'s data member is being referred to. In order to resolve this ambiguity, we use the super keyword with the data member\'s name.\n\nFor example,\n\n```jsx\nclass Sample1\n{\n   int x = 1;\n}\n \nclass Sample2 extends Sample1\n{\n   int x = 2;\n \n   void display()\n   {\n       System.out.println("The value of x is : " + super.x);\n   }\n}\n \nclass Test\n{\n   public static void main(String[] args)\n   {\n       Sample2 s = new Sample2();\n       s.display();\n   }\n}\n```\n\n**Output**\n\n```jsx\nThe value of x is : 1\n```\n\n2. Using super with methods\n\nTo resolve ambiguity when a parent and child class have the same-named methods, we employ the super keyword. \n\n```jsx\nclass Sample1\n{\n   void fun()\n   {\n       System.out.println("Inside Sample1\'s fun method");\n   }\n}\n \nclass Sample2 extends Sample1\n{\n   void fun()\n   {\n       System.out.println("Inside Sample2\'s fun method");\n   }\n \n   void display()\n   {\n       super.fun();\n   }\n}\n \nclass Test\n{\n   public static void main(String[] args)\n   {\n       Sample2 s = new Sample2();\n       s.display();\n   }\n}\n```\n\n**Output**\n\n```jsx\nInside Sample1\'s fun method\n```\n\nLet\'s see another example,\n\n```jsx\nclass Sample1\n{\n   Sample1()\n   {\n       System.out.println("Inside Sample1\'s default constructor.")\n   }\n}\n \nclass Sample2 extends Sample1\n{\n   Sample2()\n   {\n       super();\n       System.out.println("Inside Sample2\'s default constructor.");\n   }\n}\n \nclass Test\n{\n   public static void main(String[] args)\n   {\n       Sample2 s = new Sample2();\n   }\n}\n```\n\n**Output**\n\n```jsx\nInside Sample1\'s default constructor.\nInside Sample2\'s default constructor.\n```\n\n '}}]);