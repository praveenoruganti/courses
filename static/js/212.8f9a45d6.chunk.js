(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[212],{781:function(n,e,t){"use strict";t.r(e),e.default=" A transaction is a logical unit of work that contains one or more statements. A transaction is an atomic unit. The effects of all the statements in a transaction can be either all committed or all rolled back.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/spring/transaction.PNG)\n\nTransaction management is an important part of enterprise applications to ensure data integrity and consistency.\n\nThe concept of transactions can be described as ACID(Atomicity, Consistency, Isolation, Durability) property:\n\n- Atomicity\n\nAtomicity requires that each transaction is \u201call or nothing\u201d which means either the sequence of a transaction is successful or unsuccessful.\n\nIf one part of a transaction fails then entire transaction fails.\n\n- Consistency\n\nThe database value should be consistent from state to state while any data written to the database for any combination of constraints, cascade, triggers etc.\n\n- Isolation\n\nEach transaction must be executed in isolation in concurrent environment to prevent data corruption.\n\n- Durability\n\nOnce a transaction has been committed, the results of this transaction have to be made permanent even in the event of power loss crashes, or errors.\n\n**The Spring transaction management**\n\nWe will go over on how does @Transactional really work under the hood.\n\n- how to use features like propagation and isolation\n- what are the main pitfalls and how to avoid them\n\n**Any bean in Spring is annotated with @Transactional will be intercepted by Proxy.**\n\nThis type of transaction is called declarative transactions.This proxy can be jdk proxy or cglib proxy.\n\n**There are 5 types of Isolation levels are available**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/spring/isolationlevels.PNG)\n\n**DEFAULT**\n\nUse the default isolation level of the underlying datastore. All other levels correspond to the JDBC isolation levels.\n\n**READ_UNCOMMITTED**\n\nThis level allows a row changed by one transaction to be read by another transaction before any changes in that row have been committed\n(a \"dirty read\"). If any of the changes are rolled back, the second transaction will have retrieved an invalid row.\n\n**READ_COMMITTED**\n\nThis level only prohibits a transaction from reading a row with uncommitted changes in it.\n\n**REPEATABLE_READ**\n\nThis level prohibits a transaction from reading a row with uncommitted changes in it, and it also prohibits the situation where one transaction reads a row, a second transaction alters the row, and the first transaction rereads the row, getting different values the second time (a \"non-repeatable read\").\n\n**SERIALIZABLE**\n\nThis level includes the prohibitions in {@code ISOLATION_REPEATABLE_READ} and further prohibits the situation where one transaction reads all rows that satisfy a {@code WHERE} condition, a second transaction inserts a row that satisfies that {@code WHERE} condition, and the first transaction rereads for the same condition, retrieving the additional \"phantom\" row in the second read.\n\n**There are 7 types of propagation levels.**\n\n**REQUIRED**\n\nSupport a current transaction, create a new one if none exists. Analogous to EJB transaction attribute of the same name.This is the default setting of a transaction annotation.\n\n**SUPPORTS**\n\nSupport a current transaction, execute non-transactionally if none exists. Analogous to EJB transaction attribute of the same name.\n\n**MANDATORY**\n\nSupport a current transaction, throw an exception if none exists.Analogous to EJB transaction attribute of the same name.\n\n**REQUIRES_NEW**\n\nCreate a new transaction, and suspend the current transaction if one exists.Analogous to the EJB transaction attribute of the same name.\n\n**NOT_SUPPORTED**\n\nExecute non-transactionally, suspend the current transaction if one exists. Analogous to EJB transaction attribute of the same name.\n\n**NEVER**\n\nExecute non-transactionally, throw an exception if a transaction exists. Analogous to EJB transaction attribute of the same name.\n\n**NESTED**\n\nExecute within a nested transaction if a current transaction exists, behave like {@code REQUIRED} otherwise. There is no analogous feature in EJB.\n\n**@Transactional**\n\n\n@Transactional on a class applies to each method on the service. It is a shortcut. Typically, you can set @Transactional(readOnly = true) on a service class, if you know that all methods will access the repository layer. You can then override the behavior with @Transactional on methods performing changes in your model.\n\nRollbacks the RuntimeException but does not rollback the checked exception.\n\n**JPA and Transaction Management**\n\nIt's important to notice that JPA on itself does not provide any type of declarative transaction management. When using JPA outside of a dependency injection container, transactions need to be handled programatically by the developer:\n\n```jsx\nUserTransaction utx = entityManager.getTransaction();\ntry {\nutx.begin();\nbusinessLogic();\nutx.commit();\n} catch(Exception ex) {\nutx.rollback();\nthrow ex;\n}\n\n\n```\n\nThis way of managing transactions makes the scope of the transaction very clear in the code, but it has several disadvantages:\n\n- it's repetitive and error prone\n- any error can have a very high impact\n- errors are hard to debug and reproduce\n- this decreases the readability of the code base\n\n**What if this method calls another transactional method?**\n\n**Using Spring @Transactional**\n\nWith Spring @Transactional, the above code gets reduced to simply this\n\n```jsx\n@Transactional\npublic void businessLogic() {\n// use entity manager inside a transaction\n}\n```\n\nThis is much more convenient and readable, and is currently the recommended way to handle transactions in Spring.\n\nBy using @Transactional, many important aspects such as transaction propagation are handled automatically. In this case if another transactional method is called by businessLogic(), that method will have the option of joining the ongoing transaction.\n\nOne potential downside is that this powerful mechanism hides what is going on under the hood, making it hard to debug when things don't work.\n\n**What does @Transactional mean?**\n\nOne of the key points about @Transactional is that there are two separate concepts to consider, each with it's own scope and life cycle:\n\n- the persistence context\n- the database transaction\n\nThe transactional annotation itself defines the scope of a single database transaction. The database transaction happens inside the scope of apersistence context.\n\nThe persistence context is in JPA the EntityManager, implemented internally using an Hibernate Session (when using Hibernate as the persistence provider).\n\nThe persistence context is just a synchronizer object that tracks the state of a limited set of Java objects and makes sure that changes on those objects are eventually persisted back into the database.\n\nThis is a very different notion than the one of a database transaction. One Entity Manager can be used across several database transactions, and it actually often is.\n\n**When does an EntityManager span multiple database transactions?**\n\nThe most frequent case is when the application is using the Open Session In View pattern to deal with lazy initialization exceptions, see this previous blog post for it's pros and cons.\n\nIn such case the queries that run in the view layer are in separate database transactions than the one used for the business logic, but they are made via the same entity manager.\n\nAnother case is when the persistence context is marked by the developer as PersistenceContextType.EXTENDED, which means that it can survive multiple requests.\n\n**What defines the EntityManager vs Transaction relation?**\n\nThis is actually a choice of the application developer, but the most frequent way to use the JPA Entity Manager is with the\n\"Entity Manager per application transaction\" pattern.\n\nThis is the most common way to inject an entity manager:\n\n```jsx\n@PersistenceContext\nprivate EntityManager em;\n```\n\nHere we are by default in \"Entity Manager per transaction\" mode. In this mode, if we use this Entity Manager inside a @Transactional method, then the method will run in a single database transaction.\n\n**How does @PersistenceContext work?**\n\nOne question that comes to mind is, how can @PersistenceContext inject an entity manager only once at container startup time, given that entity managers are so short lived, and that there are usually multiple per request.\n\nThe answer is that it can't: EntityManager is an interface, and what gets injected in the spring bean is not the entity manager itself but a context aware proxy that will delegate to a concrete entity manager at runtime.\n\nUsually the concrete class used for the proxy is SharedEntityManagerInvocationHandler, this can be confirmed with the help a debugger.\n\n**How does @Transactional work then?**\n\nThe persistence context proxy that implements EntityManager is not the only component needed for making declarative transaction management work.\n\nActually three separate components are needed:\n\n- The EntityManager Proxy itself\n- The Transactional Aspect\n- The Transaction Manager\n\n**Let's go over each one and see how they interact.**\n\n**The Transactional Aspect**\n\nThe Transactional Aspect is an 'around' aspect that gets called both before and after the annotated business method. The concrete class for implementing the aspect is TransactionInterceptor.\n\n**The Transactional Aspect has two main responsibilities**\n\nAt the 'before' moment, the aspect provides a hook point for determining if the business method about to be called should run in the scope of an ongoing database transaction, or if a new separate transaction should be started.\n\nAt the 'after' moment, the aspect needs to decide if the transaction should be committed, rolled back or left running.\n\nAt the 'before' moment the Transactional Aspect itself does not contain any decision logic, the decision to start a new transaction if needed is delegated to the Transaction Manager.\n\n**The Transaction Manager**\n\nThe transaction manager needs to provide an answer to two questions:\n\n- should a new Entity Manager be created?\n- should a new database transaction be started?\n\nThis needs to be decided at the moment the Transactional Aspect 'before' logic is called. The transaction manager will decide based on:\n\n- the fact that one transaction is already ongoing or not\n- the propagation attribute of the transactional method (for example REQUIRES_NEW always starts a new transaction)\n\nIf the transaction manager decides to create a new transaction, then it will:\n\n- create a new entity manager\n- bind the entity manager to the current thread\n- grab a connection from the DB connection pool\n- bind the connection to the current thread\n\nThe entity manager and the connection are both bound to the current thread using ThreadLocal variables.\n\nThey are stored in the thread while the transaction is running, and it's up to the Transaction Manager to clean them up when no longer needed.\n\nAny parts of the program that need the current entity manager or connection can retrieve them from the thread. One program component that does exactly that is the EntityManager proxy.\n\n**The EntityManager proxy**\n\nThe EntityManager proxy (that we have introduced before) is the last piece of the puzzle. When the business method calls for example\nentityManager.persist(), this call is not invoking the entity manager directly.\n\nInstead the business method calls the proxy, which retrieves the current entity manager from the thread, where the Transaction Manager put it.\n\nKnowing now what are the moving parts of the @Transactionalmechanism, let's go over the usual Spring configuration needed to make this work.\n\n**Putting It All Together**\n\nLet's go over how to setup the three components needed to make the transactional annotation work correctly. We start by defining the entity manager factory.\n\nThis will allow the injection of Entity Manager proxies via the persistence context annotation:\n\n```jsx\n@Configuration\npublic class EntityManagerFactoriesConfiguration {\n@Autowired\nprivate DataSource dataSource;\n@Bean(name = \"entityManagerFactory\")\npublic LocalContainerEntityManagerFactoryBean emf() {\nLocalContainerEntityManagerFactoryBean emf = ...\nemf.setDataSource(dataSource);\nemf.setPackagesToScan(new String[] {\"your.package\"});\nemf.setJpaVendorAdapter(\nnew HibernateJpaVendorAdapter());\nreturn emf;\n}\n}\n\n```\n\nThe next step is to configure the Transaction Manager and to apply the Transactional Aspect in @Transactional annotated classes\n\n```jsx\n@Configuration\n@EnableTransactionManagement\npublic class TransactionManagersConfig {\n@Autowired\nEntityManagerFactory emf;\n@Autowired\nprivate DataSource dataSource;\n@Bean(name = \"transactionManager\")\npublic PlatformTransactionManager transactionManager() {\nJpaTransactionManager tm = new JpaTransactionManager();\ntm.setEntityManagerFactory(emf);\ntm.setDataSource(dataSource);\nreturn tm;\n}\n}\n\n```\n\nThe annotation @EnableTransactionManagement tells Spring that classes with the @Transactional annotation should be wrapped with the Transactional Aspect. With this the @Transactional is now ready to be used.\n "}}]);