(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[216],{785:function(e,n,t){"use strict";t.r(n),n.default=' ## DI(Dependency Injection)\n\nIt is a form of IOC where implementations are passed into an object through constructors/setters which the object will depend on in order to behave correctly.\n\n## Setter Injection\n\nSpring Setter Injection is nothing but injecting the Bean Dependencies using the Setter methods on an Object.\n\nUnlike Spring Constructor Injection, in Setter Injection, the object is created first and then the dependency is injected.\n\nFor example,\n\n1. **XML based injection**\n\n**beans.xml**\n\n```jsx\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"\n        "http://www.springframework.org/dtd/spring-beans-2.0.dtd">\n<beans>\n <bean id="department" class="com.praveen.core.di.setter.xml.SIDepartment">\n  <property name="deptName" value="Tech" />\n  <property name="deptId" value="1000" />\n </bean>\n\n <bean id="employee" class="com.praveen.core.di.setter.xml.SIEmployee">\n  <property name="empName" value="Praveen" />\n  <property name="empId" value="149903" />\n  <property name="empSal" value="10000000"/>\n  <property name="dept" ref="department" />\n </bean>\n</beans>\n\n```\n\n```jsx\npublic class SIDepartment {\n\n private String deptName;\n private int deptId;\n\n public SIDepartment() {\n\n }\n\n public String getDeptName() {\n  return deptName;\n }\n\n public void setDeptName(String deptName) {\n  this.deptName = deptName;\n }\n\n public int getDeptId() {\n  return deptId;\n }\n\n public void setDeptId(int deptId) {\n  this.deptId = deptId;\n }\n\n}\n```\n```jsx\npublic class SIEmployee {\n\n private String empName;\n private int empId;\n private double empSal;\n private SIDepartment dept;\n\n public SIEmployee() {\n\n }\n\n public String getEmpName() {\n  return empName;\n }\n\n public void setEmpName(String empName) {\n  this.empName = empName;\n }\n\n public int getEmpId() {\n  return empId;\n }\n\n public void setEmpId(int empId) {\n  this.empId = empId;\n }\n\n public double getEmpSal() {\n  return empSal;\n }\n\n public void setEmpSal(double empSal) {\n  this.empSal = empSal;\n }\n\n public SIDepartment getDept() {\n  return dept;\n }\n\n public void setDept(SIDepartment dept) {\n  this.dept = dept;\n }\n\n}\n```\n```jsx\npublic class SetterInjectionTest {\n\n public static void main(String[] args) {\n  \n  // Usage of BeanFactory\n  \n  @SuppressWarnings("deprecation")\n  BeanFactory factory = new XmlBeanFactory(new ClassPathResource("beans.xml"));\n  \n  SIEmployee emp= (SIEmployee)factory.getBean("employee");\n  \n  System.out.println("Employee Id :"+emp.getEmpId());\n  System.out.println("Employee Name :"+emp.getEmpName());\n  System.out.println("Employee Salary :"+emp.getEmpSal());\n  System.out.println("Employee Department ID :" + emp.getDept().getDeptId());\n  System.out.println("Employee Department Name :" + emp.getDept().getDeptName());\n  \n  // Usage of ApplicationContext\n  \n  AbstractApplicationContext context= new ClassPathXmlApplicationContext("beans.xml");\n  SIEmployee emp1= (SIEmployee)context.getBean("employee");\n  \n  System.out.println("Employee1 Id :"+emp1.getEmpId());\n  System.out.println("Employee1 Name :"+emp1.getEmpName());\n  System.out.println("Employee1 Salary :"+emp1.getEmpSal());\n  System.out.println("Employee1 Department ID :" + emp1.getDept().getDeptId());\n  System.out.println("Employee1 Department Name :" + emp1.getDept().getDeptName());\n  \n  context.close();\n\n }\n\n}\n\n```\n\n**Output**\n\n```jsx\n\nSep 07, 2019 5:26:24 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\nINFO: Loading XML bean definitions from class path resource [beans.xml]\n\nEmployee Id :149903\n\nEmployee Name :Praveen\n\nEmployee Salary :1.0E7\n\nEmployee Department ID :1000\n\nEmployee Department Name :Tech\n\nSep 07, 2019 5:26:25 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh\nINFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@26f67b76: startup date [Sat Sep 07 17:26:25 IST 2019]; root of context hierarchy\n\nSep 07, 2019 5:26:25 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\nINFO: Loading XML bean definitions from class path resource [beans.xml]\n\nEmployee1 Id :149903\n\nEmployee1 Name :Praveen\n\nEmployee1 Salary :1.0E7\n\nEmployee1 Department ID :1000\n\nEmployee1 Department Name :Tech\n\nSep 07, 2019 5:26:25 PM org.springframework.context.support.AbstractApplicationContext doClose\nINFO: Closing org.springframework.context.support.ClassPathXmlApplicationContext@26f67b76: startup date [Sat Sep 07 17:26:25 IST 2019]; root of context hierarchy\n\n```\n\n2. **Annotation based injection**\n\nWe will make use of above SIDepartment.java and SIEmployee.java and will replace the beans.xml with SIEmployeeConfig.java\n\n```jsx\n@Configuration\npublic class SIEmployeeConfig {\n\n @Bean(name="siemployee")\n public SIEmployee siemployee(){\n  SIEmployee emp= new SIEmployee();\n  SIDepartment dept= new SIDepartment();\n  dept.setDeptId(1000);\n  dept.setDeptName("Tech");\n  \n  emp.setDept(dept);\n  emp.setEmpId(149903);\n  emp.setEmpName("Praveen");\n  emp.setEmpSal(10000000d);\n  return emp;\n }\n}\n```\n\n```jsx\npublic class SetterInjectionTest {\n\n public static void main(String[] args) {\n  \n  \n  AnnotationConfigApplicationContext context= new AnnotationConfigApplicationContext();\n  context.register(SIEmployeeConfig.class);\n  \n  context.refresh();\n  \n  SIEmployee emp1= (SIEmployee)context.getBean("siemployee");\n  System.out.println("Employee1 Id :"+emp1.getEmpId());\n  System.out.println("Employee1 Name :"+emp1.getEmpName());\n  System.out.println("Employee1 Salary :"+emp1.getEmpSal());\n  System.out.println("Employee1 Department ID :" + emp1.getDept().getDeptId());\n  System.out.println("Employee1 Department Name :" + emp1.getDept().getDeptName());\n  \n  context.close();\n\n }\n\n}\n```\n\n**Output**\n\n```jsx\n\nSep 07, 2019 6:05:04 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh\nINFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2cdf8d8a: startup date [Sat Sep 07 18:05:04 IST 2019]; root of context hierarchy\n\nEmployee1 Id :149903\n\nEmployee1 Name :Praveen\n\nEmployee1 Salary :1.0E7\n\nEmployee1 Department ID :1000\n\nEmployee1 Department Name :Tech\n\nSep 07, 2019 6:05:05 PM org.springframework.context.support.AbstractApplicationContext doClose\nINFO: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2cdf8d8a: startup date [Sat Sep 07 18:05:04 IST 2019]; root of context hierarchy\n\n```\n\nIn setter injection, the objects get created first and then the dependency is injected.\n\nIn case of Setter Injection, the setter methods are annotated with @Autowired. Spring will first use the no-argument constructor to instantiate the bean and then call setter methods to inject the dependencies.\n\n\n## Constructor based Injection\n\nIt is a type of Spring Dependency Injection, where object\u2019s constructor is used to inject dependencies. This type of injection is safer as the objects won\u2019t get created if the dependencies aren\u2019t available or dependencies cannot be resolved.\n\nFor example,\n\n1. **Using XML  based configuration**\n\n**beans.xml**\n\n```jsx\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"\n        "http://www.springframework.org/dtd/spring-beans-2.0.dtd">\n<beans>\n \n <bean id="condepartment" class="com.praveen.core.di.constructor.xml.CIDepartment">\n  <constructor-arg value="Tech"/>\n  <constructor-arg value="100"/>\n </bean>\n\n <bean id="conemployee" class="com.praveen.core.di.constructor.xml.CIEmployee">\n  <constructor-arg value="Praveen"/>\n  <constructor-arg value="149903"/>\n  <constructor-arg value="10000000"/>\n  <constructor-arg ref="condepartment"/>  \n </bean>\n\n</beans>\n\n\n```\n\n```jsx\npublic class CIDepartment {\n \n private String deptName;\n private int deptId;\n \n public CIDepartment(String deptName, int deptId) {\n  super();\n  this.deptName = deptName;\n  this.deptId = deptId;\n }\n public String getDeptName() {\n  return deptName;\n }\n \n public int getDeptId() {\n  return deptId;\n } \n\n}\n\n\n```\n\n```jsx\npublic class CIEmployee {\n\n private String empName;\n private int empId;\n private double empSal;\n private CIDepartment dept;\n\n public CIEmployee(String empName, int empId, double empSal, CIDepartment dept) {\n  super();\n  this.empName = empName;\n  this.empId = empId;\n  this.empSal = empSal;\n  this.dept = dept;\n }\n\n public String getEmpName() {\n  return empName;\n }\n\n public int getEmpId() {\n  return empId;\n }\n\n public double getEmpSal() {\n  return empSal;\n }\n\n public CIDepartment getDept() {\n  return dept;\n }\n\n}\n\n\n```\n\n```jsx\n\npublic class ConstructionInjectionTest {\n\npublic static void main(String[] args) {\n  \n  // Usage of BeanFactory\n  \n  @SuppressWarnings("deprecation")\n  BeanFactory factory = new XmlBeanFactory(new ClassPathResource("beans.xml"));\n  \n  CIEmployee emp= (CIEmployee)factory.getBean("conemployee");\n  \n  System.out.println("Employee Id :"+emp.getEmpId());\n  System.out.println("Employee Name :"+emp.getEmpName());\n  System.out.println("Employee Salary :"+emp.getEmpSal());\n  System.out.println("Employee Department ID :" + emp.getDept().getDeptId());\n  System.out.println("Employee Department Name :" + emp.getDept().getDeptName());\n  \n  // Usage of ApplicationContext\n  \n  AbstractApplicationContext context= new ClassPathXmlApplicationContext("beans.xml");\n  CIEmployee emp1= (CIEmployee)context.getBean("conemployee");\n  \n  System.out.println("Employee1 Id :"+emp1.getEmpId());\n  System.out.println("Employee1 Name :"+emp1.getEmpName());\n  System.out.println("Employee1 Salary :"+emp1.getEmpSal());\n  System.out.println("Employee1 Department ID :" + emp1.getDept().getDeptId());\n  System.out.println("Employee1 Department Name :" + emp1.getDept().getDeptName());\n  \n  context.close();\n\n }\n\n}\n\n\n```\n\n**Output**\n\n```jsx\n\nSep 07, 2019 5:35:50 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\nINFO: Loading XML bean definitions from class path resource [beans.xml]\n\nEmployee Id :149903\n\nEmployee Name :Praveen\n\nEmployee Salary :1.0E7\n\nEmployee Department ID :100\n\nEmployee Department Name :Tech\n\nSep 07, 2019 5:35:51 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh\nINFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@234bef66: startup date [Sat Sep 07 17:35:51 IST 2019]; root of context hierarchy\n\nSep 07, 2019 5:35:51 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\nINFO: Loading XML bean definitions from class path resource [beans.xml]\n\nEmployee1 Id :149903\n\nEmployee1 Name :Praveen\n\nEmployee1 Salary :1.0E7\n\nEmployee1 Department ID :100\n\nEmployee1 Department Name :Tech\n\nSep 07, 2019 5:35:51 PM org.springframework.context.support.AbstractApplicationContext doClose\nINFO: Closing org.springframework.context.support.ClassPathXmlApplicationContext@234bef66: startup date [Sat Sep 07 17:35:51 IST 2019]; root of context hierarchy\n\n```\n\n2. **Using Annotation based configuration**\n\nWe will make use of above CIDepartment.java and CIEmployee.java and will replace the beans.xml with CIEmployeeConfig.java\n\n```jsx\n@Configuration\npublic class CIEmployeeConfig {\n\n @Bean(name="ciemployee")\n public CIEmployee ciemployee(){ \n  CIDepartment dept= new CIDepartment("Tech",1000);  \n  CIEmployee emp= new CIEmployee("Praveen",149903,10000000d,dept);  \n  return emp;\n }\n}\n\n\n```\n\n```jsx\npublic class ConstructorInjectionTest {\n\n public static void main(String[] args) {\n  \n  \n  AnnotationConfigApplicationContext context= new AnnotationConfigApplicationContext();\n  context.register(CIEmployeeConfig.class);\n  \n  context.refresh();\n  \n  CIEmployee emp1= (CIEmployee)context.getBean("ciemployee");\n  System.out.println("Employee1 Id :"+emp1.getEmpId());\n  System.out.println("Employee1 Name :"+emp1.getEmpName());\n  System.out.println("Employee1 Salary :"+emp1.getEmpSal());\n  System.out.println("Employee1 Department ID :" + emp1.getDept().getDeptId());\n  System.out.println("Employee1 Department Name :" + emp1.getDept().getDeptName());\n  \n  context.close();\n\n }\n\n}\n\n```\n\n**Output**\n\n```jsx\n\nSep 07, 2019 6:14:57 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh\nINFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2cdf8d8a: startup date [Sat Sep 07 18:14:57 IST 2019]; root of context hierarchy\n\nEmployee1 Id :149903\n\nEmployee1 Name :Praveen\n\nEmployee1 Salary :1.0E7\n\nEmployee1 Department ID :1000\n\nEmployee1 Department Name :Tech\n\nSep 07, 2019 6:14:58 PM org.springframework.context.support.AbstractApplicationContext doClose\nINFO: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2cdf8d8a: startup date [Sat Sep 07 18:14:57 IST 2019]; root of context hierarchy\n\n```\n\nNotice here that neither the setters nor the no-argument constructors were invoked by Spring.\n\nThe dependencies were injected purely by means of Constructors. This approach is preferred over Spring Setter Injection\n\nWhen constructor is used to set instance variables on an objects, it is called as Constructor Injection\n\n**When we go for Setter Injection or when we go for Constructor Injection?**\n\n- At the time of creating our target class object, the dependent objects are injected or instantiated through Constructor Injection. \n- Whereas in Setter Injection dependent objects are not injected or instantiated while creating the target class object; those will be injected after the target class has been instantiated by calling the setter on the target object.\n- If bean class contains only one property or if all the property of bean class should participate in dependency injection then we should go for constructor injection because constructor injection is very faster than setter injection. \n- If bean class contains more than one property and there is no need of making all properties (means optional to inject) are participating in dependency injection, then we should go for setter injection. So it is bit delayed injection.\n- Constructor Injection doesn\u2019t support cyclic dependency. \n- Whereas Setter injection supports cyclic or circular dependency injection.\n- To perform constructor injection on n properties in all angles, n! Constructors are required. \n- Whereas to perform setter injection on n properties in all angles \u201cn-setter\u201d methods are required.\n- To perform constructor injection we will use <constructor-arg>. \n- Whereas to perform setter injection we will use <property> tag.\n\n**Spring supports dependency injection on the following properties:**\n\n- Simple properties (primitive data types, String)\n- Reference or Object type properties\n- Collection properties (Array, List, Set, Map, Properties, and etc...)\n\n**Difference between construction and setter injection**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/spring/cisi.png)\n\n##Lookup Method Injection\n\nIn Spring application there are many beans injected to each other for a goal. There is no problem when injected beans have same scope of beans like singleton bean injected with other singleton beans. \n\nSometimes in Spring, Problems arise when you need to inject a prototype-scoped bean in a singleton-scoped bean. \n\nSince singletons are created (and then injected) during context creation it\u2019s the only time the Spring context is accessed and thus prototype-scoped beans are injected only once, thus defeating their purpose.\n\nBut Spring provides another way for injection of beans, It is called method injection. It is solution of above problem in injecting different scoped beans. It works as that since singleton beans are instantiated at context creation, but it changes the way prototype-scoped are handled, from injection to created by an abstract method. It is actually a another kind of injection used for dynamically overriding a class and its abstract methods to create instances every time the bean is injected.\n\nMethod injection is different from Constructor Injection and Setter Injection. While in Constructor and Setter Injection, Spring creates the beans and injects them using the constructor or setter method, in Method Injection Spring overrides a given abstract method of an abstract class and provides an implementation of the overridden method.\n\nNote there is an alternative to method injection would be to explicitly access the Spring context to get the bean yourself. It\u2019s a bad thing to do since it completely defeats the whole Inversion of Control pattern, but it works.\n\nThis is an advanced form of dependency injection and should be used in very special cases as it involves byte-code manipulation by Spring.\n\nLets consider an example,\n\n```jsx\n@Component\n@Scope("prototype")\npublic class Token { \n}\n```\n\n```jsx\npublic abstract class TokenMachine {\n public void findToken() {\n  System.out.println("Token has been generated " + generateToken());\n }\n public abstract Token generateToken();\n}\n```\n\n**Beans.xml**\n\n```jsx\n<beans>\n<bean id="token" class="com.praveen.core.di.lookupmethod.Token" scope="prototype" />\n\n <bean id="tokenMachine" class="com.praveen.core.di.lookupmethod.TokenMachine"\n  scope="singleton">\n  <lookup-method bean="token" name="generateToken" />\n </bean>\n</beans>\n\n\n```\n\n```jsx\npublic class XMLTestMain {\n public static void main(String[] args) {\n\n  AbstractApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");\n  TokenMachine machine = (TokenMachine) context.getBean("tokenMachine");\n  machine.findToken();\n  machine = (TokenMachine) context.getBean("tokenMachine");\n  machine.findToken();\n  context.close();  \n }\n}\n\n```\n\n**Output**\n\n```jsx\n\nSep 07, 2019 9:18:05 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh\nINFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@14514713: startup date [Sat Sep 07 21:18:05 IST 2019]; root of context hierarchy\n\nSep 07, 2019 9:18:05 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\nINFO: Loading XML bean definitions from class path resource [beans.xml]\n\nin Param\n\nToken has been generated com.praveen.core.di.lookupmethod.Token@13acb0d1\n\nToken has been generated com.praveen.core.di.lookupmethod.Token@3e3047e6\n\nSep 07, 2019 9:18:07 PM org.springframework.context.support.AbstractApplicationContext doClose\nINFO: Closing org.springframework.context.support.ClassPathXmlApplicationContext@14514713: startup date [Sat Sep 07 21:18:05 IST 2019]; root of context hierarchy\n\n```\n\nIf you go with Annotation based configuration then you just need to replace the beans.xml with AppConfig.java\n\n```jsx\n@Configuration\npublic class AppConfig {\n @Bean \n public TokenMachine tokenMachine(){\n  return new TokenMachine(){\n\n   @Override\n   public Token generateToken() {\n    return new Token();\n   }\n   \n  };\n }\n}\n\n```\n\n```jsx\npublic class AnnotationTestMain {\n public static void main(String[] args) {\n  \n  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n  TokenMachine machine = context.getBean(TokenMachine.class);\n  machine.findToken();\n  machine = context.getBean(TokenMachine.class);\n  machine.findToken();\n  context.close();\n }\n}\n```\n\n**Output**\n\n```jsx\n\nSep 07, 2019 9:20:35 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh\nINFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5cb0d902: startup date [Sat Sep 07 21:20:35 IST 2019]; root of context hierarchy\n\nToken has been generated com.praveen.core.di.lookupmethod.Token@70beb599\n\nToken has been generated com.praveen.core.di.lookupmethod.Token@4e41089d\n\nSep 07, 2019 9:20:37 PM org.springframework.context.support.AbstractApplicationContext doClose\nINFO: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5cb0d902: startup date [Sat Sep 07 21:20:35 IST 2019]; root of context hierarchy\n\n```\n\n '}}]);