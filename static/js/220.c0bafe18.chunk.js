(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[220],{789:function(e,n,t){"use strict";t.r(n),n.default=' An Interceptor runs between requests whereas a Filter runs before rendering view.\n\nFilter is related to the Servlet API and HandlerIntercepter is a Spring specific concept.\n\nA Servlet Filter is used in the web layer only, you can\u2019t use it outside of a web context. Interceptors can be used anywhere. which is the main difference\n\nFor authentication of web pages you would use a servlet filter.\n\nFor security stuff in your business layer or logging you would use an Interceptor.\n\n**Filter**\n\nA filter as the name suggests is a Java class executed by the servlet container for each incoming HTTP request and for each http response. This way, is possible to manage HTTP incoming requests before them reach the resource, such as a JSP page, a servlet or a simple static page; in the same way is possible to manage HTTP outbound response after resource execution.\n\n**Interceptor**\n\nSpring Interceptors are similar to Servlet Filters but they acts in Spring Context so are many powerful to manage HTTP Request and Response but they can implement more sophisticated behavior because can access to all Spring context.\n\n**Methods in HandlerInterceptorAdapter**\n\n- prehandle method: do something before hitting the controller\n- posthandle method: do something after returning from controller\n- after completion method: do something after response is sent out and the view is rendered.\n\nResponseEntity is meant to represent the entire HTTP response. You can control anything that goes into it: status code, headers, and body.\n\nLets see an Example\n\n```jsx\n\n@Component\npublic class RequestHeaderInterceptor extends HandlerInterceptorAdapter {\n\n @Override\n public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n   throws Exception {\n\n  if (StringUtils.isBlank(request.getHeader("user-auth-key"))) {\n   throw new InvalidHeaderFieldException("Invalid request");\n  }\n\n  return super.preHandle(request, response, handler);\n }\n\n@Override\n public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n   @Nullable ModelAndView modelAndView) throws Exception {\n\n  System.out.println("In RequestHeaderInterceptor  :: SPRING Called postHandle method for URI "+request.getRequestURI() );\n }\n\n\n @Override\n public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n   @Nullable Exception ex) throws Exception {\n\n  System.out.println("In RequestHeaderInterceptor  :: SPRING Called afterCompletion method for URI "+request.getRequestURI() );\n\n }\n\n}\n\n```\n\n```jsx\n@Configuration\npublic class UserConfig implements WebMvcConfigurer {\n\n @Autowired\n private RequestHeaderInterceptor requestHeaderInterceptor;\n\n @Override\n public void addInterceptors(InterceptorRegistry registry) {\n  // TODO Auto-generated method stub\n  registry.addInterceptor(requestHeaderInterceptor);\n }\n\n}\n\n```\n\n```jsx\npublic class InvalidFieldException extends RuntimeException {\n private static final long serialVersionUID = 1L;\n private String message;\n public InvalidFieldException(String message) {\n  this.setMessage(message);\n }\n public String getMessage() {\n  return message;\n }\n public void setMessage(String message) {\n  this.message = message;\n }\n\n}\n```\n\n```jsx\npublic class InvalidHeaderFieldException extends RuntimeException {\n\n private static final long serialVersionUID = 1L;\n\n private String message;\n\n public InvalidHeaderFieldException(String message) {\n  this.setMessage(message);\n }\n\n public String getMessage() {\n  return message;\n }\n\n public void setMessage(String message) {\n  this.message = message;\n }\n}\n```\n '}}]);