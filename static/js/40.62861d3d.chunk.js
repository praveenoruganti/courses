(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[40],{609:function(t,e,n){"use strict";n.r(e),e.default=' It is a type of Structural Design Pattern.\n\nThe Proxy Pattern provides a surrogate or placeholder for another object to control access to it.\n\nThe Proxy Pattern is used to create a representative object that controls access to another object, which may be remote, expensive to create or in need of being secured.\n\nOne reason for controlling access to an object is to defer the full cost of its creation and initialization until we actually need to use it. Another reason could be to act as a local representative for an object that lives in a different JVM. The Proxy can be very useful in controlling the access to the original object, especially when objects should have different access rights.\n\nIn the Proxy Pattern, a client does not directly talk to the original object, it delegates it calls to the proxy object which calls the methods of the original object. The important point is that the client does not know about the proxy, the proxy acts as an original object for the client. But there are many variations to this approach which we will see soon.\n\nThere are three main variations to the Proxy Pattern:\n\n- A remote proxy provides a local representative for an object in a different address space.\n- A virtual proxy creates expensive objects on demand.\n- A protection proxy controls access to the original object. Protection proxies are useful when objects should have different access rights.\n\n```jsx\npackage com.praveen.designpatterns.structural.proxy;\n\npublic interface Internet {\n\tvoid connectTo(String host) throws Exception;\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.structural.proxy;\n\npublic class RealInternet implements Internet {\n\n\t@Override\n\tpublic void connectTo(String host) throws Exception {\n\t\tSystem.out.println("Connecting to "+host);\t\t\n\t}\n\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.structural.proxy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class InternetProxy implements Internet {\n\n\tprivate Internet internet = new RealInternet();\n\tprivate static List<String> restrictedSites;\n\n\tstatic {\n\t\trestrictedSites = new ArrayList<>();\n\t\trestrictedSites.add("gmail.com");\n\t}\n\n\t@Override\n\tpublic void connectTo(String host) throws Exception {\n\t\tif (restrictedSites.contains(host.toLowerCase())) {\n\t\t\tthrow new Exception("Company restricted " +host+" site view");\n\t\t} else {\n\t\t\tinternet.connectTo(host);\n\t\t}\n\t}\n\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.structural.proxy;\n\npublic class ProxyPatternTest {\n\n\tpublic static void main(String[] args) {\n\t\tInternet intConn = new InternetProxy();\n\t\ttry {\n\t\t\tintConn.connectTo("praveen-oruganti.firebaseapp.com");\n\t\t\tintConn.connectTo("gmail.com");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.getMessage());\n\t\t}\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\nConnecting to praveen-oruganti.firebaseapp.com\nCompany restricted gmail.com site view\n```\n\n### When to use the Proxy Pattern\n\nProxy is applicable whenever there is a need for a more versatile or sophisticated reference to an object than a simple pointer. Here are several common situations in which\nthe Proxy pattern is applicable:\n- A remote proxy provides a local representative for an object in a different address space.\n- A virtual proxy creates expensive objects on demand.\n- A protection proxy controls access to the original object. Protection proxies are useful when objects should have different access rights.\n\n### Proxy pattern examples in JDK\n\n- java.lang.reflect.Proxy\n- java.rmi.* (whole package) '}}]);