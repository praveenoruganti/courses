(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[98],{667:function(e,n,t){"use strict";t.r(n),n.default=' ![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/ExceptionHierarchy.png)\n\n**Exception**\n\nAn exception is an event, which occurs during the execution of a program, that disrupts the normal flow of the program\u2019s instructions.\n\n**Errors**\n\nMost of the times errors are not caused by our programs these are due to lack of system resources. Errors are not recoverable (not handle).\n\nFor example, if OutOfMemory error occurs during the execution of a program we can\u2019t do anything and the program will be terminated abnormally.\n\n**Java Exception Handling Keywords**\n\nThere are 5 keywords which are used for exception handling in Java\n\n- try\n\nIn java try block we can write the code that might throw an exception. A try block in Java must be followed by either at least one catch block or one finally block.\n\n- catch\n\ncatch block in Java is used to handle the exception that may occur in our program. It must be used after try block only. We can use more than one catch block with a single try block.\n\n- finally\n\n  1. finally block in Java can be used to clean up code or release some resources that are utilized in the program.\n  2. The Specialty of finally Block is it will be executed Always irrespective of whether Exception raised OR Not raised and whether Exception Handled OR Not Handled.\n\n- throw\n\n  1. throw keyword in java can be used to throw an exception. It can throw the exceptions explicitly.\n  2. We can throw either checked or unchecked exception using throw keyword.\n  3. After throw Statement we are Not allowed to write any Statements Directly Otherwise we will get Compile Time Error Saying unreachable statement.\n  4. In General we can Use throw Key Word for Customized Exceptions but Not for pre-defined Exceptions.\n  5. We can Use throw Key Word Only for Throwable Types. Otherwise we will get Compile Time Error Saying incompatible types.\n\n**Syntax**\n\nthrow exception;\n\n- throws\n\n  1. throws keyword in java is used for declaring an exception. We can declare only checked exception using throws keyword. So its programmer responsibility to provide the exception handling code so that the normal flow of the program can be maintained.\n  2. Usage of throws Key Word for Unchecked Exceptions there is No Use.\n  3. throws Key Word required Only to Convince Compiler and it doesn\u2019t Prevent Abnormal Termination of the Program.\n  4. Hence Recommended to Use try- catch- finally Over throws Key Word.\n\n**Syntax**\n\nreturn_type method_name() throws exception_class_name.\n\n**Points to remember**\n\n- Within the try Block if any where an Exception raised then Rest of the try Block won\'t be executed even though we handled that Exception.\n- Hence within the try Block we have to Take Only Risky Code and Hence Length of the try Block should be as Less as Possible.\n- If there is any Statement which raises an Exception and it is Not Part of the try Block then it is Always Abnormal Termination.\n- In Addition to try Block there May be a Chance of raising an Exception Inside catch and finally Blocks Also.\n- We can Take try \u2013 catch \u2013 finally Inside try Block i.e. Nesting of try \u2013 catch \u2013 finally is Always Possible.\n- More Specific Exceptions can be handled by Inner catch Block and Generalized Exceptions are handled by Outer catch Blocks.\n- Once we entered into the try Block without executing finally Block the Control Never Comes Up.\n- If we are Not entering into the try Block then finally Block won\u2019t be executed.\n- Default Exception Handler can Handle Only One Exception at a Time i.e. the Most Recently raised Exception.\n\n**Various Possible Combinations of try-catch-finally**\n\n- In try-catch-finally Order is Important.\n- Inside try-catch-finally we can take try-catch-finally that is nesting of try-catch-finally is always possible.\n- Whenever we are taking try Compulsory we have to Take either catch OR finally Blocks i.e. try without catch OR finally is Invalid.\n- Whenever we are writing catch Block Compulsory we have to write try Block i.e. catch without try is Invalid.\n- Whenever we are writing finally Block Compulsory we should write try i.e. finally without try is Invalid.\n- For try-catch-finally Blocks Curly Braces are Mandatory.\n- We can\u2019t write 2 catch Blocks for the Same Exception Otherwise we will get CE.\n\n**Throwable Class defines the following Methods to Print Exception Information**\n\nprintStackTrace(): Name of the Exception: Description and Stack Trace\ntoString() : Name of the Exception: Description\ngetMessage() : Description\n\n**Types of Exception in Java**\n\nThere are two types of Exception in Java:\n\n1. **Checked Exception**\n\nA checked exception is a type of exception that must be either caught or declared in the method in which it is thrown. For example, the java.io.IOException is a checked exception.\n\nLet\'s see some sample code\n\nIn this example, we are reading the file abc.txt and displaying its content on the screen. Here we are usingFileInputStream for reading the data from a file, throws FileNotFoundException. The read() method which is used for reading the data from the input stream and close() method which is used for closes the file input stream throws an IOException.\n\n```jsx\npublic class ExceptionExample {\n\n\tpublic static void main(String args[]) {\n\t\tFileInputStream fis = null;\n\t\tfis = new FileInputStream("D:/abc.txt");\n\t\tint i;\n\t\twhile ((i = fis.read()) != -1) {\n\t\t\tSystem.out.println((char) i);\n\t\t}\n\t\tfis.close();\n\t}\n\n}\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/exception1.png)\n\nThere are two ways to handle this compilation error\n\n- Using try-catch.\n- Using throws keyword.\n\n- Handle Checked Exception using a try-catch block.\n\nIt is a good practice to handle the exception using try-catch block Because you should give a meaningful message for each exception type so that it would be easy for someone to understand the error.\n\n```jsx\npublic class CheckedExceptionExample{\n public static void main(String args[]) {\n  FileInputStream fis = null;\n  try {\n   fis = new FileInputStream("D:/abc.txt");\n  } catch (FileNotFoundException e) {\n   e.printStackTrace();\n  }\n  int i;\n  try {\n   while ((i = fis.read()) != -1) {\n    System.out.println((char) i);\n   }\n  } catch (IOException e) {\n   e.printStackTrace();\n  }\n  try {\n   fis.close();\n  } catch (IOException e) {\n   e.printStackTrace();\n  }\n }\n\n}\n\n```\n\n- Handle Checked Exception using throws keyword\n\nAs we know that checked exception occurs inside the main() method. So you can declare the exception in the main() method using throws keyword. You can declare the exception like this:\n\n```jsx\nclass CheckedExceptionExample{\n public static void main(String args[]) throws IOException {\n  FileInputStream fis = null;\n  fis = new FileInputStream("D:/abc.txt");\n  int i;\n  while ((i = fis.read()) != -1) {\n   System.out.println((char) i);\n  }\n  fis.close();\n }\n\n}\n\n```\n\nIOException is the parent class of FileNotFoundException so that it by default handle the FileNotFoundException\n\n2. **Unchecked Exceptions**\n\nAll the classes which inherit RuntimeException are known as Unchecked Exception. The Unchecked exceptions are not checked by the compiler at compile-time. But they are checked at runtime.\n\nIn case of Unchecked exception if programmers will not handle the exception then we won\u2019t get a compile-time error.\n\nMost of the time these exceptions occur due to the wrong data entered by the user ( divide by zero). In such type of exceptions, the compiler will never force you to handle the exceptions. For example, ArithmeticException, NullPointerException, ArrayIndexOutOfBounds etc.\n\nLet\'s see some sample code\n\nIn this example, we are dividing two numbers which are entered by the user. If the user enters right data then our program will display division of two numbers. If the user enters wrong data then our program will display ArithmeticException.These exceptions will not occur at compile-time, it can occur at runtime.\n\n```jsx\npublic class UnCheckedExceptionExample {\n\n public static void main(String args[]) {\n  Scanner sc = new Scanner(System.in);\n  System.out.println("Enter the first number:");\n  int a = sc.nextInt();\n  System.out.println("Enter the second number:");\n  int b = sc.nextInt();\n  int c = a / b;\n  System.out.println("Division of two number is: " + c);\n  System.out.println("Program continues!");\n  sc.close();\n }\n\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/exception2.png)\n\nLet\u2019s see another example for unchecked exception\n\nIn this example we are taking an example of an array. Here my array has only 5 elements but we are trying to display the value of the 10th element.\n\nIt should throw an exception ArrayIndexOutOfBoundsException.\n\n```jsx\n\npublic class UnCheckedExceptionExample {\n\n\tpublic static void main(String args[]) {\n\t\tint arr[] = { 1, 2, 3, 4, 5 };\n\t\tSystem.out.println("The value of 10th element is:" + arr[10]);\n\n\t}\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/exception3.png)\n\nException handling using try and catch block\n\n```jsx\npublic class UnCheckedExceptionExample {\n\n public static void main(String args[]) {\n  Scanner sc = new Scanner(System.in);\n  System.out.println("Enter the first number:");\n  int a = sc.nextInt();\n  System.out.println("Enter the second number:");\n  int b = sc.nextInt();\n  try {\n   int c = a / b;\n   System.out.println("Division of two number is: " + c);\n  }catch(ArithmeticException e) {\n   System.out.println("Exception: " +e.getMessage());\n  }\n  System.out.println("Program continues!");\n  sc.close();\n }\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/exception4.png)\n\nInternally Default Exception Handler Uses printStackTrace() to Print Exception Information to the Console.\n\n**Multiple catch blocks**\n\nIf we want to perform a different task at the occurrence of different exception then we should go for multiple catch block.\n\nLet\u2019s see an example of multiple catch block in Java.\n\n```jsx\npublic class UnCheckedExceptionExample {\n\n public static void main(String args[]) {\n  try {\n   int arr[] = new int[5];\n   arr[3] = 12 / 0;\n   System.out.println("We are in try block");\n  } catch (ArithmeticException e) {\n   System.out.println("Divide by zero exception");\n  } catch (ArrayIndexOutOfBoundsException e) {\n   System.out.println("array elements outside limit");\n  } catch (Exception e) {\n   System.out.println("Other type of exception");\n  }\n  System.out.println("We are outside the try catch block");\n }\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/exception5.png)\n\n**Points to remember**\n\n- If try with Multiple catch Blocks Present then the Order of catch Blocks are Very Important. It should be from Child to Parent.\n- By Mistake if we are trying to Take Parent to Child then we will get Compile Time Error Saying: exception XXX has already been caught.\n- For any Exception if we are writing 2 Same catch Blocks we will get Compile Time Error like exception already caught.\n\n**Explicitly throw an Exception in Java**\n\nthrow keyword in Java can be used to throw an exception. It can throw the exceptions explicitly. We can throw either checked or unchecked exception using throw keyword. Let\u2019s understand with a simple example.\n\nIn this example, we have created two variable balance and withdrawlAmount. If the balance is less than withdrawalAmount then ArithmeticException has occurred. Therefore we throw an object of ArithmeticException and it will display a message on the screen "insufficient balance".\n\n```jsx\npublic class ThrowExceptionExample {\n\n public static void main(String args[]) {\n  int balance = 5000;\n  int withdrawlAmount = 6000;\n  try {\n   if (balance < withdrawlAmount)\n    // created an object of ArithmeticException class\n    throw new ArithmeticException("Insufficient balance");\n   balance = balance - withdrawlAmount;\n   System.out.println(" Transactions successfully completed");\n  } catch (ArithmeticException e) {\n   System.out.println("Exception is: " + e.getMessage());\n  }\n  System.out.println("Programs continues!");\n }\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/exception6.png)\n\n**Checked Exception vs Unchecked Exception**\n\nAll the classes which inherit throwable class except RuntimeException and Error are known as Checked Exception while all the classes which inherit RuntimeException are known as Unchecked Exception.\n\nThe checked exceptions are checked by the compiler at compile-time while the Unchecked exceptions are not checked by the compiler at compile-time. But they are checked at runtime.\n\nIn case of checked exception if programmers will not handle the exception then we will get a compile-time error while in case of Unchecked exception if programmers will not handle the exception then we won\u2019t get a compile-time error.\n\nFileNotFoundException, ClassNotFoundException, IOException, SQLException etc. are the example of checked exception while ArithmeticException, NullPointerException,\n\nArrayIndexOutOfBounds etc. are the example of Unchecked exception.\n\nBy default, checked exceptions are not forwarded in calling chain where as unchecked exceptions are forwarded in calling chain.\n\n**Throw vs Throws**\n\nthrow keyword in Java can be used to throw an exception. It can throw the exception explicitly while throws keyword in java is used for declaring an exception.\n\nA throw is used inside the method while throws are used with the body signature.\n\nfor example,\n\n```jsx\n      public void m1() {\n          throw new ArithmeticException\n      }\n\n      public void m1() throws IOException, FileNotFoundException{\n\n      }\n\n```\n\nA throw is used to throw only one exception while we can declare multiple exceptions using throws.\n\nA throw is used in either checked exception or unchecked exception while throws only are used in a checked exception.\n\n**final vs finally vs finalize in Java**\n\n**final**\n\n- final is a Modifier is Applicable for Classes, Methods and Variables.\n- If a Class declared as final then we can\'t Create Child Class. That is Inheritance is Not Possible for final Classes.\n- If a Method declared as final then we can\'t Override that Method in Child Classes.\n- If a Variable declared as final then we can\'t Perform Re- Assignment for that Variable.\n\n**finally**\n\n- finally is a Block Always associated with try-catch to Maintain Clean Up Code.\n- The Specialty of finally Block is it will be executed Always Irrespective of whether Exception raised OR Not and whether Handled OR Not Handled.\n\n**finalize()**\n\n- finalize() is a Method Always Called by the Garbage Collector Just before Destroying an Object to Perform Clean Up Activities.\n- Once finalize() Completes Automatically Garbage Collector Destroys that Object.\n\n**Points to remember**\n\n- finalize is Responsible to Perform Object Level Clean-Up Activities whereas finally Block is Responsible to Perform try Block Level Clean-Up Activities i.e. whatever Resources we Opened at the Time of try Block will be Closed Inside finally Block\n- It is Highly Recommended to Use finally Block than finalize()because we can\'t Expect Exact Behavior of Garbage Collector. It is JVM Vendor Dependent.\n\n**finally vs return**\n\nIf return Statement Present Inside try OR catch Blocks 1st finally will be executed and after that Only return Statement will be Considered i.e. finally Block Dominates return Statement.\n\nIf try-catch-finally Blocks having return Statements then finally Block return Statement will be Considered i.e. finally Block return Statement has More Priority than try and catch Block return Statements.\n\n```jsx\npackage com.praveen.exception;\n\npublic class FinallyReturnExample {\n\n public static void main(String[] args) {\n  System.out.println(m1());\n }\n\n public static int m1() {\n  try {\n   return 777;\n  } catch (Exception e) {\n   return 888;\n  } finally {\n   return 999;\n  }\n }\n\n}\n\n```\n\n**Output**\n\n999\n\n**finally vs System.exit(0)**\n\n**finally**\n\nThere is Only One Situation where the finally Block won\'t be executed that is whenever we are System.exit(0).\n\nWhenever we are using System.exit(0) then JVM itself will be Shutdown and hence finally Block won\'t be executed. That is System.exit(0) Dominates finally Block.\n\n```jsx\n\npublic class FinallySystemExitExample {\n public static void main(String[] args) {\n  try {\n   System.out.println("try");\n   System.exit(0);\n  } catch (Exception e) {\n   System.out.println("catch");\n  } finally {\n   System.out.println("finally");\n  }\n }\n\n}\n\n\n```\n\n**Output**\n\ntry\n\n**System.exit(0)**\n\n- We can Use this Method to Exit (Shut Down) the System (JVM) Programmatically.\n- The Argument Represents as Status Code.\n- Instead of 0 we can Pass any Valid int Value.\n- 0 Means Normal Termination, Non- Zero Means Abnormal Termination.\n- So this status code internally used by JVM.\n- Whether it is 0 OR Non- Zero Effect is Same in Our Program but this Number Internally used by JVM.\n\n**Example on Custom Exception**\n\n**InsufficientFundsException.java**\n\n```jsx\npublic class InsufficientFundsException extends Exception {\n private static final long serialVersionUID = -5077686490745588740L;\n public InsufficientFundsException(String exception_Description) {\n  super(exception_Description);\n }\n}\n\n```\n\n**Account.java**\n\n```jsx\n\npublic class Account {\n String accNo;\n String accName;\n String accType;\n int balance;\n\n public Account(String acc_No, String acc_Name, String acc_Type, int acc_Balance) {\n  accNo = acc_No;\n  accName = acc_Name;\n  accType = acc_Type;\n  balance = acc_Balance;\n }\n\n public String getAccNo() {\n  return accNo;\n }\n\n public String getAccName() {\n  return accName;\n }\n\n public String getAccType() {\n  return accType;\n }\n\n public int getBalance() {\n  return balance;\n }\n}\n\n\n```\n\n**Transaction.java**\n\n```jsx\n\npublic class Transaction {\n public void withdraw(Account acc, int wd_Amt) {\n  try {\n   System.out.println("Transaction Details");\n   System.out.println("\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014");\n   System.out.println("Transaction Id :T-111");\n   System.out.println("Account Number :" + acc.accNo);\n   System.out.println("Account Name :" + acc.accName);\n   System.out.println("Account Type :" + acc.accType);\n   System.out.println("Initial Balance :" + acc.balance);\n   System.out.println("Transaction Type :WITHDRAW");\n   System.out.println("Withdraw Amount :" + wd_Amt);\n   if (acc.balance >= wd_Amt) {\n    acc.balance = acc.balance - wd_Amt;\n    System.out.println("Total Balance :" + acc.balance);\n    System.out.println("Transaction Status :SUCCESS");\n   } else {\n    System.out.println("Total Balance :" + acc.balance);\n    System.out.println("Transaction Status :FAILURE");\n    throw new InsufficientFundsException(\n      "Reason: Funds are not Sufficient in your Accout, please enter valid withdraw Amount");\n   }\n  } catch (InsufficientFundsException e) {\n   System.out.println(e.getMessage());\n  } finally {\n   System.out.println("*********Thanks Vist Again************");\n\n  }\n\n }\n}\n\n```\n\n**Test.java**\n\n```jsx\n\npublic class Test {\n public static void main(String[] args) {\n  Account acc1 = new Account("abc123", "Praveen", "Savings", 20000);\n  Transaction tx1 = new Transaction();\n  tx1.withdraw(acc1, 15000);\n  System.out.println("Transaction for account number "+ acc1.getAccNo() +" is complete \n");\n  Account acc2 = new Account("xyz123", "Prasad", "Savings", 10000);\n  Transaction tx2 = new Transaction();\n  tx2.withdraw(acc2, 15000);\n  System.out.println("Transaction for account number "+ acc2.getAccNo() +" is complete");\n }\n}\n\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/exception7.png)\n\n**Summary of Exception Handling Key Words**\n\n1. try -> To Maintain Risky Code\n2. catch -> To Maintain Handling Code\n3. finally -> To Maintain Clean Up Code\n4. throw -> To Hand-Over Our Created Exception Object to the JVM Manually\n5. throws -> To Delegate Responsibility of Exception Handling to the Caller Method\n\n**1.7 Version Enhancements**\n\nIn 1.7 Version as the Part of Exception Handling the following 2 Concepts Introduced.\n\n- try with Resources\n- Multi catch Block\n\n**try with Resources**\n\nUntil 1.6 Version it is Highly Recommended to write finally Block to Close All Resources which are Opened as the Part of try Block.\n\n- The Main Advantage of try with Resources is the Resources which are Opened as the Part of try Block will be Closed Automatically and we are Not required to Close Explicitly. It Reduces Complexity of the Programming.\n- It is Not required to write finally Block Explicitly and Hence Length of the Code will be Reduced and Readability will be Improved.\n\n**Points to remember**\n\nWe can Declare Multiple Reasons and All these Resources should be Separated with \u2018;\u2019.\n\n```jsx\nSyntax: try (R1; R2; R3) {\n------------------\n}\nEg: try ( FileWriter fw = new FileWriter("Output.txt");\nFileWriter fw = new FileWriter("Input.txt"); ) {\n--------------\n}\n```\n\n- All Resources should be AutoClosable Resources.\n- A Resource is Said to be AutoClosable\n- Corresponding Class Implements java.lang.AutoClosable Interface either Directly OR In- Directly.\n- This Interface introduced in 1.7 Version and it contains Only One Method public void close();\n- All Network OR Database Related OR File IO Related Resources Implements AutoClosable Interface. Being a Programmer we are Not required to do anything.\n- All Resource Reference Variables are Implicitly final. Hence within the try Block we can\u2019t Perform Re- Assignment.\n- Until 1.6 Version try should be followed by either catch OR finally but from 1.7 onwards we can Take Only try with Resources without - catch and finally Blocks.\n- The Main Advantage of try with Resources is finally Block will become Dummy because we are required to Close the Resources Explicitly.\n\n**Multi Catch Block (Catch Block with Multiple Exceptions)**\n\nUntil 1.6 Version even though Multiple Exceptions having Same Handling Code Compulsory we have to write a Separate catch Block for Every Exception.\n\n```jsx\ntry {\n-------\n}\ncatch (ArithmeticException e) {\ne.printStackTrace();\n}\ncatch (NullPointerException e) {\ne.printStackTrace();\n}\ncatch (ClassCastException e) {\nSystem.out.println(e.getMessage());\n}\ncatch (IOException e) {\nSystem.out.println(e.getMessage());\n}\n\n```\n\n- The Problem in this Approach is it Increases Length of the Code and Reduces Readability.\n- To Overcome this Problem SUN People Introduced Multi Catch Block in 1.7 Version.\n- In this Approach we can write a Single Catch Block which can Handle Multiple Exceptions of different Types.\n\n```jsx\ntry {\n-------\n}\ncatch (ArithmeticException | NullPointerException e) {\ne.printStackTrace();\n}\ncatch (ClassCastException | IOException e) {\nSystem.out.println(e.getMessage());\n}\n\npackage com.praveen.exception;\n\npublic class MultiCatchBlockExample {\n public static void main(String[] args) {\n  try {\n   // System.out.println(10/ 0);\n   String s = null;\n   System.out.println(s.length());\n  } catch (ArithmeticException | NullPointerException e) {\n   System.out.println(e); // java.lang.NullPointerException\n  }\n }\n}\n\n```\n\n**Output**\n\njava.lang.NullPointerException\n\nIf Mutli Catch Block there should Not be any Relation between Exception Types (Like Parent to Child OR Child to Parent OR Same Type) Otherwise we will get Compile Time Error.\n\n```jsx\ncatch (ArithmeticException | NullPointerException | ClassCastException e) {}\ncatch (ArithmeticException | Exception e) {}\n```\n\nCE:\n\nAlternatives in a multi-catch statement cannot be related by subclassing\n\nAlternative ArithmeticException is a subclass of alternative Exception\n\n**Exception Propagation**\n\n- Within a Method if an Exception raised and if we are Not Handle that Exception then that Exception Object will be propagated to Automatically to the Caller Method.\n- Then Caller Method is Responsible to Handle that Exception.\n- This Process is Called Exception Propagation.\n\n**Re-Throwing Exception**\n\nWe can Use this Approach to Convert One Exception Type to Another Exception Type.\n\n```jsx\ntry {\nSystem.out.println(10/ 0);\n}\ncatch (ArithmeticException e) {\nthrow new NullPointerException();\n}\n\n```\n\nLets see some examples\n\n```jsx\npublic class ExceptionExample {\n public static void main(String args[]) throws Exception {\n  Sample s= new Sample();\n  s.printFileContent();\n }\n}\n\nclass Sample{\n public void printFileContent() throws IOException {\n  throw new IOException();\n }\n}\n\n```\n\n```jsx\npublic class ExceptionExample {\n public static void main(String args[]) throws Exception {\n  ExceptionExample ee= new ExceptionExample();\n  int cno=1234;\n  ee.checkCard(cno);\n  ee.readCard(cno);\n }\n void readCard(int cno) throws Exception{\n  System.out.println("Rearding Card");\n }\n void checkCard(int cno) throws RuntimeException{\n  System.out.println("Checking Card");\n }\n}\n\n```\n\n\n '}}]);