(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[119],{688:function(e,n,a){"use strict";a.r(n),n.default=' \n- Lambda Expression is just an anonymous (nameless) function. That means the function which doesn\u2019t have the name, return type and access modifiers.\n- Lambda Expression also known as anonymous functions or closures.\n\nSyntax:\n\nParameter Expression Body\n\n() -> System.out.println("Praveen");\n\nLambda expression can be written only for method present in Functional Interface.\n\nIf Lambda expression has multiple lines then curly brace and return statement is mandatory.\n\nIf the type of the parameter can be decided by compiler automatically based on the context then we can remove types also.\n\n**What kind of variable you can access in an lambda expression?**\n\nUsing lambda expression, you can refer to final variable or effectively final variable (which is assigned only once). Lambda expression throws a compilation error, if a variable is assigned a value the second time.\n\nfor example,\n\n```jsx\n\nCalculator cal= (int num1,int num2) -> {\n System.out.println("sum of numbers");\nreturn num1+num2;\n};\n\n```\n\n**Advantages of Lambda Expression**\n\n- We can reduce length of the code so that readability of the code will be improved.\n- We can resolve complexity of anonymous inner classes.\n- We can provide Lambda expression in the place of object.\n- We can pass lambda expression as argument to methods.\n\nLet\'s see some examples\n\n```jsx\ninterface Calculator {\n    int add(int num1, int num2);\n}\n\npublic class CalculatorImpl implements Calculator {\n\n@Override\npublic int add(int num1, int num2) {\n    return num1 + num2;\n}\n\npublic static void main(String[] args) {\n    /* Without Lambdas */\n    CalculatorImpl ci = new CalculatorImpl();\n    System.out.println(ci.add(5, 6));\n\n    /* With Lambdas */\n    Calculator ci1= (int num1,int num2) -> (num1+num2);\n    System.out.println(ci1.add(5, 6));\n}\n}\n\n```\n\n```jsx\n\n\n@AllArgsConstructor\n@Data\n@SuperBuilder\n@ToString\nclass Employee {\n    private final int empId;\n    private final String empName;\n    private final int empAge;\n    private final double empSal;\n}\n\npublic class Java8LambdaExamples {\n\npublic static void main(String args[]) {\n\nEmployee emp1 = new Employee(1, "Praveen", 34, 1000000);\nEmployee emp2 = new Employee(2, "Rahul", 29, 500000);\nEmployee emp3 = new Employee(3, "Prasad", 35, 900000);\n\nArrayList<Employee> empList = new ArrayList<Employee>();\nempList.add(emp1);\nempList.add(emp2);\nempList.add(emp3);\n\n/* Without Lambdas */\nCollections.sort(empList, new Comparator<Employee>() {\n@Override\npublic int compare(Employee e1, Employee e2) {\nreturn (int) (e1.empSal \u2013 e2.empSal);\n}\n});\nSystem.out.println(empList);\n\n/* With Lambdas */\nCollections.sort(empList, (Employee e1, Employee e2) -> Double.compare(e1.empSal, e2.empSal));\nSystem.out.println(empList);\n}\n\n}\n\n```\n\n**Conclusions**\n\n- A lambda expression can have zero or more number of parameters (arguments).\n- Usually we can specify type of parameter. If the compiler expects the type based on the context then we can remove type. i.e., programmer is not required.\n- If multiple parameters present then these parameters should be separated with comma (,).\n- If zero number of parameters available then we have to use empty parameter [ like ()].\n- If only one parameter is available and if the compiler can expect the type then we can remove the type and parenthesis also.\n- Similar to method body lambda expression body also can contain multiple statements. If more than one statements present then we have to enclose inside within curly braces. \n  If one statement present then curly braces are optional.\n- Once we write lambda expression we can call that expression just like a method, for this functional interfaces are required.\n\n '}}]);