(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[101],{670:function(e,n,t){"use strict";t.r(n),n.default=' **Process** -> Execution of a program\n\n**Thread** -> Single execution sequence with in a process\n\nEach thread will have its own stack memory but single heap per process shared by all threads.\n\nJava multithreading is a process of executing more than one thread simultaneously is known as multithreading in java.\n\nThe main purpose of multithreading is to achieve the concurrent execution.\n\n**Advantage of Multithreading in Java**\n\n- Save Time\n\n  By using multi-threading in java you can perform multiple operation at the same time so it saves time.\n\n- Doesn\u2019t Block Users\n\n  Java multithreading doesn\u2019t block the user because thread are independent, if exception occurs in one thread it does not affect other thread so you can perform multiple operation at the same time.\n\n**Thread**\n\nThread in java is a light weight process and thread is a small part of a process or program.\n\nIt is used to achieve multitasking.\n\nThreads have separate path of execution and threads are independent if exception occurs in one thread, it does not affect other threads.Thread share common memory area.\n\n**How many ways to create a thread**\n\n- Extend the java.lang.Thread class\n\n```jsx\npublic class SimpleThread extends Thread {\n    public void run() {\n        System.out.println("Starting  " + currentThread().getName());\n    }\n    public static void main(String args[]) {\n        Thread t1 = new SimpleThread();\n        t1.setName("t1");\n        Thread t2 = new SimpleThread();\n        t2.setName("t2");\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n**Output**\n\nStarting t1\n\nStarting t2\n\n- Implementing the java.lang.Runnable interface\n\n```jsx\npublic class RunnableThread implements Runnable {\n    public void run() {\n        System.out.println("Starting  " + Thread.currentThread().getName());\n    }\n    public static void main(String args[]) {\n        RunnableThread rt1 = new RunnableThread();\n        Thread t1=new Thread(rt1); t1.setName("t1");\n        RunnableThread rt2 = new RunnableThread();\n        Thread t2=new Thread(rt2); t2.setName("t2");\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/threadoutput1.png)\n\n- Implement the java.util.concurrent.callable interface\n\nThe executor framework which uses Runnable objects, unfortunately a runnable cannot return a result to the caller.\n\nIn case you expect your threads to return a computeable result you can use java.util.concurrent.callable interface.\n\n```jsx\npublic class ThreadSampleCallable implements Callable<String> {\n    private int command;\n    @Override\n    public String call() throws Exception {\n        return "Starting " + command + " " + Thread.currentThread().getName();\n    }\n    public ThreadSampleCallable(int command) {\n        this.command = command;\n    }\n    public static void main(String args[]) throws InterruptedException {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        List<Future<String>> list = new ArrayList<Future<String>>();\n        for (int i = 0; i < 10; i++) {\n            Future<String> future = executor.submit(new ThreadSampleCallable(i));\n            list.add(future);\n        }\n        // now retrieving the result\n        for (Future<String> future : list) {\n            try {\n                System.out.println(future.get());\n            } catch (InterruptedException ie) {\n                System.out.println(ie);\n            } catch (ExecutionException ee) {\n                System.out.println(ee);\n            }\n        }\n        // This will make the executor accept no new threads and finish all existing\n        // threads in queue executor.shutdown();\n        // wait until all threads are finish\n        executor.awaitTermination(10, TimeUnit.SECONDS);\n        System.out.println("Finished all threads");\n    }\n}\n\n```\n\n**Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/threadoutput.png)\n\n**ThreadPool Concept**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/threadpool.PNG)\n\nJava threadpool represents a group of worker thread that are waiting for the job(performed the task) and reuse many times.\n\nA group of fixed size threads are created.\n\nAssigned the job of worker thread by the service provider amd complete the job( finish the work) threads contained in the ThreadPool again.\n\n**Advantages**\n\n- Better performance\n- save times\n- there is no need to create new thread.\n\n\n '}}]);