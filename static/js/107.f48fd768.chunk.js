(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[107],{676:function(e,t,n){"use strict";n.r(t),t.default=' Traditional way of manually creating threads have below limitiations due to which Executor Framework is introduced in Java 1.5.\n\n- Time Consuming\n- Poor Resource Management\n- Not Robust\n\n\nExecutor Framework will helps you to perform asynchronous non blocking execution of thread even it support features of thread pool to reuse thread and you can group them based on your business logic.\n\n**Internal working for Executor service**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/executorservice.png)\n\n**Java ExecutorService Implementations**\n\nThe Java ExecutorService is very similar to a thread pool.\n\nIn fact, the implementation of the ExecutorService interface is present in the java.util.concurrent package which is a thread pool implementation.\n\nSince ExecutorService is an interface, you need to checkout its implementations in order to make any use of it.\n\nExecutorService has the following implementation in the java.util.concurrent package\n\n- ThreadPoolExecutor\n- ScheduledThreadPoolExecutor\n\n**Creating an ExecutorService**\n\nHow you create an ExecutorService depends on the implementation you use. However, you can use the Executors factory class to create ExecutorService instances too.\n\nHere are a few examples of creating an ExecutorService\n\n- ExecutorService executorService1 = Executors.newSingleThreadExecutor();\n- ExecutorService executorService2 = Executors.newFixedThreadPool(10);\n- ExecutorService executorService3 = Executors.newScheduledThreadPool(10);\n\n**ExecutorService Usage**\n\nThere are a few different ways to delegate tasks for execution to an ExecutorService\n\n- execute(Runnable)\n- submit(Runnable)\n- submit(Callable)\n- invokeAny(\u2026)\n- invokeAll(\u2026)\n\nI will take a look at each of these methods in the following sections.\n\n**Execute Runnable**\n\nThe Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.\n\nHere is an example of executing a Runnable with an ExecutorService\n\n```jsx\nExecutorService executorService = Executors.newSingleThreadExecutor();\nexecutorService.execute(new Runnable() {\n    public void run() {\n    System.out.println("Asynchronous task");\n    }\n});\nexecutorService.shutdown();\n\n```\n\nThere is no way of obtaining the result of the executed Runnable, if necessary you will have to use a Callable for that (explained in the following sections).\n\n**Submit Runnable**\n\nThe Java ExecutorService submit(Runnable) method also takes a Runnable implementation, but returns a Future object. This Future object can be used to check if the Runnable has finished executing.\n\nLet\'s see an example,\n\n```jsx\npackage com.praveen.executorframework;\n\npublic class CheckProcessorTask implements Runnable {\n\n\tString name;\n\n\tpublic CheckProcessorTask(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(name + " Check Processor has began processing the check " + Thread.currentThread().getName());\n\t\t\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t}catch(InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tSystem.out.println(name + " Check Processor has completed processing the check " + Thread.currentThread().getName());\n\n\t}\n\n}\n\n```\n\n```jsx\npackage com.praveen.executorframework;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ExecutorDemo {\n\n\tpublic static void main(String[] args) {\n\n\t\tCheckProcessorTask[] cpt = { new CheckProcessorTask("ATM"), new CheckProcessorTask("Bank"),\n\t\t\t\tnew CheckProcessorTask("Mobile"), new CheckProcessorTask("Web") };\n\n\t\tExecutorService executorService = Executors.newFixedThreadPool(2);\n\n\t\tfor (CheckProcessorTask checkProcessorTask : cpt) {\n\t\t\texecutorService.submit(checkProcessorTask);\n\t\t}\n\t\t\n\t\texecutorService.shutdown();\n\n\t}\n\n}\n\n```\n\n**Output**\n\n```jsx\nATM Check Processor has began processing the check pool-1-thread-1\nBank Check Processor has began processing the check pool-1-thread-2\nATM Check Processor has completed processing the check pool-1-thread-1\nBank Check Processor has completed processing the check pool-1-thread-2\nMobile Check Processor has began processing the check pool-1-thread-1\nWeb Check Processor has began processing the check pool-1-thread-2\nMobile Check Processor has completed processing the check pool-1-thread-1\nWeb Check Processor has completed processing the check pool-1-thread-2\n\n```\n\n**Submit Callable**\n\nThe Java ExecutorService submit(Callable) method is similar to the submit(Runnable) method except it takes a Java Callable instead of a Runnable.\n\nThe Callable\'s result can be obtained via the Java Future object returned by the submit(Callable)method.\n\n\nLet\'s see an example,\n\n```jsx\npackage com.praveen.executorframework;\n\nimport java.util.concurrent.Callable;\n\npublic class MyCallable implements Callable<Integer> {\n\n\tint num;\n\n\tpublic MyCallable(int num) {\n\t\tthis.num = num;\n\t}\n\n\t@Override\n\tpublic Integer call() throws Exception {\n\n\t\tSystem.out\n\t\t\t\t.println(Thread.currentThread().getName() + " is calculating the sum of all the numbers up to " + num);\n\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= num; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\n}\n\n\n```\n\n```jsx\npackage com.praveen.executorframework;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\npublic class CallableFutureDemo {\n\n\tpublic static void main(String[] args) {\n\n\t\tMyCallable[] callables = { new MyCallable(10), new MyCallable(20), new MyCallable(30), new MyCallable(40),\n\t\t\t\tnew MyCallable(50), new MyCallable(60) };\n\n\t\tExecutorService executorService = Executors.newFixedThreadPool(3);\n\n\t\tfor (MyCallable myCallable : callables) {\n\t\t\tFuture<Integer> future = executorService.submit(myCallable);\n\n\t\t\ttry {\n\t\t\t\tSystem.out.println(future.get());\n\t\t\t} catch (InterruptedException | ExecutionException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\texecutorService.shutdown();\n\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\npool-1-thread-1 is calculating the sum of all the numbers up to 10\n55\npool-1-thread-2 is calculating the sum of all the numbers up to 20\n210\npool-1-thread-3 is calculating the sum of all the numbers up to 30\n465\npool-1-thread-1 is calculating the sum of all the numbers up to 40\n820\npool-1-thread-2 is calculating the sum of all the numbers up to 50\n1275\npool-1-thread-3 is calculating the sum of all the numbers up to 60\n1830\n```\n\n\n**invokeAny()**\n\nThe invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.\nInvoking this method does not return a Future, but returns the result of one of the Callable objects.\n\nYou have no guarantee about which of the Callable\'s results you get. Just one of the ones that finish.If one of the tasks complete (or throws an exception), the rest of the Callable\'s are cancelled.\n\n\n**invokeAll()**\n\nThe invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.\nThe invokeAll() returns a list of Future objects via which you can obtain the results of the executions of each Callable.Keep in mind that a task might finish due to an exception, so it may not have "succeeded".There is no way on a Future to tell the difference.\n\nLet\'s see an example with invokeAny() and invokeAll(),\n\n```jsx\npackage com.praveen.multithreading.executorservice;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\npublic class FutureAndCallableDemo {\n\tpublic static void main(String[] args) throws InterruptedException, ExecutionException {\n\t\tExecutorService executorService = Executors.newFixedThreadPool(3);\n\n\t\tCallable<String> task1 = () -> {\n\t\t\tThread.sleep(2000);\n\t\t\treturn "Result of Task1";\n\t\t};\n\n\t\tCallable<String> task2 = () -> {\n\t\t\tThread.sleep(1000);\n\t\t\treturn "Result of Task2";\n\t\t};\n\n\t\tCallable<String> task3 = () -> {\n\t\t\tThread.sleep(5000);\n\t\t\treturn "Result of Task3";\n\t\t};\n\n\t\tList<Callable<String>> taskList = Arrays.asList(task1, task2, task3);\n\n\t\tList<Future<String>> futures = executorService.invokeAll(taskList);\n\n\t\tfor (Future<String> future : futures) {\n\t\t\t// The result is printed only after all the futures are complete. (i.e. after 5\n\t\t\t// seconds)\n\t\t\tSystem.out.println(future.get());\n\t\t}\n\n\t\t// Returns the result of the fastest callable. (task2 in this case)\n\t\tString result = executorService.invokeAny(Arrays.asList(task1, task2, task3));\n\n\t\tSystem.out.println(result);\n\n\t\texecutorService.shutdown();\n\t}\n}\n\n```\n**Output**\n\n```jsx\nResult of Task1\nResult of Task2\nResult of Task3\nResult of Task2\n\n```\n\n**Runnable vs. Callable**\n\nThe Runnable interface is very similar to the Callable interface. Both interfaces represents a task that can be executed concurrently by a thread or an ExecutorService.\nBoth interfaces only has a single method.\n\nThere is one small difference between the Callable and Runnable interface though. The difference between the Runnable and Callable interface is more easily visible when you see the interface declarations.\n\nHere is first the Runnable interface declaration\n\n```jsx\n\npublic interface Runnable {\n    public void run();\n}\n\n```\n\nAnd here is the Callable interface declaration\n\n```jsx\n\npublic interface Callable{\n    public Object call() throws Exception;\n}\n\n```\n\nThe main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.\n\nAnother difference between call() and run() is that call() can throw an exception, whereas run() cannot (except for unchecked exceptions \u2013 subclasses of RuntimeException).\n\nIf you need to submit a task to a Java ExecutorService and you need a result from the task, then you need to make your task implement the Callable interface. Otherwise your task can just implement the Runnable interface.\n\n**Cancel Task**\n\nYou can cancel a task (Runnable or Callable) submitted to a Java ExecutorService by calling the cancel() method on the Future returned when the task is submitted.\nCancelling the task is only possible if the task has not yet started executing. \n\n```jsx\nfuture.cancel();\n```\n\n**ExecutorService Shutdown**\n\nWhen you are done using the Java ExecutorService you should shut it down, so the threads do not keep running.\n\nIf your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application.\n\nThe active threads inside this ExecutorService prevents the JVM from shutting down.\n\n**shutdown()**\n\nTo terminate the threads inside the ExecutorService you call its shutdown() method. The ExecutorService will not shut down immediately, but it will no longer accept new tasks, and once all threads have finished current tasks, the ExecutorService shuts down.\n\nAll tasks submitted to the ExecutorService before shutdown() is called, are executed. \n\n```jsx\nexecutorService.shutdown();\n```\n\n**shutdownNow()**\n\nIf you want to shut down the ExecutorService immediately, you can call the shutdownNow() method. This will attempt to stop all executing tasks right away, and skips all submitted but non-processed tasks. There are no guarantees given about the executing tasks.\n\nPerhaps they stop, perhaps the execute until the end. It is a best effort attempt.\n\n```jsx\nexecutorService.shutdownNow();\n```\n\n**awaitTermination()**\n\nThe ExecutorServiceawaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs. The awaitTermination() method is typically called after calling shutdown() or shutdownNow().\n\n```jsx\nexecutorService.awaitTermination();\n```\n\n '}}]);