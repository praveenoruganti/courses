(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[196],{765:function(e,t,n){"use strict";n.r(t),t.default=' ```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\n```\n\nFor those of you who use Redux, useReducer will probably be familiar.\n\nuseReducer takes in two arguments \u2014 a reducer and an initial state.\n\nA reducer is a function that you can define that takes in the current state and an **action**. The action has a type, and the reducer uses a switch statement to determine which block to execute based on the type.\n\nWhen it finds the correct block, it returns the state but with the modifications you define depending on the type. We can pass this reducer into useReducer, and then use this hook like this:\nuseReducer is normally used when you have to manage complex states.\n\nuseReducer is the best solution in React for handling complex state interactions so let\u2019s look at how we can convert a component from useState to useReducer.\n\nuseReducer is normally used when you have to manage complex states.\n\n```jsx\nimport React, { useReducer } from "react";\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case "increment":\n      return { count: state.count + 1 };\n    case "decrement":\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\nexport default function CounterReducer() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: "decrement" })}>-</button>\n      <button onClick={() => dispatch({ type: "increment" })}>+</button>\n    </>\n  );\n}\n```\n '}}]);