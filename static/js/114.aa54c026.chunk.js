(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[114],{683:function(e,n,a){"use strict";a.r(n),n.default=' HashMap class implements the map interface by using a hash table.\n\n- HashMap don\'t contain duplicate keys and can contain duplicate values.\n- HashMap class may have one null key and multiple null values.\n- HashMap class is not synchronized.\n- HashMap class doesn\'t maintain order\n- The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.\n\n```jsx\npackage com.praveen.collections;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HashMapExamples {\n\n    public static void main(String[] args) {\n\n        System.out.println("HashMap Examples");\n\n        Map<Integer, String> namedMap = new HashMap<>();\n        namedMap.put(100, "Praveen");\n        namedMap.put(101, "Prasad");\n        namedMap.put(102, "Kiran");\n        namedMap.putIfAbsent(103, "Krishna");\n        namedMap.put(104, "Ravi");\n        namedMap.remove(100);\n        namedMap.replace(101, "Praveen");\n        for (Map.Entry<Integer, String> namedEntry : namedMap.entrySet()) {\n            System.out.println(namedEntry.getKey() + " " + namedEntry.getValue());\n        }\n\n    }\n\n}\n\n```\n\n**Output**\n\n```jsx\nHashMap Examples\n101 Praveen\n102 Kiran\n103 Krishna\n104 Ravi\n```\n\n**HashMap internal working**\n\n**What is Hashing**\n\nIt is the process of converting an object into an integer value. The integer value helps in indexing and faster searches.\n\nHashMap uses a technique called Hashing.\n\nIt stores the data in the pair of Key and Value. HashMap contains an array of the nodes, and the node is represented as a class. It uses an array and LinkedList data structure internally for storing Key and Value.\n\n**equals():** It checks the equality of two objects. It compares the Key, whether they are equal or not. It is a method of the Object class. It can be overridden. If you override the equals() method, then it is mandatory to override the hashCode() method.\n\n**hashCode():** This is the method of the object class. It returns the memory reference of the object in integer form. The value received from the method is used as the bucket number. The bucket number is the address of the element inside the map. Hash code of null Key is 0.\n\n**Buckets:** Array of the node is called buckets. Each node has a data structure like a LinkedList. More than one node can share the same bucket. It may be different in capacity.\n\nWe use put() method to insert the Key and Value pair in the HashMap. The default size of HashMap is 16 (0 to 15).\n\nFor example,we want to insert three (Key, Value) pair in the HashMap.\n\n```jsx\nHashMap<String,\xa0Integer>\xa0map\xa0=\xa0new\xa0HashMap<>();\nmap.put("Praveen", 89);\nmap.put("Prasad", 45);\nmap.put("Kiran", 51);\n```\n\nTo store the key in memory we have to calculate the index.\n\nFor example, Praveen index is 1\n\nIf Prasad index is 1, then there is a hash collision hence it will be next node for Praveen in index 1 itself.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/bucket.png)\n\nTo use HashMap in multi threaded environment, you must write your code in synchronized block or use any external Lock implementation but in that case there is high chances of error and deadlock situations, if proper care is not taken care of.\nIn short it is not advisable to use HashMap in multi threaded environment. Instead use any of the similar thread safe collections like HashTable, Collections.SynchronizedMap or ConcurrentHashMap.\n\nThough all of them are thread safe but ConcurrentHashMap provides better performance.\n\n**HashTable**\n\nHashTable is a legacy class uses synchroized methods to achive thread safety but at a time only one thread can read or write in other words thread acquires lock on entire HashTable instance hence performance is slow. HashTable doesnt allow null keys or values where as HashMap allows one null key and multiple null values.\n\n**Collections.SynchronizedMap**\n\nSynchronizedMap is static inner class of utility class Collections.It is quite similar to HashTable and it allows acquires lock on entire Map instance. It may allow null keys and null values based on the original collection class being passed to it.\n\n**ConcurrentHashMap**\n\nHashTable and Collections.SynchronizedMap both acquires lock on entire Map instance which provides thread safety but not good performance as at a time only one thread object can access that Map instance.\n\nTo overcome this issue ConcurrentHashMap was introduced in Java 5.More than one thread can read and write concurrently in ConcurrentHashMap and it still provides thread safety. ConcurrentHashMap divides the Map instance into different segments and each thread acquires lock on each segment. By default it allows 16 threads to access simultaneously without external synchronization i.e.. default concurrency level is 16. We can also increase or decrease the concurrency level by using below constructor\nConcurrentHashMap(int intialCapacity,fload loadfactor,int concurrencyLevel). Please note multiple threads cant write on same segment but multiple threads can read from the same segment. ConcurrentHashMap doesnt allow null keys and null values.\n\n**LinkedHashMap**\n\nLinkedHashMap is Hashtable and Linked list implementation of the Map interface, with predictable iteration order. It inherits HashMap class and implements the Map interface. LinkedHashMap maintains insertion order apart from the above HashMap features.\n\n**TreeMap**\n\nTreeMap is a red-black tree based implementation. It provides an efficient means of storing key-value pairs in sorted order.It implements the NavigableMap interface and extends AbstractMap class.TreeMap cannot have a null key but can have multiple null values.TreeMap maintains ascending order by default.\n\n**Hashtable**\n\nHashtable class implements a hashtable, which maps keys to values. It inherits Dictionary class and implements the Map interface.\n\n- A Hashtable is an array of a list. Each list is known as a bucket. The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.\n- Java Hashtable class contains unique elements.\n- Java Hashtable class doesn\'t allow null key or value.\n- Java Hashtable class is synchronized.\n- The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.\n\n**IdentityHashMap**\n\n- It is exactly same as HashMap except the following difference.\n- In case of HashMap, JVM will use .equals(-) method to identify duplicate keys, which is meant for content comparison.\n- But in case of IdentityHashMap, JVM will use == operator to identify duplicate keys which is meant for reference comparison.\n\n**WeakHashMap**\n\n- It is exactly same as HashMap except the following difference.\n- In case of HashMap, if an object associated with HashMap then it is not eligible for garbage collection,eventhough it doesn\'t contain any external references. i.e., HashMap dominates Garbage Collector.\n- But in case of WeakHashMap, if an object doesn\'t contain any references then it is always eligible for Garbage Collector eventhough it is associated with WeakHashMap. ie., Garbage Collector dominates WeakHashMap.\n\n**How to create a Custom Map(key/value pair)**\n\n```jsx\npackage com.praveen.collections;\n\nimport java.util.List;\n\nimport java.util.ArrayList;\n\npublic class MyMap {\n    class Container {\n        Object key;\n        Object value;\n\n        public void insert(Object k, Object v) {\n            this.key = k;\n            this.value = v;\n        }\n    }\n\n    private Container c;\n    private List<Container> recordList;\n\n    public MyMap() {\n        this.recordList = new ArrayList<Container>();\n    }\n\n    public void put(Object k, Object v) {\n        this.c = new Container();\n        c.insert(k, v);\n        // check for the same key before adding\n        for (int i = 0; i < recordList.size(); i++) {\n            Container c1 = recordList.get(i);\n            if (c1.key.equals(k)) {\n                // remove the existing object\n                recordList.remove(i);\n                break;\n            }\n        }\n        recordList.add(c);\n    }\n\n    public Object get(Object k) {\n        for (int i = 0; i < this.recordList.size(); i++) {\n            Container con = recordList.get(i);\n            if (k.toString() == con.key.toString()) {\n                return con.value;\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        MyMap hm = new MyMap();\n        hm.put("1", "1");\n        hm.put("2", "2");\n        hm.put("3", "3");\n        System.out.println(hm.get("3"));\n        hm.put("3", "4");\n        System.out.println(hm.get("1"));\n        System.out.println(hm.get("3"));\n        System.out.println(hm.get("8"));\n    }\n}\n\n```\n\n**Output**\n\n```jsx\n3\n1\n4\nnull\n```\n\n\n**Difference between Map Implementations**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/mapdifferences.png)\n\n**Difference between HashMap, HashTable ,ConcurrentHashMap**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/mapdifferences1.png)\n\n\n**Difference between HashMap and HashTable**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/mapdifferences2.png)\n\n\n\n\n\n\n\n '}}]);