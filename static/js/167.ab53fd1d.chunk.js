(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[167],{736:function(e,n,t){"use strict";t.r(n),n.default=' A microservice instance needs to register itself with the third-party agent. This registration process is called service discovery.\n\nWhen a microservice instance registers with a service discovery agent, it will tell the discovery agent two things: the physical IP address or domain address of the service instance, and a logical name that an application can use to look up in a service. Certain service discovery agents will also require a URL back to the registering service that can be used by the service discovery agent to perform health checks.\n\nThe service client then communicates with the discovery agent to look up the service\'s location.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/discovery.jpg)\n\nA service discovery agent doesn\'t act only as a traffic cop that guides the client to the location of the service. In a cloud-based microservice application, you\'ll often have\nmultiple instances of a service running. Sooner or later, one of those service instances will fail. The service discovery agent monitors the health of each service instance registered with it and removes any service instances from its routing tables to ensure that clients aren\'t sent a service instance that has failed.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/monitoring.jpg)\n\nAfter a microservice has come up, the service discovery agent will continue to monitor and ping the health check interface to ensure that that service is available.\n\nBy building a consistent health check interface, you can use cloud-based monitoring tools to detect problems and respond to them appropriately.\n\nIf the service discovery agent discovers a problem with a service instance, it can take corrective action such as shutting down the ailing instance or bringing additional\nservice instances up.\n\n\nWith Spring Cloud service discovery, you can abstract away the physical location (IP and/or server name) of where your servers are deployed from the clients consuming\nthe service. Service consumers invoke business logic for the servers through a logical name rather than a physical location. Spring Cloud service discovery also handles the\nregistration and deregistration of services instances as they\'re started up and shut down. Spring Cloud service discovery can be implemented using Consul and Eureka as its service discovery engine.\n\n**Local Environment Using Netflix Eureka**\n\nEureka Server\xa0is an application that holds the information about all client-service applications. Every Micro service will register into the Eureka server and Eureka server knows all the client applications running on each port and IP address. Eureka Server is also known as Discovery Server.\n\nNormally in Micro Service Architecture Design we are developing separate Services and exposing each API as service Endpoint and whenever we required to access other services in simple we will be using\xa0RestTemplate.\n\nIt is highly impossible to remember the microservice restful service endpoint URL\'s with hostname and port so Netflix team came up with solution with Eureka server where all services endpoints will be registered.\n\n**Registering with Eureka**\n\nWhen a client registers with Eureka, it provides meta-data about itself such as host and port, health indicator URL, homepage etc. Eureka receives heartbeat messages from each instance belonging to a service. If the heartbeat fails over a configurable timetable, the instance is normally removed from the registry.\n\n**In local, we need to develop eureka server SpringBoot application**\n\nWe need to add below eureka server dependency in pom.xml\n\n```jsx\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\nWe need to include @EnableEurekaServer on top of main class.\n\n```jsx\n@SpringBootApplication\n@EnableEurekaServer\npublic class SpringCloudEurekaServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringCloudEurekaServerApplication.class, args);\n\t}\n\n}\n\n```\n\nWe need to configure below eureka server properties in application.yml\n\n```jsx\neureka:\n client:\n  register-with-eureka: false\n  fetch-registry: false\n server:\n   eviction-interval-timer-in-ms: 1000\n\nspring:\n application:\n   name: praveenoruganti-eureka-server\n   \nserver:\n port: 8761\n\n\n```\n\nNow run the application in command prompt using command **java -jar target/eureka-server-1.0.jar**\n\nLet\'s Open URL for eureka server application\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/eureka1.png)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/eureka2.png)\n\nIf you see above there are no application registered in eureka server.\n\nLet\'s consider an example, we have 2 microservices i.e... Order Management Service and Billing service.\n\nHere the flow will be Order Management Service will call Billing Service for successful creation of order based on orderid. Here we will call the service using RestTemplate.\n\n**praveenoruganti-billing-service**\n\nWe need to add the below dependency in pom.xml\n\n```jsx\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\nWe need to add @EnableDiscoveryClient on top of main class.\n\n```jsx\npackage com.praveen.billing;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.env.Environment;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.info.Contact;\nimport io.swagger.v3.oas.models.info.Info;\nimport io.swagger.v3.oas.models.info.License;\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class BillingServiceApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(BillingServiceApplication.class);\n\t}\n\n\t@Bean\n\tpublic OpenAPI customOpenAPI(Environment env) {\n\n\t\treturn new OpenAPI().components(new Components()).info(new Info()\n\t\t\t\t.title(env.getRequiredProperty("app.openApiTitle"))\n\t\t\t\t.description(env.getRequiredProperty("app.openApiDescription"))\n\t\t\t\t.contact(new Contact().name("Praveen Oruganti").email("praveenoruganti@gmail.com")\n\t\t\t\t\t\t.url("https://praveenoruganti.github.io"))\n\t\t\t\t.termsOfService("https://praveenoruganti.github.io/#/aboutme")\n\t\t\t\t.license(new License().name("GNU General Public License v3.0").url("https://www.gnu.org/licenses")));\n\t}\n\n}\n\n```\n\nWe need to configure eureka properties in application.yml file.\n\n```jsx\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n  endpoint:\n    health:\n      show-details: ALWAYS\neureka:\n  client:\n    registerWithEureka: true\n    fetchRegistry: true\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n  instance:\n    hostname: localhost\nserver:\n  port: 8091\nspring:\n  application:\n    name: praveenoruganti-billing-service\n\napp:\n openApiTitle: Billing Service\n openApiDescription: |\n   \n       Billing Service\n\n```\n\nNow run the application in command prompt using below commands.\n\n**java -Dserver.port=8091 -jar target/billing-service-1.0.jar**\n\n**java -Dserver.port=8092 -jar target/billing-service-1.0.jar**\n\n\n**praveenoruganti-ordermanagement-service**\n\nWe need to add the below dependency in pom.xml\n\n```jsx\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\nWe need to add @EnableDiscoveryClient on top of main class.\n\n```jsx\npackage com.praveen.ordermanagement;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.client.RestTemplateBuilder;\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\nimport org.springframework.cloud.client.loadbalancer.LoadBalanced;\nimport org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.env.Environment;\nimport org.springframework.web.client.RestTemplate;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.info.Contact;\nimport io.swagger.v3.oas.models.info.Info;\nimport io.swagger.v3.oas.models.info.License;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class OrderManagementServiceApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(OrderManagementServiceApplication.class);\n\t}\n\t\n\t@Bean\n\tpublic OpenAPI customOpenAPI(Environment env) {\n\n\t\treturn new OpenAPI().components(new Components()).info(new Info()\n\t\t\t\t.title(env.getRequiredProperty("app.openApiTitle"))\n\t\t\t\t.description(env.getRequiredProperty("app.openApiDescription"))\n\t\t\t\t.contact(new Contact().name("Praveen Oruganti").email("praveenoruganti@gmail.com")\n\t\t\t\t\t\t.url("https://praveenoruganti.github.io"))\n\t\t\t\t.termsOfService("https://praveenoruganti.github.io/#/aboutme")\n\t\t\t\t.license(new License().name("GNU General Public License v3.0").url("https://www.gnu.org/licenses")));\n\t}\n\n\t@LoadBalanced\n\t@Bean\n\tRestTemplate restTemplate(RestTemplateBuilder builder){\n\t\treturn builder.build();\n\t}\n\t\n\n}\n\n\n```\n\nWe need to configure eureka properties in application.yml file.\n\n```jsx\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n  endpoint:\n    health:\n      show-details: ALWAYS\n\neureka:\n  client:\n    registerWithEureka: true\n    fetchRegistry: true\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n  instance:\n    hostname: localhost\nserver:\n  port: 8090\nspring:\n  application:\n    name: praveenoruganti-ordermanagement-service\n    \npraveenoruganti-ordermanagement-service:\n                   billingURL: http://praveenoruganti-billing-service/api/v1_0/billing/{id}\n                   \napp:\n openApiTitle: Order Management Service\n openApiDescription: |\n   \n       Order Management Service\n                  \n```\n\nAs we have discussed earlier, praveenoruganti-ordermanagement-service is interacting with praveenoruganti-billing-service with the help of rest template and let\'s see the code of it.\n\n```jsx\npublic String createOrder(String orderid) throws Exception {\n\t\tMap<String, String> map = new HashMap<>();\n\t\tmap.put("id", orderid);\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));\n\t\tHttpEntity<String> entity = new HttpEntity<>(null, headers);\n\t\tString message = restTemplate.exchange(billingURL, HttpMethod.POST, entity, String.class, map).getBody();\n\t\tlog.info("Response Received from Billing Service", message);\n\t\treturn message;\n\t}\n```\n\nHere if you see billingURL is mentioned in application.yml as [http://praveenoruganti-billing-service/api/v1_0/billing](http://praveenoruganti-billing-service/api/v1_0/billing)\n\nAs we have used Eureka Server, there is no need for providing the hostname and port for discovery as praveenoruganti-ordermanagement-service and praveenoruganti-billing-service are already registered in Eureka server rather we have used the application name in the URL for service interaction via rest template.\n\nNow run the application in command prompt using command **java -jar target/ordermanagement-service-1.0.jar**\n\nLet\'s open URL [http://localhost:8761/](http://localhost:8761/) for eureka server application.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/eureka3.png)\n\n\nLet\'s post a request to Order Management Service(http://localhost:8090/api/v1_0/order)\n\n**Input**\n\n```jsx\n{\n  "orderId": "501",\n  "orderDescription": "Mobile",\n  "correlationId": "258527852785275275"\n}\n```\n\n**Output**\n\n```jsx\nSuccessfully placed the order 501\n```\n\nNow if you post multiple requests in Order Management Service then you can see that the transactions are flowing through both the ports(8091 and 8092) of Billing Service.\n\n '}}]);