(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[233],{802:function(e,t,n){"use strict";n.r(t),t.default=' **What is OAuth 2.0?**\n\nOAuth = Open + Authorization\n\nOAuth 2.0 - is an Authorization framework\n\nOAuth 2.0 is version 2 of Oauth protocol which was created in 2006. It allows the 3rd party applications to obtain limited access to User accounts hosted on applications like Google, Facebook, and Twitter etc.\n\n**Roles in OAuth2**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/oauth2.jpg)\n\nThere are 4 roles in OAuth2\n\n- **Resource Owner** : Resource owner is the user,  who authorizes an application to access their account.\n- **Client** : Client is the application, which is used by the user to get resources from the resource server.\n- **Resource Server** : For example, Google server where our account/contacts are hosted. Third Party Apps accesses the resource server using temporary access tokens\n- **Authorization Server** : The server which issues access tokens. In above example it was "accounts.google.com", which authorizes the google account.\n\n**Tokens in OAuth2**\n\nThere are 2 types of tokens issued by Authorization Server\n\n- **Access Token** : Third party apps use this token to access information from the resource server. It has a limited lifetime and must be sent with each request.\n- **Refresh Token** : This is similar to REMEMBER ME option. This token has a longer lifetime and is used to re-generate the access token.\n\n  **Grant Types**\n\nBased on the nature of 3rd party applications, Authorization server defines Grant Types for obtaining the access token.\n\n- **Authorization Code Grant** : Authorization server first issues Authorization code to Client. It then uses this code to get the Access token. Generally this is used in Server Side Web App.\n- **Implicit Grant** : Similar to the Authorization Code Grant, but Authentication server directly returns the token.\n- **Resource Owner Password Credentials OR password Grant** : Here the user submits his credentials and then only access token is issues.\n- **Client Credentials Grant** : Client uses client_id and client_secret to get access token. Generally this is used in Server Side script with no UI.\n- **Refresh Token** : Client uses this token to regenerate access token.\n\nThe Client Credentials grant type is the most appropriate for server-to-server applications, such as typical B2B interactions.\n\n**Getting Started**\n\nWe add the Spring Oauth dependency to our pom.xml file.\n\n```jsx\n\t    <dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-security</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.glassfish.jaxb</groupId>\n\t\t\t<artifactId>jaxb-runtime</artifactId>\n\t\t\t<version>2.3.6</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-oauth2-resource-server</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-oauth2</artifactId>\n\t\t\t<version>2.2.5.RELEASE</version>\n\t\t\t<exclusions>\n\t\t\t\t<exclusion>\n\t\t\t\t\t<groupId>org.glassfish.jaxb</groupId>\n\t\t\t\t\t<artifactId>jaxb-runtime</artifactId>\n\t\t\t\t</exclusion>\n\n\t\t\t</exclusions>\n\t\t</dependency>\n```\n\n**Enable Authorization Server Support**\n\nWe open the main application class and add @EnableAuthorizationServer to enable the support for the authorization server and appropriate outh configuration in open api.\n\n```jsx\n@SpringBootApplication\n@EnableAuthorizationServer\npublic class EmployeeRegistrationApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EmployeeRegistrationApplication.class);\n\t}\n\n\t@Bean\n\tpublic OpenAPI customOpenAPI(Environment env) {\n\n\t\treturn new OpenAPI()\n\t\t\t\t.components(new Components().addSecuritySchemes("spring_oauth",\n\t\t\t\t\t\tnew SecurityScheme().type(SecurityScheme.Type.OAUTH2).description("Oauth2 flow")\n\t\t\t\t\t\t\t\t.flows(new OAuthFlows().clientCredentials(new OAuthFlow().tokenUrl("/oauth/token")\n\t\t\t\t\t\t\t\t\t\t.scopes(new Scopes().addString("read", "for read operations").addString("write",\n\t\t\t\t\t\t\t\t\t\t\t\t"for write operations"))))))\n\t\t\t\t.security(Arrays.asList(new SecurityRequirement().addList("spring_oauth")))\n\t\t\t\t.info(new Info().title(env.getRequiredProperty("app.openApiTitle"))\n\t\t\t\t\t\t.description(env.getRequiredProperty("app.openApiDescription"))\n\t\t\t\t\t\t.contact(new Contact().name("Praveen Oruganti").email("praveenoruganti@gmail.com")\n\t\t\t\t\t\t\t\t.url("https://praveenoruganti.github.io"))\n\t\t\t\t\t\t.termsOfService("https://praveenoruganti.github.io/#/aboutme").license(new License()\n\t\t\t\t\t\t\t\t.name("GNU General Public License v3.0").url("https://www.gnu.org/licenses")));\n\t}\n\n}\n\n\n```\n\n`@EnableAuthorizationServer` enables the client credentials grant type by default.\n\n**Creating ClientId and Client Secret**\n\nOpen/create the resources/application.yml file and add the following properties:\n\n```jsx\nsecurity:\n  oauth2:\n    client:\n      client-id: praveenorugantitech\n      client-secret: passionfortech\n      scope:\n        - read\n        - write\n```\n\nWe need to tell Spring which endpoints -resources- must be authenticated. Otherwise, all requests will skip security.\n\n\n**Enable Resource Server Support**\n\nCreate a class that extends ResourceServerConfigurerAdapter and add the following code.\n\n```jsx\n@Configuration\n@EnableResourceServer\npublic class OAuth2ResourceServer extends ResourceServerConfigurerAdapter {\n\t@Override\n\tpublic void configure(HttpSecurity http) throws Exception {\n\t\thttp.authorizeRequests().antMatchers("/api/v1_0/**").authenticated().antMatchers("/").permitAll();\n\t}\n\n}\n```\n\nNow, run the main application.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/swagger6.jpg)\n\n\nLet\'s invoke Fetch All Employees operation in swagger without oauth2 credentials\n\nNow you see the below error \n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/swagger7.jpg)\n\n\nLet\'s invoke Create Employee operation in swagger without oauth2 credentials\n\nNow you see the below error \n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/swagger8.jpg)\n\nWhy does this happen? Well, we need to tell OpenAPI that configures security.\n\n\nLet\'s enter the credentials and the scope in swagger now by clicking the green button called Authorize.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/swagger9.jpg)\n\nNow click on Close button and we are able to Authorize all endpoints in swagger now.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/swagger10.jpg)\n\n\nLet\'s invoke Fetch All Employees operation in swagger and you will see success response as you have authorized already.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/swagger11.jpg)\n\n\nLet\'s invoke Create Employee operation in swagger and you will see success response as you have authorized already.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/swagger12.jpg)\n\nYes, you did it!\n\nNow, your endpoints are secured.\n\n\nLet\'s create a consumer app which fetches the employees with OAuth2 credentials.\n\n**Token Service class**\n\n```jsx\n@Service\n@AllArgsConstructor\n@Slf4j\npublic class TokenService {\n\n\tprivate final WebClient tokenApi;\n\tprivate final ApplicationConfig appConfig;\n\tprivate final Gson gson;\n\n\tpublic String getAccessToken() {\n\t\tString accessTokenValue = null;\n\t\tString tokenRespStr = null;\n\t\tToken response=null;\n\n\t\ttry {\n\t\t\tStopWatch stopWatch = new StopWatch("Employee Registration Token Service Call");\n\t\t\tstopWatch.start();\n\n\t\t\tMultiValueMap<String, String> formData = new LinkedMultiValueMap<>();\n\n\t\t\tformData.add("grant_type", appConfig.getOauth().getGrantType());\n\t\t\tformData.add("scope", appConfig.getOauth().getScope());\n\t\t\ttokenRespStr = tokenApi.post()\n\t\t\t\t\t.header(HttpHeaders.AUTHORIZATION,\n\t\t\t\t\t\t\t"Basic " + HttpHeaders.encodeBasicAuth(appConfig.getOauth().getClientId(),\n\t\t\t\t\t\t\t\t\tappConfig.getOauth().getClientSecret(), null))\n\t\t\t\t\t.body(BodyInserters.fromFormData(formData)).retrieve().bodyToMono(String.class).block();\n\t\t\tresponse = gson.fromJson(tokenRespStr, Token.class);\n\t\t\taccessTokenValue = response.getAccessToken();\n\t\t\tstopWatch.stop();\n\t\t} catch (WebClientResponseException webClientResponseException) {\n\t\t\tlog.error("Employee Registration Token Service  Failure Response",\n\t\t\t\t\tv("webClientResponse", webClientResponseException.getResponseBodyAsString()));\n\t\t\tthrow new ExternalServiceException("tokenException-" + webClientResponseException.getMessage());\n\n\t\t} catch (Exception exception) {\n\t\t\tlog.error("Employee Registration Token Service Failure Response",\n\t\t\t\t\tv("webClientResponse", exception.getMessage()));\n\t\t\tthrow new ExternalServiceException("tokenException--" + exception.getMessage());\n\n\t\t}\n\n\t\treturn accessTokenValue;\n\t}\n\n}\n```\n\n**Employee Reg Service Class**\n\n```jsx\n@Service\n@AllArgsConstructor\n@Slf4j\npublic class EmployeeRegService {\n\n\tprivate final ApplicationConfig appConfig;\n\tprivate final WebClient empRegServiceForFetchEmployees;\n\tprivate final TokenService tokenService;\n\n\tpublic List<Employee> fetchData() {\n\t\tlog.info("Employee Registration Service Request", v("Host", appConfig.getEmpRegApiHost()),\n\t\t\t\tv("Path", appConfig.getEmpRegApiEndpoint()));\n\n\t\tList<Employee> empList = null;\n\t\ttry {\n\t\t\tStopWatch stopWatch = new StopWatch("Employee Registration Service Call");\n\t\t\tstopWatch.start();\n\t\t\tempList = empRegServiceForFetchEmployees.get()\n\t\t\t\t\t.header("Authorization", "Bearer " + tokenService.getAccessToken())\n\t\t\t\t\t.accept(MediaType.APPLICATION_JSON).retrieve()\n\t\t\t\t\t.bodyToMono(new ParameterizedTypeReference<List<Employee>>() {\n\t\t\t\t\t})\n\t\t\t\t\t.retryWhen(Retry\n\t\t\t\t\t\t\t.backoff(appConfig.getRetryAttempts(),\n\t\t\t\t\t\t\t\t\tDuration.ofMillis(appConfig.getBackOffTimeInMillisec()))\n\t\t\t\t\t\t\t.filter(this::isConnectionTimeout))\n\t\t\t\t\t.block();\n\t\t\tstopWatch.stop();\n\t\t\tlog.info("Employee Registration Service  Execution Times", v("Host", appConfig.getEmpRegApiHost()),\n\t\t\t\t\tv("Path", appConfig.getEmpRegApiEndpoint()), v("TotalTimeTaken", stopWatch.getTotalTimeMillis()));\n\t\t} catch (WebClientResponseException webClientResponseException) {\n\t\t\tlog.error("Employee Registration Service  Failure Response",\n\t\t\t\t\tv("webClientResponse", webClientResponseException.getResponseBodyAsString()));\n\t\t\tthrow new ExternalServiceException("empRegException-" + webClientResponseException.getMessage());\n\n\t\t} catch (Exception exception) {\n\t\t\tlog.error("Employee Registration Service Failure Response", v("webClientResponse", exception.getMessage()));\n\t\t\tthrow new ExternalServiceException("empRegException-" + exception.getMessage());\n\n\t\t}\n\t\treturn empList;\n\t}\n\n\tprivate boolean isConnectionTimeout(Throwable throwable) {\n\n\t\tboolean isConnectionTimeout = false;\n\t\tboolean isUnknownHost = false;\n\t\tif (throwable instanceof WebClientRequestException) {\n\t\t\tWebClientRequestException excep = (WebClientRequestException) throwable;\n\t\t\tif (excep.contains(ConnectTimeoutException.class)) {\n\t\t\t\tisConnectionTimeout = true;\n\t\t\t} else if (excep.contains(UnknownHostException.class)) {\n\t\t\t\tisUnknownHost = true;\n\t\t\t}\n\t\t} else {\n\t\t\tisConnectionTimeout = throwable instanceof ConnectTimeoutException;\n\t\t\tisUnknownHost = throwable instanceof UnknownHostException;\n\t\t}\n\n\t\treturn isConnectionTimeout || isUnknownHost;\n\n\t}\n\n}\n\n```\n\n** Configuration File**\n\n```jsx\nserver:\n  port: 8081\n\nspring:\n application:\n  name: praveenoruganti-emp-reg-consumer\n\n  \nspringdoc:\n   use-fqn: true\n   swagger-ui:\n    doc-expansion: none\n    operationsSorter: method\n#   supportedSubmitMethods: []\n\n\napp:\n openApiTitle: Employee Registration Consumer using OAuth2\n openApiDescription: |\n   \n       Employee Registration Consumer using OAuth2\n empRegApiEndpoint: /api/v1_0/employees\n empRegApiHost:  http://localhost:8080\n connectionTimeout: 200\n readTimeout: 1000\n retryAttempts: 1\n backOffTimeInMillisec: 25\n oauth:\n   clientId: praveenorugantitech\n   clientSecret: passionfortech\n   grantType: client_credentials\n   scope: read write\n   tokenUri: http://localhost:8080/oauth/token\n \n\n```\n\n**WebClient Config Class**\n\n```jsx\n@Configuration\n@AllArgsConstructor\npublic class WebClientConfiguration {\n\tprivate final ApplicationConfig appConfig;\n\n\t@Bean\n\tpublic WebClient empRegServiceForFetchEmployees() {\n\t\treturn WebClient.builder().clientConnector(new ReactorClientHttpConnector(createHttpClient()))\n\t\t\t\t.baseUrl(appConfig.getEmpRegApiHost() + appConfig.getEmpRegApiEndpoint()).build();\n\t}\n\t\n\t@Bean\n\tpublic WebClient tokenApi() {\n\t\treturn WebClient.builder().clientConnector(new ReactorClientHttpConnector(createHttpClient()))\n\t\t\t\t.baseUrl(appConfig.getOauth().getTokenUri()).build();\n\t}\n\n\tprivate HttpClient createHttpClient() {\n\t\treturn HttpClient.newConnection().resolver(DefaultAddressResolverGroup.INSTANCE)\n\t\t\t\t.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, appConfig.getConnectionTimeout())\n\t\t\t\t.doOnConnected(connection -> connection\n\t\t\t\t\t\t.addHandlerLast(new ReadTimeoutHandler(appConfig.getReadTimeout(), TimeUnit.MILLISECONDS)));\n\t}\n}\n\n```\n\n**Now Let\'s develop an another app with OAuth2 using JWT Token**\n\n**What are JWT Tokens?**\n\nJWT stands for JSON Web Tokens is a popular format for representing tokens.\n\nJWT Tokens are JSON encoded and it contains information about the issuer, claims, an algorithm used. These tokens are digitally signed and thus its integrity can be ensured.\n\nA typical JWT Token is a string divided into 3 periods. (Periods are.)\n\nXXXX.YYYYYY.ZZZZZ\n\nThe different parts are:\n\n- Header: It consists of the type and the algorithm used. This info is Base64Url encoded to form the header.\n- Payload: It consists of claims encoded in Base64Url.\n- Signature: The last part is constructed using encoded header, encoded payload, a secret key and the algorithm specified in the header. Since the secret key is only known to issuer, the token cannot be decoded and thus its integrity is ensured.\n\nFor example,\n\nConsider following JWT Token:\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwttoken.png)\n\nWe will develop project shortly where the tokens will be encoded in JWT.\n\n**Spring OAuth2 Implementation**\n\nIn Spring implementation of OAuth2 is divided between Authorization-Server and Resource-Server.\n\nThey can reside in the same application or be 2 distinct applications.\n\n**Authorization Server**\n\n- This issues access tokens to the clients (3rd party apps) and verifies them.\n- For issuing tokens, token endpoints are provided (/oauth/token)\n- For authorizing the tokens, authorize endpoints are provided (/oauth/authorize).\n\n**Resource Server**\n\nResource server holds the resources/endpoints which can be accessed by the client(3rd party apps), only when granted by Authorization Server.\n\nFor protecting the resource server\u2019s APIs, Spring security adds OAuth2AuthenticationProcessingFilter in the spring security filter chain.\n\nThis filter checks the access token in the request, validates and authorizes it and then only request reaches Resource Server endpoints.\n\n**Lets develop a sample project with the below requirement.**\n\n- Implement OAuth2 using Spring Boot and Spring Security.\n- The access and refresh tokens will be JWT encoded.\n- Authentication will be done using OAuth2\n- Further, we will be implementing authorization too.\n- Resource server and Authorization server will run in a single instance.\n\n**Include below dependencies in pom.xml**\n\n```jsx\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security.oauth</groupId>\n    <artifactId>spring-security-oauth2</artifactId>\n    <version>2.5.1.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-jwt</artifactId>\n    <version>1.1.1.RELEASE</version>\n</dependency>\n```\n\n**Add below properties in application.yml**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/oauth2.png)\n\n**SpringBoot Main Class**\n\n```jsx\n@SpringBootApplication\npublic class DemoSecurityApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoSecurityApplication.class, args);\n\t}\n\n}\n\n```\n\n**Application Security Config**\n\n```jsx\n@Configuration\n@EnableWebSecurity\npublic class ApplicationSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Bean(name = BeanIds.AUTHENTICATION_MANAGER)\n\t@Override\n\tpublic AuthenticationManager authenticationManagerBean() throws Exception {\n\t\treturn super.authenticationManagerBean();\n\t}\n\n\t@SuppressWarnings("deprecation")\n\t@Bean\n\tpublic static NoOpPasswordEncoder passwordEncoder() {\n\treturn (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();\n\t}\n\n}\n\n```\n\n**Authorization server configuration**\n\n**AuthorizationServerConfig.java**\n\n```jsx\n\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n\t@Autowired\n\tprivate AuthenticationManager authenticationManager;\n\n\t@Autowired\n\tprivate UserDetailsService userDetailsService;\n\n\t// For signing JWT Token\n\t@Value("oauth2.signing.key")\n\tprivate String signingKey;\n\n\t@Bean\n\tpublic JwtAccessTokenConverter accessTokenConverter() {\n\t\tfinal JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();\n\t\taccessTokenConverter.setSigningKey(signingKey);\n\t\treturn accessTokenConverter;\n\t}\n\n\t/**\n\t * a configurer that defines the client details service Currently we are storing\n\t * clients in-memory\n\t */\n\t@Override\n\tpublic void configure(final ClientDetailsServiceConfigurer clients) throws Exception {\n\t\tclients.inMemory().withClient("client1").secret("secret").authorizedGrantTypes("password", "refresh_token")\n\t\t\t\t.scopes("read", "write").accessTokenValiditySeconds(100);\n\t}\n\n\t/**\n\t * defines the security constraints on the token endpoints.\n\t */\n\t@Override\n\tpublic void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n\t\tendpoints.authenticationManager(authenticationManager).userDetailsService(userDetailsService)\n\t\t\t\t.accessTokenConverter(accessTokenConverter());\n\t}\n}\n\n\n```\n\n- @EnableAuthorizationServer : is a convenience annotation which enables the Authorization server in the application and sets up authorization endpoints (/oauth/authorize) and token endpoints (/oauth/token).\n- JwtAccessTokenConverter - For encoding tokens using JWT. Also for signing JWT tokens, Authorization server will use the value in oauth2.signing.key. Since this signing key is only known to Authorization server, only he can sign it and verify its integrity.\n- ClientDetailsServiceConfigurer - Configures how clients (or 3rd party apps) are configured and stored. Currently, they are stored in memory. We have configured only 1 client, which will provide access tokens for grant-types (password - where a user provides his credentials and refresh_token - where a user provides refresh token value to regenerate access token). The access token issued will expire in 100 sec.\n- AuthorizationServerEndpointsConfigurer - It defines the security for the Authorization server endpoints.\n- For storing tokens JwtTokenStore is used, which doesn\u2019t really stores the tokens.\n\n**Resource Server Configuration**\n\n**ResourceServerConfig.java**\n\n```jsx\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter {\n\n\t/**\n\t * 1. public APIs can be accessed by any user, authenticated or not\n\t * 2. admin APIs can be accessed by authenticated users who possess the role ADMIN\n\t * 3. Remaining all APIs can only be accessed by authenticated users,irrespective of their roles\n\t */\n\t@Override\n\tpublic void configure(final HttpSecurity http) throws Exception {\n\t\thttp.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\t\thttp.authorizeRequests().antMatchers("/public/**").anonymous();\n\t\thttp.authorizeRequests().antMatchers("/admin/**").hasRole("ADMIN");\n\t\thttp.authorizeRequests().anyRequest().authenticated();\n\t\thttp.csrf().disable();\n\t\thttp.logout().disable();\n\t}\n}\n\n```\n\nEnableResourceServer - This enables the resource server which encompasses all the URLs which are not part of Authorization server. \n\nThis sets up OAuth2AuthenticationProcessingFilter - A pre-authentication filter for OAuth2 protected resources\n\n**Authentication Provider and User Services**\n\nIn this project, for the sake of simplicity, the users are stored in-memory and authentication is provided against them only.\n\n```jsx\n@Component\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n\tMap<String, User> userMap;\n\n\t@PostConstruct\n\tpublic void initUsers() {\n\t\t// admin@gmail.com -- admin -- role=ADMIN, so he is admin user\n\t\tUser adminUser = new User("admin@gmail.com", "admin", Arrays.asList(new SimpleGrantedAuthority("ROLE_ADMIN")));\n\t\t// normal@gmail.com -- normal -- role=NORMAL, so he is normal user\n\t\tUser normalUser = new User("normal@gmail.com", "normal",\n\t\t\t\tArrays.asList(new SimpleGrantedAuthority("ROLE_NORMAL")));\n\n\t\tuserMap = new HashMap<>();\n\t\tuserMap.put(adminUser.getUsername(), adminUser);\n\t\tuserMap.put(normalUser.getUsername(), normalUser);\n\t}\n\n\t@Override\n\tpublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\tUser user = userMap.get(username);\n\t\tif (null == user) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new User(username, user.getPassword(), user.getAuthorities());\n\t}\n\n}\n\n```\n\n```jsx\n@Component\npublic class CustomAuthenticationProvider implements AuthenticationProvider {\n\n\t@Autowired\n\tprivate UserDetailsService userDetailsService;\n\n\t@Override\n\tpublic Authentication authenticate(Authentication authentication) throws AuthenticationException {\n\t\tString username = authentication.getPrincipal().toString();\n\t\tString password = authentication.getCredentials().toString();\n\n\t\tUser user = (User) userDetailsService.loadUserByUsername(username);\n\t\tif (user == null) {\n\t\t\tthrow new UsernameNotFoundException("User not found :=" + username);\n\t\t}\n\n\t\tif (!user.getPassword().equals(password)) {\n\t\t\tthrow new BadCredentialsException("Invalid password");\n\t\t}\n\n\t\treturn new UsernamePasswordAuthenticationToken(username, password, user.getAuthorities());\n\t}\n\n\t@Override\n\tpublic boolean supports(Class<?> authentication) {\n\t\treturn true;\n\t}\n}\n\n```\n\n**Controllers**\n\nFor covering cases related to Authorization, we have defined 3 controllers providing APIs for resource server.\n\n1.AdminController: Its APIs can only accessed by authenticated users with role - ADMIN\n2.CommonController: Its APIs can only accessed by authenticated users with ANY role\n3.PublicController: Its APIs can be accessed by any user - authenticated and non-authenticated\n\nThis security configuration is provided in ResourceServer Configuration.\n\n```jsx\n@RestController\n@RequestMapping("admin")\npublic class AdminController {\n\n\t@RequestMapping(value = "", method = RequestMethod.GET)\n\tpublic Map<String, String> getAdminData() {\n\t\tMap<String, String> map = new HashMap<>();\n\t\tmap.put("1", "admin-value1");\n\t\tmap.put("2", "admin-value2");\n\t\treturn map;\n\t}\n}\n```\n\n**Try accessing /public/ API. It should be accessible without any restrictions.**\n\n```jsx\nGET http://localhost:8100/public\n{\n  "1": "pub-value-1",\n  "2": "pub-value-2"\n}\n\n```\n\n**Similarly try accessing any other URL (/commons or /admin). You should get access denied error.**\n\n```jsx\nGET http://localhost:8100/commons\n\n401\n{\n  "error": "unauthorized",\n  "error_description": "Full authentication is required to access this resource"\n}\n\n\n```\n\nThis is because, we cannot access these without access token.\n\n**Get access token**\n\nWe have to pass, clientId and client secret in Authorization header, set grant_type=password and also send the user credentials.\n\n**Sending improper credentials**\n\n```jsx\n\ncurl -X POST -u client1:secret -i"http://localhost:8100/oauth/token?grant_type=password&username=admin&password=xyz"\nHTTP/1.1401\n{\n  "error": "unauthorized",\n  "error_description": "User not found :=admin"\n}\n\n```\n\n**Sending proper credentials**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/oauth2-1.PNG)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/oauth2-2.PNG)\n\n```jsx\ncurl -X POST -u client1:secret -i"http://localhost:8100/oauth/token?grant_type=password&username=admin@gmail.com&password=admin"\n{\n  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTAwNDQsInVzZXJfbm  FtZSI6ImFkbWluQGdtYWlsLmNvbSIsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXSwian  RpIjoiMmRiMmUwM2YtMjFkYi00ZWQwLWEyZmMtZTExOWRkNjQ1OGNmIiwiY2xpZW50X2lkIj  oiY2xpZW50MSIsInNjb3BlIjpbInJlYWQiLCJ3cml0ZSJdfQ.-qFr_BMDuvt6UtQ68GZHGqnDjCHB6cf1FfSfpjjTvc8",\n  "token_type": "bearer",\n  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbkBnbWFpbC5jb20iLCJzY29wZSI6WyJyZWFkIiwid3JpdGUiXSwiYXRpIjoiMmRiMmUwM2YtMjFkYi00ZWQwLWEyZmMtZTExOWRkNjQ1OGNmIiwiZXhwIjoxNTM1NDAxOTQ0LCJhdXRob3JpdGllcyI6WyJST0xFX0FETUlOIl0sImp0aSI6IjVkOGU5OWY4LTM0OGUtNDMxZC1iODk2LTcyYzVhMGNkYmM3NiIsImNsaWVudF9pZCI6ImNsaWVudDEifQ.Xpygqx0heunlTJqWRUKA2TcoRDbpeDIkVQ3bykcDXr8",\n  "expires_in": 99,\n  "scope": "read write",\n  "jti": "2db2e03f-21db-4ed0-a2fc-e119dd6458cf"\n}\n\n\n```\n\n**Once access token is obtained, we can access the protected resources.**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/oauth2-3.PNG)\n\n```jsx\ncurl -X GET  --header "Authorization: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTAwNDQsInVzZXJfbmFtZSI6ImFkbWluQGdtYWlsLmNvbSIsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXSwianRpIjoiMmRiMmUwM2YtMjFkYi00ZWQwLWEyZmMtZTExOWRkNjQ1OGNmIiwiY2xpZW50X2lkIjoiY2xpZW50MSIsInNjb3BlIjpbInJlYWQiLCJ3cml0ZSJdfQ.-qFr_BMDuvt6UtQ68GZHGqnDjCHB6cf1FfSfpjjTvc8" -i"http://localhost:8100/admin"\n200 OK\n{\n  "1": "admin-value1",\n  "2": "admin-value2"\n}\n```\n\n**Once access token has expired (100 sec), trying to use to accessing the same resource shouldn\u2019t work. It should give token expired error.**\n\n```jsx\ncurl -X GET  --header "Authorization: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTAwNDQsInVzZXJfbmFtZSI6ImFkbWluQGdtYWlsLmNvbSIsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXSwianRpIjoiMmRiMmUwM2YtMjFkYi00ZWQwLWEyZmMtZTExOWRkNjQ1OGNmIiwiY2xpZW50X2lkIjoiY2xpZW50MSIsInNjb3BlIjpbInJlYWQiLCJ3cml0ZSJdfQ.-qFr_BMDuvt6UtQ68GZHGqnDjCHB6cf1FfSfpjjTvc8" -i"http://localhost:8100/admin"\nHTTP/1.1401\n{\n  "error": "invalid_token",\n  "error_description": "Access token expired: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTAwNDQsInVzZXJfbmFtZSI6ImFkbWluQGdtYWlsLmNvbSIsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXSwianRpIjoiMmRiMmUwM2YtMjFkYi00ZWQwLWEyZmMtZTExOWRkNjQ1OGNmIiwiY2xpZW50X2lkIjoiY2xpZW50MSIsInNjb3BlIjpbInJlYWQiLCJ3cml0ZSJdfQ.-qFr_BMDuvt6UtQ68GZHGqnDjCHB6cf1FfSfpjjTvc8"\n}\n```\n\n**We can use the refresh token we got earlier to regenerate the access token.**\n\n```jsx\ncurl -X POST -u client1:secret -i"http://localhost:8100/oauth/token?grant_type=refresh_token&refresh_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbkBnbWFpbC5jb20iLCJzY29wZSI6WyJyZWFkIiwid3JpdGUiXSwiYXRpIjoiMmRiMmUwM2YtMjFkYi00ZWQwLWEyZmMtZTExOWRkNjQ1OGNmIiwiZXhwIjoxNTM1NDAxOTQ0LCJhdXRob3JpdGllcyI6WyJST0xFX0FETUlOIl0sImp0aSI6IjVkOGU5OWY4LTM0OGUtNDMxZC1iODk2LTcyYzVhMGNkYmM3NiIsImNsaWVudF9pZCI6ImNsaWVudDEifQ.Xpygqx0heunlTJqWRUKA2TcoRDbpeDIkVQ3bykcDXr8"\nHTTP/1.1200\n{\n  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTEyNTgsInVzZXJfbmFtZSI6ImFkbWluQGdtYWlsLmNvbSIsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXSwianRpIjoiZmNhNjRjYjYtZWVkOC00YmY2LTliZDktYzQzMmJmYWE4OTA5IiwiY2xpZW50X2lkIjoiY2xpZW50MSIsInNjb3BlIjpbInJlYWQiLCJ3cml0ZSJdfQ.k3J0mVDyebLOKUiZvCXGkwlJaUHSfp4UGuNB99IuDJU",\n  "token_type": "bearer",\n  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbkBnbWFpbC5jb20iLCJzY29wZSI6WyJyZWFkIiwid3JpdGUiXSwiYXRpIjoiZmNhNjRjYjYtZWVkOC00YmY2LTliZDktYzQzMmJmYWE4OTA5IiwiZXhwIjoxNTM1NDAxOTQ0LCJhdXRob3JpdGllcyI6WyJST0xFX0FETUlOIl0sImp0aSI6IjVkOGU5OWY4LTM0OGUtNDMxZC1iODk2LTcyYzVhMGNkYmM3NiIsImNsaWVudF9pZCI6ImNsaWVudDEifQ.VwRILrmjExP-I7cKS9SfvSX21j3mN_sNpUqBYGTozO4",\n  "expires_in": 99,\n  "scope": "read write",\n  "jti": "fca64cb6-eed8-4bf6-9bd9-c432bfaa8909"\n}\n\n\n```\n\n**Let\u2019s check Authorization part (for normal User). Get access token for normal User**\n\n```jsx\ncurl -X POST -u client1:secret -i"http://localhost:8100/oauth/token?grant_type=password&username=normal@gmail.com&password=normal"\n{\n  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTIyNzksInVzZXJfbmFtZSI6Im5vcm1hbEBnbWFpbC5jb20iLCJhdXRob3JpdGllcyI6WyJST0xFX05PUk1BTCJdLCJqdGkiOiJlZGEwMGQwNS1hYTQ1LTQ1N2YtOTFlNC0wODdkNGE3ZTM5ZWMiLCJjbGllbnRfaWQiOiJjbGllbnQxIiwic2NvcGUiOlsicmVhZCIsIndyaXRlIl19.1YTL0ZWC0O9VfszVhgpomFXcTrldl3xqp8dn9BWU8qU",\n  "token_type": "bearer",\n  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJub3JtYWxAZ21haWwuY29tIiwic2NvcGUiOlsicmVhZCIsIndyaXRlIl0sImF0aSI6ImVkYTAwZDA1LWFhNDUtNDU3Zi05MWU0LTA4N2Q0YTdlMzllYyIsImV4cCI6MTUzNTQwNDE3OSwiYXV0aG9yaXRpZXMiOlsiUk9MRV9OT1JNQUwiXSwianRpIjoiNTg4NWY0Y2EtNTczZC00ZmUxLWJmNjItMTY3ZDVlNDY0NDliIiwiY2xpZW50X2lkIjoiY2xpZW50MSJ9.UipHQRf3IURJY2sZhch8QwKcZXM0y_s80az6vSXsX0Y",\n  "expires_in": 99,\n  "scope": "read write",\n  "jti": "eda00d05-aa45-457f-91e4-087d4a7e39ec"\n}\n```\n\n**Use the access token to access commons API**\n\n```jsx\ncurl -X GET  --header "Authorization: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTIyNzksInVzZXJfbmFtZSI6Im5vcm1hbEBnbWFpbC5jb20iLCJhdXRob3JpdGllcyI6WyJST0xFX05PUk1BTCJdLCJqdGkiOiJlZGEwMGQwNS1hYTQ1LTQ1N2YtOTFlNC0wODdkNGE3ZTM5ZWMiLCJjbGllbnRfaWQiOiJjbGllbnQxIiwic2NvcGUiOlsicmVhZCIsIndyaXRlIl19.1YTL0ZWC0O9VfszVhgpomFXcTrldl3xqp8dn9BWU8qU" -i"http://localhost:8100/commons"\n200 OK\n{"1":"common-value-1","2":"common-value-2"}\n```\n\nHe should be able to access it, since it\u2019s meant for all authenticated users irrespective of role.\n\n**Use the access token to access Admin API**\n\n```jsx\ncurl -X GET  --header "Authorization: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MzI4MTIyNzksInVzZXJfbmFtZSI6Im5vcm1hbEBnbWFpbC5jb20iLCJhdXRob3JpdGllcyI6WyJST0xFX05PUk1BTCJdLCJqdGkiOiJlZGEwMGQwNS1hYTQ1LTQ1N2YtOTFlNC0wODdkNGE3ZTM5ZWMiLCJjbGllbnRfaWQiOiJjbGllbnQxIiwic2NvcGUiOlsicmVhZCIsIndyaXRlIl19.1YTL0ZWC0O9VfszVhgpomFXcTrldl3xqp8dn9BWU8qU" -i"http://localhost:8100/admin"\nHTTP/1.1403\n{"error":"access_denied","error_description":"Access is denied"}\n```\n\nThis is because the user only has ROLE_NORMAL, but ROLE_ADMIN is needed to access the admin APIs. Thus authorization config is working fine.\n\nWe used grant_type=password (where user needs to provide access token to receive access token) and grant_type=refresh_token (where user provides refresh token to generate the access token value). In addition to OAuth2 implementation, we also applied authorization to our resource server endpoints.\n\n\n\n\n\n\n\n\n '}}]);