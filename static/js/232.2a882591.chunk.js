(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[232],{801:function(e,n,t){"use strict";t.r(n),n.default=' JWT stands for JSON Web Token. JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. \n\nThis information can be verified and trusted because it is digitally signed. The client will need to authenticate with the server using the credentials only once. \n\nDuring this time the server validates the credentials and returns the client a JSON Web Token(JWT). \n\nFor all future requests the client can authenticate itself to the server using this JSON Web Token(JWT) and so does not need to send the credentials like username and password.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt1.PNG)\n\nDuring the first request the client sends a POST request with username and password. \n\nUpon successful authentication the server generates the JWT sends this JWT to the client. This JWT can contain a payload of data. \n\nOn all subsequent requests the client sends this JWT token in the header. Using this token the server authenticates the user. So we don\'t need the client to send the user name and password to the server during each request for authentication, but only once after which the server issues a JWT to the client. \n\nA JWT payload can contain things like user ID so that when the client again sends the JWT, you can be sure that it is issued by you, and you can see to whom it was issued.\n\nJWT has the following format **header.payload.signature**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt2.PNG)\n\nAn important point to remember about JWT is that the information in the payload of the JWT is visible to everyone. \n\nSo we should not pass any sensitive information like passwords in the payload. \n\nWe can encrypt the payload data if we want to make it more secure. \n\nHowever we can be sure that no one can tamper and change the payload information. If this is done the server will recognize it.\n\nLets develop a sample application for better understanding\n\nWe will be configuring Spring Security and JWT for performing 2 operations\n\n- **Generating JWT** - Expose a POST API with mapping /authenticate. On passing correct username and password it will generate a JSON Web Token(JWT)\n- **Validating JWT** - If user tries to access GET API with mapping /api/v1/students. It will allow access only if request has a valid JSON Web Token(JWT)\n\n**Generating JWT**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt3.PNG)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt4.PNG)\n\n**Validating JWT**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt5.PNG)\n\n**Define the application.yml**\n\nThe secret key is combined with the header and the payload to create a unique hash. We are only able to verify this hash if you have the secret key.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt6.png)\n\n**JwtTokenUtil**\n\nThe JwtTokenUtil is responsible for performing JWT operations like creation and validation.It makes use of the io.jsonwebtoken.Jwts for achieving this.\n\n```jsx\n@Component\npublic class JwtTokenUtil implements Serializable {\n\n    private static final long serialVersionUID = 3997520832076584955L;\n\n    public static final long JWT_TOKEN_VALIDITY = 5*60*60;\n\n    @Value("jwt.secret")\n    private String secret;\n\n    public String getUsernameFromToken(String token) {\n        return getClaimFromToken(token, Claims::getSubject);\n    }\n\n    public Date getIssuedAtDateFromToken(String token) {\n        return getClaimFromToken(token, Claims::getIssuedAt);\n    }\n\n    public Date getExpirationDateFromToken(String token) {\n        return getClaimFromToken(token, Claims::getExpiration);\n    }\n\n    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {\n        final Claims claims = getAllClaimsFromToken(token);\n        return claimsResolver.apply(claims);\n    }\n\n    private Claims getAllClaimsFromToken(String token) {\n        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\n    }\n\n    private Boolean isTokenExpired(String token) {\n        final Date expiration = getExpirationDateFromToken(token);\n        return expiration.before(new Date());\n    }\n\n    private Boolean ignoreTokenExpiration(String token) {\n        // here you specify tokens, for that the expiration is ignored\n        return false;\n    }\n\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        return doGenerateToken(claims, userDetails.getUsername());\n    }\n\n    private String doGenerateToken(Map<String, Object> claims, String subject) {\n\n        return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt\n                (new Date(System.currentTimeMillis()))\n                .setExpiration(new Date(System.currentTimeMillis() \n    + JWT_TOKEN_VALIDITY*1000)).signWith(SignatureAlgorithm.HS512, secret).compact();\n    }\n\n    public Boolean canTokenBeRefreshed(String token) {\n        return (!isTokenExpired(token) || ignoreTokenExpiration(token));\n    }\n\n    public Boolean validateToken(String token, UserDetails userDetails) {\n        final String username = getUsernameFromToken(token);\n        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));\n    }\n}\n\n\n```\n\n**JWTUserDetailsService**\n\nJWTUserDetailsService implements the Spring Security UserDetailsService interface. It overrides the loadUserByUsername for fetching user details from the database using the username. The Spring Security Authentication Manager calls this method for getting the user details from the database when authenticating the user details provided by the user. Also the password for a user is stored in encrypted format using BCrypt.\n\n```jsx\n@Service\npublic class JwtUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws\n UsernameNotFoundException {\n        if ("praveen".equals(username)) {\n            return new User("praveen", "$2a$10$HDuOKL45DZAyNLuNFwYvS.HvGadnj\nFGc0Pvy39QEJsn6QB1V1U.ZO",\n                    new ArrayList<>());\n        } else {\n            throw new UsernameNotFoundException("User not found with username: " \n+ username);\n        }\n    }\n\n}\n\n```\n\n**JwtAuthenticationController**\n\nExpose a POST API /authenticate using the JwtAuthenticationController. The POST API gets username and password in the body- Using Spring Authentication Manager we authenticate the username and password.If the credentials are valid, a JWT token is created using the JWTTokenUtil and provided to the client.\n\n```jsx\n@RestController\n@CrossOrigin\npublic class JwtAuthenticationController {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private UserDetailsService jwtInMemoryUserDetailsService;\n\n    @RequestMapping(value = "/authenticate", method = RequestMethod.POST)\n    public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequest\n authenticationRequest)\n            throws Exception {\n\n        authenticate(authenticationRequest.getUsername(), authenticationRequest.\ngetPassword());\n\n        final UserDetails userDetails = jwtInMemoryUserDetailsService\n                .loadUserByUsername(authenticationRequest.getUsername());\n\n        final String token = jwtTokenUtil.generateToken(userDetails);\n\n        return ResponseEntity.ok(new JwtResponse(token));\n    }\n\n    private void authenticate(String username, String password) throws Exception {\n        Objects.requireNonNull(username);\n        Objects.requireNonNull(password);\n\n        try {\n            authenticationManager.authenticate(new \nUsernamePasswordAuthenticationToken(username, password));\n        } catch (DisabledException e) {\n            throw new Exception("USER_DISABLED", e);\n        } catch (BadCredentialsException e) {\n            throw new Exception("INVALID_CREDENTIALS", e);\n        }\n    }\n}\n\n```\n\n**JwtRequest**\n\nThis class is required for storing the username and password we recieve from the client.\n\n```jsx\npublic class JwtRequest implements Serializable {\n\n    private static final long serialVersionUID = -8651526166784406382L;\n    private String username;\n    private String password;\n    \n    //need default constructor for JSON Parsing\n    public JwtRequest()\n    {\n        \n    }\n\n    public JwtRequest(String username, String password) {\n        this.setUsername(username);\n        this.setPassword(password);\n    }\n\n    public String getUsername() {\n        return this.username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return this.password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n\n```\n\n**JwtResponse**\n\nThis is class is required for creating a response containing the JWT to be returned to the user.\n\n```jsx\npublic class JwtResponse implements Serializable {\n\n    private static final long serialVersionUID = -3951183088604857416L;\n    private final String jwttoken;\n\n    public JwtResponse(String jwttoken) {\n        this.jwttoken = jwttoken;\n    }\n\n    public String getToken() {\n        return this.jwttoken;\n    }\n}\n\n```\n\n**JwtRequestFilter**\n\nThe JwtRequestFilter extends the Spring Web Filter OncePerRequestFilter class. For any incoming request this Filter class gets executed. It checks if the request has a valid JWT token. If it has a valid JWT Token then it sets the Authentication in the context, to specify that the current user is authenticated.\n\n```jsx\n@Component\npublic class JwtRequestFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private JwtUserDetailsService jwtUserDetailsService;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, \nHttpServletResponse response, FilterChain chain)\n            throws ServletException, IOException {\n\n        final String requestTokenHeader = request.getHeader("Authorization");\n\n        String username = null;\n        String jwtToken = null;\n        // JWT Token is in the form "Bearer token". Remove Bearer word and get \nonly the Token\n        if (requestTokenHeader != null && requestTokenHeader.startsWith("Bearer ")) {\n            jwtToken = requestTokenHeader.substring(7);\n            try {\n                username = jwtTokenUtil.getUsernameFromToken(jwtToken);\n            } catch (IllegalArgumentException e) {\n                System.out.println("Unable to get JWT Token");\n            } catch (ExpiredJwtException e) {\n                System.out.println("JWT Token has expired");\n            }\n        } else {\n            logger.warn("JWT Token does not begin with Bearer String");\n        }\n\n        //Once we get the token validate it.\n        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n\n            UserDetails userDetails = this.jwtUserDetailsService.\nloadUserByUsername(username);\n\n            // if token is valid configure Spring Security to manually \nset authentication\n            if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {\n\n                UsernamePasswordAuthenticationToken \nusernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(\n                        userDetails, null, userDetails.getAuthorities());\n                usernamePasswordAuthenticationToken\n                        .setDetails(new WebAuthenticationDetailsSource()\n.buildDetails(request));\n                // After setting the Authentication in the context, we specify\n                // that the current user is authenticated. So it passes the \nSpring Security Configurations successfully.\n                SecurityContextHolder.getContext().\nsetAuthentication(usernamePasswordAuthenticationToken);\n            }\n        }\n        chain.doFilter(request, response);\n    }\n\n}\n\n```\n\n**JwtAuthenticationEntryPoint**\n\nThis class will extend Spring\'s AuthenticationEntryPoint class and override its method commence. It rejects every unauthenticated request and send error code 401.\n\n```jsx\n@Component\npublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint, \nSerializable {\n\n    private static final long serialVersionUID = -5445144020238051L;\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response,\n            AuthenticationException authException) throws IOException {\n\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");\n    }\n}\n\n```\n\n**ApplicationSecurityConfig**\n\nThis class extends the WebSecurityConfigurerAdapter is a convenience class that allows customization to both WebSecurity and HttpSecurity.\n\n```jsx\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class ApplicationSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\n\n    @Autowired\n    private UserDetailsService jwtUserDetailsService;\n\n    @Autowired\n    private JwtRequestFilter jwtRequestFilter;\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        // configure AuthenticationManager so that it knows from where to load\n        // user for matching credentials\n        // Use BCryptPasswordEncoder\n        auth.userDetailsService(jwtUserDetailsService).\npasswordEncoder(passwordEncoder());\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n        // We don\'t need CSRF for this example\n        httpSecurity.csrf().disable()\n                // dont authenticate this particular request\n                .authorizeRequests().antMatchers("/authenticate").permitAll()\n                .antMatchers("/").permitAll().\n                // all other requests need to be authenticated\n                anyRequest().authenticated().and().\n                // make sure we use stateless session; session won\'t be used to\n                // store user\'s state.\n                exceptionHandling().authenticationEntryPoint\n(jwtAuthenticationEntryPoint).and().sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\n        // Add a filter to validate the tokens with every request\n        httpSecurity.addFilterBefore(jwtRequestFilter, \nUsernamePasswordAuthenticationFilter.class);\n    }\n\n}\n\n```\n\n**Generate a JSON Web Token**\n\nCreate a POST request with url [http://localhost:8080/authenticate](http://localhost:8080/authenticate). Body should have valid username and password. In our case username is **praveen** and password is **password123**.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt7.PNG)\n\n**Validate the JSON Web Token**\n\nTry accessing the url [http://localhost:8080/api/v1/students](http://localhost:8080/api/v1/students) using the above generated token in the header as follows\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/springboot/jwt8.PNG) '}}]);