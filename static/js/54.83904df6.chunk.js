(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[54],{623:function(e,t,n){"use strict";n.r(t),t.default=' It is a type of structural design pattern.\n\nThere are times when you feel a need of a tree data structure in your code. There are many variations to the tree data structure, but sometimes there is a need of a tree in which both branches as well as leafs of the tree should be treated as uniformly.\n\nThe Composite Pattern allows you to compose objects into a tree structure to represent the part-whole hierarchy which means you can create a tree of objects that is made of different parts, but that can be treated as a whole one big thing. **Composite lets clients to treat individual objects and compositions of objects uniformly, that`s the intent of the Composite Pattern.**\n\nIn the composite pattern, a tree structure exists where identical operations can be performed on leaves and nodes. A node in a tree is a class that can have children. A node\nclass is a `composite` class. A leaf in a tree is a `primitive` class that does not have children. The children of a composite can be leaves or other composites.\n\nThe leaf class and the composite class share a common `component` interface that defines the common operations that can be performed on leaves and composites. When an\noperation on a composite is performed, this operation is performed on all children of the composite, whether they are leaves or composites. Thus, the composite pattern can be\nused to perform common operations on the objects that compose a tree.\n\nIn Other words, Composite Pattern consists of following objects.\n\n**Base Component** \u2013 Base component is the interface for all objects in the composition, client program uses base component to work with the objects in the composition. It can be an interface or an abstract class with some methods common to all the objects. \n\n**Leaf** \u2013 Defines the behavior for the elements in the composition. It is the building block for the composition and implements base component. It doesn\u2019t have references to other Components.\n\n**Composite** \u2013 It consists of leaf elements and implements the operations in base component.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/composute.jpg)\n\n\n```jsx\npackage com.praveen.designpatterns.structural.composite;\n\n/*\n * Manager(Composite)\n * Developer(Leaf)\n * Employee(Component)\n */\npublic interface Employee {\n\n\tvoid add(Employee emp);\n\n\tvoid remove(Employee emp);\n\n\tEmployee getChild(int i);\n\n\tString getName();\n\n\tdouble getSalary();\n\n\tvoid print();\n\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.structural.composite;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Manager implements Employee {\n\n\tprivate String name;\n\tprivate double salary;\n\n\tpublic Manager(String name, double salary) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.salary = salary;\n\t}\n\n\tList<Employee> employees = new ArrayList<>();\n\n\t@Override\n\tpublic void add(Employee emp) {\n\t\temployees.add(emp);\n\n\t}\n\n\t@Override\n\tpublic void remove(Employee emp) {\n\t\temployees.remove(emp);\n\n\t}\n\n\t@Override\n\tpublic Employee getChild(int i) {\n\t\treturn employees.get(i);\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\t@Override\n\tpublic void print() {\n\t\tSystem.out.println("--------------");\n\t\tSystem.out.println("Name " + getName());\n\t\tSystem.out.println("Salary " + getSalary());\n\t\tSystem.out.println("--------------");\n\t\tIterator<Employee> empIterator = employees.iterator();\n\t\twhile (empIterator.hasNext()) {\n\t\t\tEmployee emp = empIterator.next();\n\t\t\temp.print();\n\t\t}\n\n\t}\n\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.structural.composite;\n\npublic class Developer implements Employee {\n\n\tprivate String name;\n\tprivate double salary;\n\n\tpublic Developer(String name, double salary) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.salary = salary;\n\t}\n\n\t@Override\n\tpublic void add(Employee emp) {\n\t\t// this is leaf node so this method is not applicable for this class\n\t}\n\n\t@Override\n\tpublic void remove(Employee emp) {\n\t\t// this is leaf node so this method is not applicable for this class\n\n\t}\n\n\t@Override\n\tpublic Employee getChild(int i) {\n\t\t// this is leaf node so this method is not applicable for this class\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\t@Override\n\tpublic void print() {\n\t\tSystem.out.println("--------------");\n\t\tSystem.out.println("Name " + getName());\n\t\tSystem.out.println("Salary " + getSalary());\n\t\tSystem.out.println("--------------");\n\n\t}\n\n}\n\n```\n\n```jsx\npackage com.praveen.designpatterns.structural.composite;\n\npublic class CompositePatternTest {\n\n\tpublic static void main(String[] args) {\n\n\t\tEmployee emp1 = new Developer("Kiran", 80000);\n\t\tEmployee emp2 = new Developer("Avinash", 50000);\n\n\t\tEmployee manager1 = new Manager("Praveen", 300000);\n\t\tmanager1.add(emp1);\n\t\tmanager1.add(emp2);\n\n\t\tEmployee emp3 = new Developer("Ravi", 60000);\n\n\t\tEmployee generalManager = new Manager("Pradeep", 500000);\n\t\tgeneralManager.add(emp3);\n\t\tgeneralManager.add(manager1);\n\t\tgeneralManager.print();\n\n\t}\n\n}\n\n\n```\n\n**Output**\n\n```jsx\n--------------\nName Pradeep\nSalary 500000.0\n--------------\n--------------\nName Ravi\nSalary 60000.0\n--------------\n--------------\nName Praveen\nSalary 300000.0\n--------------\n--------------\nName Kiran\nSalary 80000.0\n--------------\n--------------\nName Avinash\nSalary 50000.0\n--------------\n```\n\n### When to use Composite Pattern\n- When you want to represent part-whole hierarchies of objects.\n- When you want clients to be able to ignore the difference between compositions of objects and individual objects. Clients will treat all objects in the composite structure\nuniformly.\n\n\n### Composite Design Pattern in JDK\n\n- java.awt.Container#add (Component) is a great example of Composite pattern in java and used a lot in Swing . '}}]);