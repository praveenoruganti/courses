(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[165],{734:function(e,o,n){"use strict";n.r(o),o.default=" Microservices are small, loosely coupled applications or services that can fail independently from each other.\n\nWhen a microservice fails, only a single function or process in the system should become unavailable, while the rest of the system remains unaffected.\n\n**Principles of Microservices**\n\n- Microservices should not share code or data.\n- Avoid unnecessary coupling between services and software components.\n- Independence and autonomy are more important than code reusability.\n- Each Microservice should be responsible for a single system function or process.\n- Microservices should not communicate directly with each other, they should make use of an event/message bus to communicate with one another.\n\nEach Microservice should be able to provide unique business context.\n\nGenerally, it is implemented as a REST service on HTTP protocol, with technology-agnostic APIs.\nIdeally, it does not share database with any other service.\n\n**Microservices are**\n\n- REST\n- and Small Well Chosen deployable Units\n- and Cloud Enabled\n\n\n**Microservice shall be defined as highly scalable, highly reliable, event driven/feature completion server side component with well defined unique business capability as its unit of work/Single Responsibility, which can be exposed through largely APIs.**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/micro.jpg)\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/micro1.jpg)\n\n**Challenges of Microservices**\n\n- Bounded Context\n- Configuration Management\n- Dynamic Scale up and Scale down \u2013 we will use Eureka,Ribbon.\n- Visibility \u2013 we will use Zipkin(using sleuth for generated id for each request) and Zuul\n- Pack of Cards \u2013 Not well designed \u2013 Fault tolerance i.e. using Hystrix.\n\nSpring Cloud solves the above challenges of microservices\xa0by using Netflix Eureka for service registry and discovery which is known as Naming Server ,Spring Cloud config which provides central GIT location for all the configuration files, Spring cloud sleuth for distributed tracing, Netflix Hystrix for fault tolerance which acts as circuit breaker, Netflix Ribbon for Client side load balancing and Netflix Zuul is a gateway service that provides dynamic routing, monitoring, resiliency, security.\n\n**What is Bounded Context?**\n\nA bounded context is like a specific responsibility that is developed within a boundary. In a domain there can be multiple bounded contexts that are internally implemented. Eg. A hospital system can have bounded contexts like- Emergency Ward handling, Regular vaccination, Out patient treatment etc. Within each bounded context, each sub-system can be independently designed and implemented.\n\n**Advantages of Microservices**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/microservice.png)\n\n**Why Microservices?**\n\nTo build reliable business system.\n\n**Is it a good idea for Microservices to share a common database?**\n\nSharing a common database between multiple Microservices increases coupling between them. One service can start accessing data tables of another service. This can defeat the purpose of bounded context. So it is not a good idea to share a common\ndatabase between Microservices.\n\n**What are the disadvantages of using Shared libraries approach to decompose a monolith application?**\n\n- You can create shared libraries to increase reuse and sharing of features among teams. But there are some downsides to it.\n- Since shared libraries are implemented in same language, it constrains you from using multiple types of technologies.\n- It does not help you with scaling the parts of system that need better performance.\n- Deployment of shared libraries is same as deployment of Monolith application, so it comes with same deployment issues.\n- Shared libraries introduce shared code that can increase coupling in software.\n\n**What is the preferred type of communication between Microservices? Synchronous or Asynchronous?**\n\n- Synchronous communication is a blocking call in which client blocks itself from doing anything else, till the response comes back.In Asynchronous communication, client can move ahead with its work after making an asynchronous call. Therefore client is not blocked.\n- In synchronous communication, a Microservice can provide instant response about success or failure. In real-time systems, synchronous service is very useful. In Asynchronous communication, a service has to react based on the response received in future.\n- Synchronous systems are also known as request/response based. Asynchronous systems are event-based.\n- Synchronous Microservices are not loosely coupled.\n- Depending on the need and critical nature of business domain, Microservices can choose synchronous or asynchronous form of communication.\n\n**SOA vs Microservices**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/microservice1.png)\n\nService Oriented Architecture (SOA) is an approach to develop software by creating multiple services. It creates small parts of services and promotes reusability of software. But SOA development can be slow due to use of things like communication protocols SOAP, middleware and lack of principles.\n\nOn the other hand, Microservices are agnostic to most of these things. You can use any technology stack, any hardware/middleware, any protocol etc. as long as you follow the principles of Microservices. Microservices architecture also provides more flexibility, stability and speed of development over SOA architecture.\n\n**What is the difference between Orchestration and Choreography in Microservices architecture?**\n\n- In Orchestration, we rely on a central system to control and call various Microservices to complete a task. In Choreography, each Microservice works like a State Machine and reacts based on the input from other parts.\n- Orchestration is a tightly coupled approach for integrating Microservices. But Choreography introduces loose coupling. Also, Choreography based systems are more flexible and easy to change than Orchestration based systems.\n- Orchestration is often done by synchronous calls. But choreography is done by asynchronous calls. The synchronous calls are much simpler compared to asynchronous communication.\n\n**Can we create Microservices as State Machines?**\n\nYes, Microservices are independent entities that serve a specific context. For that context, the Microservice can work as a State Machine. In a State Machine, there are lifecycle events that cause change in the state of the system.\n\nFor Example, In a Library service, there is a book that changes state based on different events like- issue a book, return a book, lose a book, late return of a book, add a new book to catalog etc. These events and book can form a state machine for Library Microservice.\n\n**12 Factor App**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/microservice2.png)\n\n12 factor app (twelve-factor app) is a methodology for building distributed applications that run in the cloud and are delivered as a service. The approach was developed by Adam Wiggins, the co-founder of Heroku, a platform-as-a-service which is now part of Salesforce.com: The Customer Success Platform To Grow Your Business. Wiggin's goal was to synthesize best practices for deploying an app on Horoku and provide developers who are new to the cloud with a framework for discussing the challenges of native cloud applications.\n\nAlthough some factors may seem self-evident to developers today, interest in developing apps that adhere to common best practices continues to grow with the rise of micro-services and applications that are composed of loosely-coupled web services.\n\n**12 factors developers should think about when building native cloud apps**\n\n1. **Codebase**: All application code and server provisioning information should be in version control. Each microservice should have its own independent code repository\nwithin the source control systems.\n2. **Dependencies**: Explicitly declare the dependencies your application uses through build tools such as Maven (Java). Third-party JAR dependence should be declared\nusing their specific version numbers. This allows your microservice to always be built using the same version of libraries.\n3. **Config**: Store your application configuration (especially your environment-specific configuration) independently from your code. Your application configuration should\nnever be in the same repository as your source code.\n4. **Backing services**: Your microservice will often communicate over a network to a database or messaging system. When it does, you should ensure that at any time, you\ncan swap out your implementation of the database from an in-house managed service to a third-party service.\n5. **Build, release, run**: Keep your build, release, and run pieces of deploying your application completely separate. Once code is built, the developer should never make\nchanges to the code at runtime. Any changes need to go back to the build process and be redeployed. A built service is immutable and cannot be changed.\n6. **Processes**: Your microservices should always be stateless. They can be killed and replaced at any timeout without the fear that a loss-of-a-service instance will result in\ndata loss.\n7. **Port binding**: A microservice is completely self-contained with the runtime engine for the service packaged in the service executable. You should run the service without\nthe need for a separated web or application server. The service should start by itself on the command line and be accessed immediately through an exposed HTTP port.\n8. **Concurrency**: When you need to scale, don't rely on a threading model within a single service. Instead, launch more microservice instances and scale out horizontally. This\ndoesn't preclude using threading within your microservice, but don't rely on it as your sole mechanism for scaling. Scale out, not up.\n9. **Disposability**: Microservices are disposable and can be started and stopped on demand. Startup time should be minimized and processes should shut down gracefully\nwhen they receive a kill signal from the operating system. \n10. **Dev/prod parity**: Minimize the gaps that exist between all of the environments in which the service runs (including the developer's desktop). A developer should use\nthe same infrastructure locally for the service development in which the actual service will run. It also means that the amount of time that a service is deployed between\nenvironments should be hours, not weeks. As soon as code is committed, it should be tested and then promoted as quickly as possible from Dev all the way to Prod.\n11. **Logs**: Logs are a stream of events. As logs are written out, they should be streamable to tools, such as Splunk or Fluentd , that will collate the logs and write them to a central location. The microservice should never be concerned about the mechanics of how this happens and the developer\nshould visually look at the logs via STDOUT as they're being written out.\n12. **Admin processes**: Developers will often have to do administrative tasks against their services (data migration or conversion). These tasks should never be ad hoc and\ninstead should be done via scripts that are managed and maintained through the source code repository. These scripts should be repeatable and non-changing (the script code isn't modified for each environment) across each environment they're run against.\n\n**The 12-factor basics**\n\nWhen a developer uses the twelve-factor app DevOps methodology, applications will have certain characteristics in common that address a variety of scenarios as an app scales. For example, the methodology recommends that apps use declarative formats for setup automation to assist new developers that enter the project at a later time.\n\nApps should also be written to have maximum portability between execution environments and scale easily without significant reworking. Twelve-factor apps can be written in any programming language and in combination with any back-end service, such as a database.\nThe goal of the twelve-factor framework is to help developers build apps that use an architecture that ensures speed, reliability, agility, portability and ultimately results in a robust and reliable application.\n\nAny developer building cloud-based applications, most of which run as a service, should familiar with the 12 factors.\n\n**Benefits of 12-factor app methodology**\n\n- This method shows a path to follow for the development.\n- It avoids the confusion and saves time.\n- The project can be handled more efficiently by adopting this method.\n- Time and resource management can be done appropriately with this method.\n- Deployment date is handled properly.\n- End minute changes can be done easily.\n- The method suits perfectly with cloud platforms and other operating systems as well.\n\nTo implement the above 12 Factor App we need a Cloud.\n\nNow a days Cloud Computing and Microservice are becoming very popular and almost all the organizations are investing and adapting it very fast.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/microservice3.png)\n\nWith cloud computing, cloud service vendors provide three kinds of models for us to use: IaaS, PaaS, and SaaS.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/microservice/cloud.jpg)\n\n\ud835\udc08\ud835\udc1a\ud835\udc1a\ud835\udc12 provides us access to cloud vendors' infrastructure, like servers,storage, and networking. We pay for the infrastructure service and install and manage supporting software on it for our application.\n\n\ud835\udc0f\ud835\udc1a\ud835\udc1a\ud835\udc12 goes further. It provides a platform with a variety of middleware, frameworks, and tools to build our application. We only focus on application development and data.\n\n\ud835\udc12\ud835\udc1a\ud835\udc1a\ud835\udc12 enables the application to run in the cloud. We pay a monthly or annual fee to use the SaaS product.\n\n "}}]);