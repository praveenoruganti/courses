(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[211],{780:function(n,e,t){"use strict";t.r(e),e.default=" ![screenshot of the app](https://praveenoruganti.github.io/courses/images/spring/springcomponentannotations.jpg)\n\nAnnotation injection is performed before XML injection. Thus XML configuration will override that.\n\n## Core Spring framework Annotations\n\n- @Required\n  This annotation is applied on bean setter methods. Consider if you need to enforce a required property at configuration time if it is not set BeanInitializationException is thrown.\n- @Autowired\n  This annotation is applied on fields,setter methods and constructors.This annotation injects object dependency implicitly.\n- @Qualifier\n  This annotation is used along with @Autowired when you need more control of the dependency injection process.\n  This annotation is used to avoid confusion which occurs when you create more than one bean of the same type and want to wire only one of them with a property.\n\nFor example,\n\n```jsx\npublic interface Vehicle {\n   public void start();\n   public void stop();\n}\n@Component(value=\u201dcar\u201d) or can be denoted as @Component @Qualifier(\u201ccar\u201d)\npublic class Car implements Vehicle {\n@Override\npublic void start(){\nSystem.out.println(\u201cCar Started\u201d);\n}\n@Override\npublic void stop(){\nSystem.out.println(\u201cCar Stopped\u201d);\n}\n}\n@Component(value=\u201dbike\u201d)\npublic class Bike implements Vehicle {\n@Override\npublic void start(){\nSystem.out.println(\u201cBike Started\u201d);\n}\n@Override\npublic void stop(){\nSystem.out.println(\u201cBike Stopped\u201d);\n}\n}\n@Component\npublic class VehicleService {\n@Autowired\n@Qualifier(\u201cbike\u201d)\nprivate Vehicle vehicle;\npublic void service(){\nvehicle.start();\nvehicle.stop();\n}\n}\n\n\n```\n\n- @Primary\n\nIndicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency. If exactly one 'primary' bean exists among the candidates, it will be the autowired value.\n\nMay be used on any class directly or indirectly annotated with @Component or on methods annotated with @Bean\n\n- @Configuration\n\nThis annotation is analog for XML configuration file.\n\n```jsx\n@Configuration\npublic class DataConfig {\n@Bean\npublic Datasource source(){\nDatasource source= new OracleDataSource();\nsource.setURL();\nsource.setUser();\nreturn source;\n}\n}\n```\n\n- @ComponentScan\n\nThis is used in conjuction with @Configuration annotation to allow spring to know the packages to scan.\n\n```jsx\n@Configuration\n@ComponentScan(\u201ccom.praveen\u201d)\npublic class DataConfig{ }\n```\n\n- @Bean\n\nThis annotation is used at method level. @Bean works with @Configuration to create spring beans.\n\n**Difference between @Autowired with @Qualifier and @Primary**\n\nIf a bean has @Autowired without any @Qualifier, and multiple beans of the type exist, the candidate bean marked @Primary will be chosen, i.e. it is the default selection when no other information is available, i.e. when @Qualifier is missing.\n\n**Difference between @Autowired and @Resource**\n\nThe main difference is that @Autowired wires per type and @Resource wires per bean name. But @Autowired in combination with @Qualifier also autowires by name.\n\n@Resource is related to Java specification Request(JSR 250) and is a standard annotation can be used in different frameworks and technologies i..e @Resource(name=\"praveen\")\nIf i don't provide name i.e.. @Resource, by default fetches the bean based on member variable name.\n\n**There are 2 beans related to JSR specific to bean initialize and destroy i.e.. @PostConstruct and @PreDestroy are useful for init and destory of beans.**\n\n**Difference between @Component and @Configuration with @Bean**\n\n@Bean is used to explicitly declare a single bean rather than letting spring do it automatically like we did with @Component.It decouples the declaration of the bean from the class definition and lets you create and configure beans exactly how you choose.\n\n@Bean can\u2019t be used at class level rather it is placed at method level in @Configuration class.\n\n- @Lazy\n\nWhen we put @Lazy annotation over the @Configuration class, it indicates that all the methods with @Bean annotation should be loaded lazily.\n\n```jsx\n@Lazy\n@Configuration\n@ComponentScan(basePackages = \u201ccom.praveen.test\u201d)\npublic class AppConfig {\n\n@Bean\npublic Region getRegion(){\nreturn new Region();\n}\n\n@Bean\npublic Country getCountry(){\nreturn new Country();\n}\n\n}\n\n```\n\nWith @Autowired, in order to initialize a lazy bean, we reference it from another one.\n\n```jsx\nublic class Region {\n\n@Lazy\n@Autowired\nprivate City city;\n\npublic Region() {\nSystem.out.println(\u201cRegion bean initialized\u201d);\n}\n\npublic City getCityInstance() {\nreturn city;\n}\n\n}\n```\n\n- @Value\n\nThis annotation can be used for injecting values into fields in Spring-managed beans and it can be applied at the field or constructor/method parameter level.\n\nGenerally this is used to fetch the values from property file.\n\n```jsx\n\n@Configuration\n@ComponentScan(\u201ccom.praveen\u201d)\n@PropertySource(\u201cclasspath:database.properties\u201d)\npublic class AppConfig {\n\n@Value(\u201cdb.driver\u201d)\nprivate String DB_DRIVER;\n\n@Value(\u201cdb.password\u201d)\nprivate String DB_PASSWORD;\n\n@Value(\u201cdb.url\u201d)\nprivate String DB_URL;\n\n@Value(\u201cdb.username\u201d)\nprivate String DB_USERNAME;\n\n@Bean\npublic DataSource datasource() throws PropertyVetoException {\n\nHikariDataSource datasource = new HikariDataSource();\ndatasource.setDriverClassName(DB_DRIVER);\ndatasource.setJdbcUrl(DB_URL);\ndatasource.setUsername(DB_USERNAME);\ndatasource.setPassword(DB_PASSWORD);\nreturn datasource;\n}\n\n}\n\n```\n\n## Spring Framework stereo type annotations\n\n- @Component\n\nThis annotation is used on classes to indicate a spring component @Component annotation marks the java class as a bean or say component so that the component scanning mechanism of spring can add into the application context.\n\nThere is an implicit one to one mapping between the annotation class and bean(i.e. one bean per class). Control of wiring is limited with this approach since it is purely declarative.\n\n- @Controller\n\nThis annotation is used on class to indicate the class is a spring controller.\n\n- @Service\n\nThis annotation is used on class to indicate the class as a service where you can mention business logic perform calculations and call external APIs.\n\n- @Repository\n\nThis is used on java class which directly access the database.\n\n## Spring Boot annotations\n\n- @EnableAutoConfiguration\n\nThis is usually placed in main application class. This implicitly defines a base search package.This annotation tells spring boot to start adding beans based on classpath settings, other beans and various property settings.\n\n- @SpringBootApplication\n\nThis annotation is used on the application class while setting up a springboot project.\nThis class needs to be present in base package.\n\nThis annotation adds all the following.\n\n@Configuration\n\n@EnableAutoConfiguration\n\n@ComponentScan\n\n## Spring MVC and REST annotations\n\n- @Controller acts as a controller class.\n- @RequestMapping\n\nThis annotation is used both at class and method level. This is used to map web request on to the specific handler classes and handler methods.\n\nWhen @RequestMapping is used on class level it creates a base URI for which controller will be used.\n\nWhen this annotation is used on methods it will give you the URI on which the handler methods will be executed.\n\n```jsx\n@Controller\n@RequestMapping(\u201c/welcome\u201d)\npublic class WelcomeController{\n@RequestMapping(method=RequestMethod.GET)\npublic string welcomeAll(){\nreturn \u201cwelcome all\u201d;\n}\n}\n```\n\nThis annotation can be used in spring MVC as well.\n\n**@RequestMapping with Multiple URIs**\n\n```jsx\n@RestController\n@RequestMapping(\u201c/home\u201d)\npublic class IndexController{\n@RequestMapping(value={\u201c/page\u201d,\u201dpage*\u201d,\u201dview/*\u201d,\u201d*/msg\u201d})\nString indexMultipleMapping(){\nreturn \u201cHello from index multiple mapping\u201d;\n}\n}\n\n```\n\n**Composed @RequestMapping variants**\n\n@GetMapping\n\n@PostMapping\n\n@PutMapping\n\n@PatchMapping\n\n@DeleteMapping\n\n**@RequestMapping with @RequestParam**\n\nThe @RequestParam is used with @RequestMapping to bind a web request parameter to the parameter of handler method.\n\n**@RequestParam can be used with or without value**\n\n```jsx\n@RestController\n@RequestMapping(\u201c/home\u201d)\npublic class IndexController {\n@RequestMapping(value=\u201d/id\u201d)\nString getIdByValue(@RequestParam(\u201cid\u201d) String personId){\nSystem.out.println(\u201cId is \u201c+ personId);\nreturn \u201cGet ID from query string or URL with value element\u201d;\n}\n@RequestMapping(value=\u201d/personId\u201d)\nString getId(@RequestParam String personId){\nSystem.out.println(\u201cId is \u201c+ personId);\nreturn \u201cGet ID from query string of URL without value element\u201d;\n}\n}\n```\n\nThe value element of @RequestParam can be omitted if the request param and handler method parameter names are same.\n\n**produces and consumes**\n\n```jsx\n@RestController\n@RequestMapping(\u201c/home\u201d)\npublic class IndexController {\n@RequestMapping(value=\u201d/prod\u201d, produces={\u201capplication/json\u201d)\n@ResponseBody\nString getProduces(){\nreturn \u201cproduces attribute\u201d;\n}\n\n@RequestMapping(value=\u201d/cons\u201d, consumes={\u201capplication/json\u201d,\u201dapplication/xml\u201d)\nString getConsumes(){\nreturn \u201cconsumes attribute\u201d;\n}\n}\n```\n\n**@RequestMapping with @PathVariable to handle dynamic URI's**\n\n```jsx\n@RestController\n@RequestMapping(\u201c/home\u201d)\npublic class IndexController{\n@RequestMapping(value=\u201d/fetch/{id}\u201d,method=RequestMethod.GET)\nString getDynamicUriValue(@PathVariable String id){\nSystem.out.println(\u201cID is \u201c+id);\nreturn \u201cDynamic URI parameter fetched\u201d;\n}\n@RequestMapping(value = \u201c/fetch/{id:[\\d]+}\u201d, method = RequestMethod.GET)\nString getDynamicUriValueRegex(@PathVariable String id){\nSystem.out.println(\u201cID is \u201c+id);\nreturn \u201cDynamic URI parameter fetched with regex\u201d;\n}\n}\n```\n "}}]);