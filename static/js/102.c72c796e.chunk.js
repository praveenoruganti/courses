(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[102],{671:function(t,e,n){"use strict";n.r(e),e.default=" In Java, threads can have States. The Thread.State enum defines the different states that a Java thread can have.\n\nThis enum defines the following values\n\n- NEW\n- RUNNABLE\n- BLOCKED\n- WAITING\n- TIMED_WAITING\n- TERMINATED\n\n## States of a Java Thread\n\n**NEW**\n\nThis is the default state a thread gets when it is first created.\n\n**RUNNABLE**\n\nAs soon as a thread starts executing, it moves to the RUNNABLE state. Note that a thread that is waiting to acquire a CPU for execution is still in this state.\n\n**BLOCKED**\n\nA thread moves to the BLOCKED state as soon as it gets blocked waiting for a monitor lock. This can happen in one of the following two ways\n\n- It\u2019s waiting to acquire a lock to enter a synchronized block/method.\n- It\u2019s waiting to reacquire the monitor lock of an object on which it invoked the Object.wait method.\n\n**WAITING**\n\nA thread moves to this state as a result of invoking one of the following methods\n\n- Object.wait without a timeout\n- Thread.join without a timeout\n- LockSupport.park\n\n**TIMED_WAITING**\n\nA thread moves to this state as a result of invoking one of the following methods\n\n- Thread.sleep\n- Object.wait with a timeout\n- Thread.join with a timeout\n- LockSupport.parkNanos\n- LockSupport.parkUntil\n\n**TERMINATED**\n\nAs soon as a thread terminates, it moves to this state.\n\n## Possible state transitions\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/thread-state-transitions1.jpg)\n\nAs soon as a thread gets scheduled for execution, it moves to the RUNNABLE state. This transition has been shown with the first arrow (marked as 1).\n\nFrom the RUNNABLE state, a thread can move to any of the BLOCKED, WAITING, TIMED_WAITING, or TERMINATED state.\n\nTheoretically speaking, if a thread does not wait to acquire any lock, or does not sleep, or does not invoke any of the methods which makes it wait, it just finishes its execution and directly goes to the TERMINATED state (marked as 2d).\n\nOf course in a practical application, the above scenario is highly unlikely. Often a thread tries to acquire a lock, in which case it moves to the BLOCKED (marked as 2a) state if it has to wait for the lock.\n\nThreads also explicitly wait for some preconditions to be true/actions from other threads, in which case they move to the WAITING (marked as 2b) or the TIMED_WAITING (marked as 2c) state, depending on whether the waits were timed or not.\n\nOnce a thread moves to the BLOCKED state, the only possible transition that is allowed next is to move to the RUNNABLE state (marked as 3d).Similarly, the only possible transition from the WAITING state is to move to the BLOCKED state (marked as 3c).\n\nPlease note that some of the articles on the internet incorrectly adds a transition from the WAITING to the RUNNABLE state. This is just not correct.\n\nA thread can never move to the RUNNABLE state from the WAITING state directly.\n\nWe can understand the reason for this with an example.Suppose that we have a thread T which is currently in the RUNNABLE state and holds the monitor lock of three objects a, b, and c, as shown in the diagram below.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/thread-state-transitions2.PNG)\n\nAt this point, T invokes c.wait(), after which it no longer holds the monitor lock of object c\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/thread-state-transitions3.png)\n\nAs soon as T is notified using an invocation of notify/notifyAll, it stops waiting and competes with other threads (let\u2019s say, X and Y) to acquire the monitor lock of c\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/thread-state-transitions4.png)\n\nwhich, according to the definitions above, is the BLOCKED state. Only after acquiring the monitor lock of c, T moves to the RUNNABLE state.\n\nSimilar reasoning can be applied for the Thread.join() (which internally uses Object.wait()) and LockSupport.park().\n\nLet\u2019s get back to our original state transition diagram. As we can see, a thread can move to either the RUNNABLE (marked as 3b) or the BLOCKED (marked as 3a) state from the TIMED_WAITING state.\n\nThe transition to RUNNABLE is possible in this case because a thread can enter the TIMED_WAITING state after invoking the Thread.sleep method, in which case it retains all the monitor locks it currently holds.\n\nAs a thread finishes execution after moving back and forth between the RUNNABLE, BLOCKED, WAITING or TIMED_WAITING state, it moves to the TERMINATED state once and for all.\n\n## How do we get the current state of a Thread?\n\nWe can use the Thread.getState() method to retrieve the current state of a thread. We can use this value to monitor or debug any concurrency issues that our application might face in production.\n\n## sleep()\n\n- If a thread doesn't want to perform any operation for a particular amount of time that is just pausing is required then we should go for sleep() method.\n- sleep(n) says \"I'm done with my timeslice, and please don't give me another one for at least n milliseconds.\" The OS doesn't even try to schedule the sleeping thread until requested time has passed.\n- It is static and final method.\n- It can be overloaded and throws InterruptedException also.\n\n## join()\n\n- If a thread wants to wait until completing other threads then we should go for join() method.\n- It is final method but not static method and native method.\n- It can be overloaded and throws InterruptedException.\n\n## yield()\n\n- It causes to pause current executing thread to give the chance for remaining waiting threads of same priority.\n- yield() says \"I\u2019m done with my timeslice, but I still have work to do.\" The OS is free to immediately give the thread another timeslice, or to give some other thread or process the CPU the yielding thread just gave up.\n- It is static method and native method but not final method.\n- It doesn't throw InterruptedException and it can't be overloaded.\n\n## wait()\n\n- wait() method releases the lock.\n- wait() is the method of Object class.\n- wait() is the non-static method.\n- wait() should be notified by notify() or notifyAll() methods.\n\n## Difference between wait and sleep method\n\n- A wait can be \"woken up\" by another thread calling notify on the monitor which is being waited on whereas a sleep cannot it can only be interrupted.\n- While sleeping a Thread does not release the locks it holds, while waiting releases the lock on the object that wait() is called on.\n- sleep(n) says \"I'm done with my timeslice, and please don't give me another one for at least n milliseconds.\" The OS doesn't even try to schedule the sleeping thread until requested time has passed. wait() says \"I'm done my timeslice. Don't give me another timeslice until someone calls notify().\"\n- we can normally use sleep() for time-synchronization and wait() for multi-thread-synchronization.\n\n "}}]);