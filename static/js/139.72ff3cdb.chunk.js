(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[139],{708:function(e,n,t){"use strict";t.r(n),n.default=' ## What is JavaScript?\nJavaScript (or "JS") is a programming language used most often for dynamic client-side scripts on webpages, but it is also often used on the server-side, using a runtime such as Node.js.\n\n## History of JavaScript\n1995 - Netscape created Livescript\n\n1997 - ECMAScript1 was released\n\n2009 - ECMAScript5(ES5) was released\n\n2015 - ECMAScript5(ES2015 - ES6) was released -> This is widely used\n\n2016 - ECMAScript5(ES2016 - ES7) was released\n\n2017 - ECMAScript5(ES2017 - ES8) was released\n\n2018 - ECMAScript5(ES2018 - ES9) was released\n\n\n## Advantages of JavaScript\n- **Less server interaction**\n\n  You can validated user input before sending the page off to the server. This saves server traffic, which means less load on your server.\n- **Immediate feedback to the visitors**\n\n  They don\'t have to wait for a page to reload to see if they have forgotten to enter something.\n- **Increased interactivity**\n\n  You can create interfaces that react when the user hovers over them with a mouse or activates them via the keyboard.\n- **Rich interfaces**\n\n  You can use JavaScript to include such items as drag and drop components and sliders to have a Rich interface to your site visitors.\n\n## Disadvantages of JavaScript\n- **Client-Side Security**\n\n  Since JavaScript code is executed on the client-side, bugs and oversights can sometimes be exploited for malicious purposes. Because of this, some people choose to disable JavaScript entirely.\n- **Browser Support**\n\n  While server-side scripts always produce the same output, different browsers sometimes interpret JavaScript code differently. These days the differences are minimal, and you shouldn\'t have to worry about it as long as you test your script in all major browsers.\n\n## Tools needed\n- Web Browser([Chrome](https://www.google.com/chrome/?brand=CHBD&brand=FKPE&gclid=Cj0KCQiA5vb-BRCRARIsAJBKc6IjMi1GbbkXQKjcpNOnOQVuXI8nmkx54QpyhTUpiDVEXAI32lHhvToaAtE-EALw_wcB&gclsrc=aw.ds))\n- Code Editor([VSCode](https://code.visualstudio.com/download))\n\n\n## How To Write JavaScript\nIn two ways we can do this\n\n- **Write code in the script tag in HTML and it can be included in head tag or body tag or after body tag based on the scenario.**\n\n```HTML\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <title> How To Write JavaScript</title>\n\n</head>\n\n<body>\n<h1> How to Write JavaScript</h1>\n</body>\n<script>\n    console.log("How To Write JavaScript")\n<\/script>\n</html>\n```\n- **We can create a js file and include in script tag in HTML using src attribute**\n\n```jsx\nconsole.log("Welcome to Praveen Oruganti JavaScript Tutorials")\n```\n\n```HTML\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <title> How To Write JavaScript</title>\n\n</head>\n\n<body>\n<h1> How to Write JavaScript</h1>\n</body>\n<script>\n    console.log("How To Write JavaScript")\n<\/script>\n<script src="script.js"><\/script>\n</html>\n```\n## How JavaScript Works?\n\nTo be able to see the bigger picture of some piece of code you must know how that particular programming language works under the hood.\n\nEverything in JavaScript happens inside an Execution Context.\n\n\nJavaScript is a synchronous single-threaded language.\n\n**Execution Context and Window Object**\n\nEvery block of code written to work properly it needs some environment when it can run, and it is no different for the JavaScript too. Say hi to the Execution Context which is the place where the JavaScript code is running. To have a picture of the Execution Context, think of it like some kind of box, container or wrapper which stores variables and which a piece of JavaScript code is evaluated and executed.\n\n**Global Execution Context**\n\nThe default execution context is the global execution context, which means all of the code (variables and functions) that is not inside of any function is executed. You can think of this Global Execution Context as some global object which is the window object. Everything that we declare in the global context is attached to the window object, for example:\n\n```jsx\nvar firstName = "Praveen";\nconsole.log(firstName === window.firstName) // True\n```\nDeclaring the variable firstName or window.firstName is the same thing, think of it like firstName is a property of window object.\n\n**Function Execution Context**\n\nWhat about the code that is in functions? each time we call a function, that function is getting a new execution context called function execution context on the top of the execution stack. Let\'s see some practical example:\n\n```jsx\nvar name="Praveen";\nfunction first(){\n  var a = "Hello";\n  second();\n  var x = a + name;\n}\n\nfunction second(){\n  var b = "Hi";\n  third();\n  var z = b + name;\n}\n\nfunction third(){\n  var c = "Hola";\n  var z = c + name;\n}\n\nfirst();\n\n```\nOur first declaration, the variable name is not in any function, which means we are in the global execution context. The function first(), function second() and function third() declarations are also in the same execution context. When we go to the last line where the first() function is called, we will get a new execution context on the top of the execution stack. Every execution context that is on the top of the execution stack becomes an active context in which the code is executed.\n\nNow inside our new execution context, we have a **variable a** stored, on the next line we call the second function which again new execution context will be created on top of the execution stack, which also now becomes an active context.\n\nHere inside the execution context of the second function, we have a **variable b** stored. we are calling the third function which will again create a new execution context on top of the execution stack.\n\nInside the execution context of the third function, we have a **variable c and z** and nothing more. So our third function has finished all of its work and we say that the function returns, and it\'s execution context it\'s removed from the top of the execution stack.\n\nAfter that, the context of the second function which called the third function becomes the active context again, and we continue. Now the **z variable** is updated and the second function finishes all of its work and returns, which it\'s execution context is also removed from the stack.\n\nNow the context of the first function is again the active context, and the code continues where the **x variable** is updated and because there is no more work to be done inside the first function, we say again that the function returns and its execution context is removed from the execution stack.\n\n**How Execution Context is Created**\n\nAs we said before we can associate an execution context with an object, this object has three properties:\n\n- **Variable Object (VO)** which contains function arguments, inner variable declarations and functions declarations.\n- **Scope Chain** which contains the current variable objects as well as the variable objects of all of its parents.\n- **"This" variable** which is pointing to the current object.\n\nNow let\'s see how the execution context is created. As we said before when a function is started an execution context is put on top of the execution stack, this process happens in two phases:\n- Creation phase\n- Execution phase\n\nIn the creation phase we first have the creation of the Variable Object, second the creation of the Scope Chain, and at the end "this" variable is set. In the execution phase, the code that generated the current execution context is run line by line, and all of the variables are defined. If it is the global context, then it is the global code that is executed.\n\nCall stack maintains the order of the execution of execution contexts.\n\n## Hoisting\n\nHoisting is JavaScript\'s default behavior of moving all declarations to the top of the current scope.\n\nFor e.g. Current scope could be the current script or the current function where they declared.\n\nThis means that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local.\n\nHoisting moves declaration to the top of current scope but not value assigned into it.\n\nIf without declaring an variable, we start to assign value into it, then It becomes by default Global variable.\n\nit is recommended to always declare variables regardless of whether they are in a function or global scope.\n\n```jsx\n// Example1: We can use a variable before it is declared\nnum = 50;\nconsole.log(num); // 50\nvar num;\n\n// Example2: Hoisting moves the declarations to top but not the assignments.\nvar num1;\nconsole.log(num1); // undefined\nnum1 = 100;\n\n// Example3: If variable not declared anywhere then it becomes Global.\n\nfunction test(){\n    num2=200;\n    var num3=300;\n\n}\n\ntest();\nconsole.log(num2); // 200\nconsole.log(num3); // ReferenceError: num3 is not defined\n\n```\n\nYou can check out the [Demo](https://praveenoruganti.github.io/courses/demo/js/Introduction)\n\n\n\n '}}]);