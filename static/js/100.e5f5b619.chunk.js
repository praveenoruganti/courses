(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[100],{669:function(e,t,n){"use strict";n.r(t),t.default=' ## Serialization\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/serialization.png)\n\nSerialization is a mechanism of converting the state of an object into a byte stream.\n\nSerialization is a process where we can change state of object to the file over the network or simply we can transfer our object from one layer to another layer, that\u2019s why java provides streaming API.\n\nIn my project I used in pojo class means my pojo class should be implements from Serializable interface because that business object will be transfer over the network, that\u2019s why it\u2019s recommended to implements BO object from Serializable interface.\n\nTo make a java object serializable, we implement java.io.Serializable marker interface.\n\n- If a parent class has implemented Serializable interface then child class doesn\u2019t need to implement it but viceversa is not true.\n- Only non static data members are saved via serialization process.\n- static and transient data members are not saved via serialization.\n- constructor of object is never called when an object is deserialized.\n- associated objects must be implementing serializable interface.\n\n**SerialversionUID**\n\nThe serialization runtime associates a version number each serializable class called a serialversionUID, which is used during deserialization to verify that sender and receiver of a serialized object.\n\nAlgorithm may vary for generating SerialversionUID based on JVM if we are not specifying in class, we will get the java.io.InvalidClassException\n\nSerializable is a marker interface (contains no methods) that tell the Java Virtual Machine (JVM) that the objects of this class is ready for being written to and read from a persistent storage or over the network.\n\nBy default, the JVM takes care of the process of writing and reading serializable objects.\n\nThe serialization/deserialization functionalities are exposed via the following two methods of the object stream classes:\n\n**ObjectOutputStream.writeObject(Object)**\n\nwrites a serializable object to the output stream. This method throws NotSerializableException if some object to be serialized does not implement the Serializable interface.\n\n**ObjectInputStream.readObject()**\n\nreads, constructs and returns an object from the input stream. This method throws ClassNotFoundException if class of a serialized object cannot be found.\n\nBoth methods throw InvalidClassException if something is wrong with a class used by serialization, and throw IOException if an I/O error occurs. Both NotSerializableException and InvalidClassException are sub classes of IOException.\n\n**transient Keyword**\n\n- transient is a modifier applicable only on variables.\n- At the time of serialization if we don\u2019t want to save the value of particular variable to meet security constraints then we should go for transient keyword.\n- At the time of serialization jvm ignores original value of transient variables and save default value to the file.\n- Hence transient means not to Serialize.\n\n**static vs transient**\n\n- Static variable are not part of object state and hence they won\u2019t participate in serialization.\n- Due to this declaring a static variable as transient there is no use or impact.\n\n**final vs transient**\n\n- final variables will be participated in serialization directly by their values.\n- Due to this declaring a final variable as transient there is no use or impact.\n\n**Static member and transient fields are ignored while serialization.**\n\nLet\'s see sample code now.\n\n```jsx\n\npublic class Card implements Serializable {\n    private static final long serialVersionUID = -2989861887704472660L;\n    String cardHolderName;\n    int cardHolderAge;\n    static String cardType;\n    transient double cardAmount;\n    public Card(String cardHolderName, int cardHolderAge, String cardType, double cardAmount) {\n        this.cardAmount = cardAmount;\n        this.cardHolderName = cardHolderName;\n        this.cardHolderAge = cardHolderAge;\n        Card.cardType = cardType;\n    }\n\n    @Override\n    public String toString() {\n        return "Card [cardHolderName=" + cardHolderName + ", cardHolderAge=" + cardHolderAge + ", cardType="\n        + Card.cardType + ",cardAmount=" + cardAmount+"]";\n    }\n}\n\n```\n\n```jsx\npublic class SerializationExample {\n    public static void main(String[] args) {\n        Card c = new Card("Praveen", 32, "Regila", 200000);\n        String fileName = "Praveen.ser";\n        FileOutputStream file = null; ObjectOutputStream out = null;\n        // Serialization\n        try {\n            file = new FileOutputStream(fileName); out = new ObjectOutputStream(file); out.writeObject(c);\n        } catch (IOException e) {\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\nAs you know, if parent class implements Serializable interface then by default child class get serializable eventhough it doesnt implement the Serializable interface.\n\nIn order to prevent subclass from serialization we need to implement writeObject() and readObject() methods which are executed by JVM during serialization and deserialization also NotSerializableException is made to be thrown from these methods.We can also provide our custom logic in these methods which would be executed during serialization/deserializatin.\n\n```jsx\npublic class TestSerialization {\n\t   public static void main(String[] args) throws IOException, ClassNotFoundException {\n\t      B obj = new B();\n\t      FileOutputStream fos = new FileOutputStream("abc.ser");\n\t      ObjectOutputStream oos = new ObjectOutputStream(fos);\n\t      oos.writeObject(obj);\n\t      FileInputStream fis = new FileInputStream("abc.ser");\n\t      ObjectInputStream ois = new ObjectInputStream(fis);\n\t      B obj1 = (B)ois.readObject();\n\t      System.out.println("value of i is : " + obj1.i + " & value of j is : " + obj1.j);\n\t   }\n\t}\n\nclass A implements Serializable {\n\tint i = 10;\n}\n\nclass B extends A {\n\tint j = 20;\n\t\n\t// implementing writeObject method,\n\tprivate void writeObject(ObjectOutputStream out) throws IOException {\n\t   throw new NotSerializableException();\n\t}\n\t// implementing readObject method,\n\tprivate void readObject(ObjectInputStream in) throws IOException {\n\t   throw new NotSerializableException();\n\t}\n}\n\t\n```\n\n**Output**\n\n```jsx\nException in thread "main" java.io.NotSerializableException\n\tat com.praveen.serialization.B.writeObject(TestSerialization.java:33)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1140)\n\tat java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1496)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\n\tat java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\n\tat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)\n\tat com.praveen.serialization.TestSerialization.main(TestSerialization.java:16)\n```\n\n\n## Deserialization\n\nDeserialization is the process by which the object previously serialized is reconstructed back into it\u2019s original form i.e. object instance. The input to the deserialization process is the stream of bytes which we get over the other end of network OR we simply read it from file system/database or memory.\n\nLet\'s see sample code now.\n\n```jsx\n\npublic class Card implements Serializable {\n    private static final long serialVersionUID = -2989861887704472660L;\n    String cardHolderName;\n    int cardHolderAge;\n    static String cardType;\n    transient double cardAmount;\n\n    public Card(String cardHolderName, int cardHolderAge, String cardType, double cardAmount) {\n        this.cardAmount = cardAmount;\n        this.cardHolderName = cardHolderName;\n        this.cardHolderAge = cardHolderAge;\n        Card.cardType = cardType;\n    }\n\n    @Override\n     public String toString() {\n        return "Card [cardHolderName=" + cardHolderName + ", cardHolderAge=" + cardHolderAge + ", cardType=" + Card.cardType + ",cardAmount=" + cardAmount+"]";\n     }\n}\n\n\npublic class DeserializationExample {\n    public static void main(String[] args) {\n    String fileName = "Praveen.ser";\n    FileInputStream file = null;\n    ObjectInputStream in = null;\n    Card c;\n    try {\n        file = new FileInputStream(fileName); in = new ObjectInputStream(file);\n        c = (Card) in.readObject();\n        System.out.println(c.toString());\n    } catch (IOException | ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n    finally {\n        if (in != null) {\n        try {\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        }\n        if (file != null) {\n            try {\n                file.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    }\n}\n\n\n```\n\n** Output**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/des.png)\n\ncardType and cardAmount values are not coming up as static and transient variables will not be serialized.\n\nFor example, In Card class if i change the value of serialVersionUID to any value for example -2989861987704472661L then i will get below exception while deserializing.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/des1.png)\n\n## Marker Interface\n\n- Marker interface in Java is interfaces with no field or methods or in simple word empty interface in java is called marker interface.\n- Example of marker interface is Serializable, Clonnable and Remote interface.\n- It looks they are used to indicate something to compiler or JVM.\n- So if JVM sees a class is Serializable it done some special operation on it, similar way if JVM sees one class is implement Clonnable it performs some operation to support cloning. Same is true for RMI and Remote interface. So in short Marker interface indicate, signal or a command to Compiler or JVM.\n- After introduction of Annotation on Java5, Annotation is better choice than marker interface and JUnit is a perfect example of using Annotation.\n- In summary marker interface in Java is used to indicate something to compiler, JVM or any other tool but Annotation is better way of doing same thing.\n\n '}}]);