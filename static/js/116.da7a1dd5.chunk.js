(this["webpackJsonppraveenoruganti-courses"]=this["webpackJsonppraveenoruganti-courses"]||[]).push([[116],{685:function(e,a,t){"use strict";t.r(a),a.default=' In java, JVM allocates memory to different processes, methods and objects.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/jvm1.jpg)\n\n\n### ClassLoader\n\nA Java program is made up of a number of custom classes (written by programmers like us) and core classes (which come pre-packaged with Java). When a program is executed, JVM needs to load the content of all the needed class. JVM uses a ClassLoader to find the classes.\n\nClassloader subsystem does the below steps.\n\n- Loading\n- Linking\n- Initialization\n\n\nThere are three main types of ClassLoaders in Java.\n\n1. **System ClassLoader**: This ClassLoader depends on CLASSPATH to find the location of class files. If you specify your jars in CLASSPATH, then this ClassLoader will load them.\n\n2. **Extension ClassLoader**: It loads class files from jre/lib/ext location.\n\n3. **Bootstrap ClassLoader**: This is the first ClassLoader. It loads classes from rt.jar file.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/classloader.png)\n\n**How does classloader works?**\n\n- When JVM requests for a class, it invokes loadClass function of the ClassLoader by passing the fully classified name of the Class.\n- The loadClass function calls for findLoadedClass() method to check that the class has been already loaded or not. It\u2019s required to avoid loading the class multiple times.\n- If the Class is not already loaded then it will delegate the request to parent ClassLoader to load the class.\n- If the parent ClassLoader is not finding the Class then it will invoke findClass() method to look for the classes in the file system.\n\n**Note**\n\nThe ClassLoader Delegation Hierarchy Model always functions in the order System ClassLoader->Extension ClassLoader->Bootstrap ClassLoader. The Bootstrap ClassLoader is always given the higher priority, next is Extension ClassLoader and then System ClassLoader.\n\n\nFor `Linking`, it performs the below steps\n\n1. Verify -> looks the byte code and checks whether Compatible with JVM\n2. Prepare -> Memory is allocated to class variables(static)\n3. Resolve -> Symbolic references will be resolved and will throw ClassNotFound Error if not available\n\n\n`Initialization`\n\nInitialize the class variables to proper values. Execute the static initializers and initialize the static fields to the configured values.\n\n\n### JVM Memory Area\n\nThe division of total Memory area of JVM is in 5 parts:\n\n1. **Class (Method) Area** \n\nIn the method area, One area will be allocated for each JVM.  It will be created at JVM startup. Class level binary information & static variables reside in this area. Also Constant pools will be saved inside method area. Further It can be accessed by multiple threads simultaneously, therefore it is not thread-safe.\n\nMethod Area is part of space in the Perm Gen and used to store class structure (runtime constants and static variables) and code for methods and constructors.\n\n2. **Heap Area** \n\nOne area will be allocated for each JVM. It will be created at JVM startup. Objects reside in this area. It can be accessed by multiple threads simultaneously, therefore it is also not thread-safe.\n\n**How can we find allocated heap area?**\n\n```jsx\nRuntime r = Runtime.getRuntime();     \nr.maxMemory();\nr.initialMemory(); \nr.freeMemory();  \nRuntime is inside java.lang package is a Singleton class.\n```\n\n**How to set maximum & minimum heap sizes?**\n\n- **By using command prompt execution of program** \n\njava -Xmx512m JavaProgramFileName \n\njava -Xms64m JavaProgramFileName\n\nWhere Xmx indicates Maximum Memory & Xms indicates Minimum Memory. Heap memory is finite memory but based on our requirement we can set max & min heap sizes\n\n- **By Setting \'JAVA_OPTS\' as a system variable**\n\nJAVA_OPTS="-Xms256m -Xmx512m"\n\nAfter that in a command prompt run the following command:\n\nSET JAVA_OPTS="-Xms256m -Xmx512m"\n\nThis setting indicates\n\nallocating minimum 256MBs of heap\n\nallocating maximum 512MBs of heap\n\nHeap Memory is created by JVM in start of program and used for storing objects. Heap Memory can be accessed by any thread is further divided into three generations Young Generation,Old & PermGen(Permanent Generation). When object is created then it first go to Young generation(especially Eden space) when objects get old then it moves to Old/tenured Generation. In PermGen space all static & instance variables name-value pairs(name-references for object) are stored. We can manually increase heap size by some JVM parameters java -Xms=1M -XmX=2M "Class Name".\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/jvmheap.png)\n\n`When Heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error`\n\n`Permanent Generation (also called as Method Area and replaced by Metaspace since Java 8)`\n\nPermanent Generation or `Perm Gen` contains the application metadata required by the JVM to describe the classes and methods used in the application. Perm Gen is populated by JVM at runtime based on the classes used by the application. Perm Gen also contains Java SE library classes and methods. Perm Gen objects are garbage collected in a full garbage collection.\n\nPermGen Space used to store 3 things\n\n- Class level data (meta-data)\n- interned strings\n- static variables\n\n`Metaspace`\n\nWith Java 8, there is no Perm Gen, that means there is no more "java.lang.OutOfMemoryError: PermGen\u201d space problems. Unlike Perm Gen which resides in the Java heap, Metaspace is not part of the heap. Most allocations of the class metadata are now allocated out of native memory. Metaspace by default auto increases its size (up to what the underlying OS provides), while Perm Gen always has fixed maximum size. Two new flags can be used to set the size of the metaspace, they are: "-XX:MetaspaceSize\u201d and "-XX:MaxMetaspaceSize\u201d. The theme behind the Metaspace is that the lifetime of classes and their metadata matches the lifetime of the classloaders. That is, as long as the classloader is alive, the metadata remains alive in the Metaspace and can\u2019t be freed. Please note the interned strings and static variables are moved into the heap itself.\n\n`Please note the general metadata, static and final variables will be stored in metaspace whereas instance variables will be stored in stack.`\n\n3. **Stack Area** \n\nJava Stack memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that are getting referred from the method.\n\nStack memory is always referenced in LIFO (Last-In-First-Out) order. Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method.\n\nAs soon as method ends, the block becomes unused and become available for next method.\n\nStack memory size is very less compared to Heap memory.\n\nEach Thread has its own stack. All local variables & function calls are stored in stack. It\'s life depends upon Thread\'s life as thread will be alive it will also and vice-versa. It can also be increased by manually:- java -Xss=512M "Class Name"\n\nFurthermore, Each stack frame has three parts : local variable array, operand stack and frame data.\n\n\n**Local Variable Array**: It contains values of local variables & method parameters.\n\n**Operand Stack**: JVM uses it as workspace, some instruction push the values to it & some pop from it & some other to performs arithmetic operations.\n\n**Frame Data**: It contains all symbolic references related to the method. It also contains reference of exception related to method.\n\n`When stack memory is full, Java runtime throws java.lang.StackOverFlowError.`\n\n**Stack vs Heap**\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/stackvsheap.jpg)\n\n4. **Program Counter Register** \n\nInternally used by JVM. For every thread JVM creates a separate PC register. In brief PC register contains address of currently executing threads.\n\n5. **Native Method Stack** \n\nFor every thread JVM creates a separate native method stack if its native method call.\n\n**Note**: \n\nMethod Area, Heap Area, Stack Area are also considered as important memory areas as programmers point of view. Method Area, Heap area are for per JVM whereas Stack area, PC register & the native method stack are for per thread.\n\n\nHere with pointers on JVM Memory Area:\n\n- Static Variables are stored in Method area.\n- Instance Variables are stored in Heap area.\n- Local Variables are stored in Stack area.\n\n### What is difference between PermGen & Metaspace?\n\n**PermGen (JDK 7 & lower versions)**\n\nPermGen is a special heap space separated from the main memory heap. Moreover, the full form of the PermGen is the Permanent Generation. JVM uses this space to keep track of metadata such as loaded classes. Additionally, the JVM stores all the static content in this space such as all the static methods, primitive variables, and references to the static objects.\n\nThe default maximum memory size for 32-bit JVM is 64 MB and for the 64-bit version its 82 MB. However, we can change the default size with the JVM options. When application tries to load unusual number of classes, we may see `java.lang.OutOfMemoryError : PermGen space`\n\nMost importantly, Oracle completely removed this memory space in the JDK 8 release.\n\n**Metaspace (JDK 8 & higher versions)**\n\nMetaspace is a new memory space \u2013 starting from the Java 8 version. Specifically, it has completely replaced the older PermGen memory space. The most significant difference is how it handles memory allocation. It is a part of native memory region. Moreover, Metaspace by default auto increases its size depending on the underlying OS. Here, the garbage collection is automatically triggered when the class metadata usage reaches its maximum metaspace size. Moreover, it does better garbage collection than PermGen. Hence, with this improvement, JVM reduces the chance to get the `java.lang.OutOfMemory error`.\n\n### Execution Engine\n\nIt is a central component of JVM and responsible for executing  .class files. It  mainly contains two parts : Interpreter & JIT compiler.\n\n**Interpreter**\n\nInterpreter reads & interprets bytecode, converts it into machine code/native code line by line. Because of line by line performance of system goes down. Then JIT compiler comes into picture in jdk 1.1 version.\n\n**JIT compiler**\n\nThe primary purpose of JIT compiler is to improve performance. In fact, Internally it maintains a separate count for every method. Whenever JVM comes across any method call, first that method is interpreted normally by the interpreter and JIT compiler increments the corresponding count variable accordingly.\n\nThis process continues for every method. Once if any method count reaches threshold value then JIT compiler identifies that the method is repeatedly used method. We also call that method as hotspot for the JIT compiler. Then JIT Compiler compiles that method immediately & generates corresponding native code. Next time JVM comes across that method call, then JVM uses native code directly & executes it instead of interpreting it once again so that performance of the system will be improved. However the threshold count varies from JVM to JVM.\n\nSome advanced JIT compilers recompile generated native code if count reached threshold value second time so that more optimized machine code can be generated. Internally profiler (which is the part of JIT compiler) is responsible to identify hot-spots.\n\n**Note**:\n\nJVM interprets total program at-least once.\n\nHowever, JIT compilation is applicable only for repeatedly required methods not for every method.\n\nAdditionally JIT Compiler has intermediate code generator, code optimizer, target code generator & machine code generator in its whole compilation process.\nExecution Engine has Garbage collector, Security manager etc..\n\n\n**JNI (Java Native interface)** :\n\nJNI acts as mediator between java method calls & corresponding native libraries. Additionally JNI is responsible to provide information about native libraries to the JVM.\n\n\n### Let\'s see Stack and Heap diagram for better understanding with a simple example.\n\n```jsx\npublic class Memory {\n\tpublic static void main(String[] args) { // Line 1\n\t\tint i=1; // Line 2\n\t\tObject obj = new Object(); // Line 3\n\t\tMemory mem = new Memory(); // Line 4\n\t\tmem.foo(obj); // Line 5\n\t} // Line 9\n\tprivate void foo(Object param) { // Line 6\n\t\tString str = param.toString(); //// Line 7\n\t\tSystem.out.println(str);\n\t} // Line 8\n}\n```\nLet\'s go through the steps of execution of the program.\n\n- As soon as we run the program, it loads all the Runtime classes into the Heap space. When main() method is found at line 1, Java Runtime creates stack memory to be used by main() method thread.\n- We are creating primitive local variable at line 2, so it\u2019s created and stored in the stack memory of main() method.\n- Since we are creating an Object in line 3, it\u2019s created in Heap memory and stack memory contains the reference for it. Similar process occurs when we create Memory object in line 4.\n- Now when we call foo() method in line 5, a block in the top of the stack is created to be used by foo() method. Since Java is pass by value, a new reference to Object is created in the foo() stack block in line 6.\n- A string is created in line 7, it goes in the String Pool in the heap space and a reference is created in the foo() stack space for it.\n- foo() method is terminated in line 8, at this time memory block allocated for foo() in stack becomes free.\n- In line 9, main() method terminates and the stack memory created for main() method is destroyed. Also the program ends at this line, hence Java Runtime frees all the memory and end the execution of the program.\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/jrm.png)\n\n\n### Garbage Collection\n\n![screenshot of the app](https://praveenoruganti.github.io/courses/images/java/gc.png)\n\nGarbage collection is the way of resource management in programming, where unused or not reference object need to be identified and removed from heap memory.\n\nGC removes the objects in Heap if there no references to stack.\n\nGC is daemon or low priority thread which runs in the background.\n\nHeap memory is divided into three generation i.e... Young Generation, old or tenured generation and permanent generation.\n\nYoung - New\n\nOld - long lasting\n\nPerm Gen - Metadata\n\n## Type of Garbage Collection in Java\n\n**Minor GC**\n\nIn Young generation new objects will be created and after GC all the non reference objects are removed and reference objects are moved to Old or Tenured generation. This is faster process.\n\n**Major GC**\n\nGarbage collection in old generation is known as Major GC. This is slower process.\n\n**Full GC**\n\nRemoving non reference objects from Young as well old generation.\n\n## Types of Garabage Collectors in Java\n\n**Serial GC**\n\nUses single thread to scan system and designed for small heap size system. All the application threads are paused at the time of Garabage collection.\n\n**Parallel/Throughput GC**\n\nUses multiple threads to scan system and default garbage collector for Java 8. All the application threads are paused at the time of Garabage collection.\n\n**Concurrent Mark Sweep(CMS) GC**\n\nUses multiple threads to scan the heap memory to mark and then sweep the objects.Application threads are paused in 2 scenarios\n\n1. Marking the reference object in old generation.\n\n2. Change in heap memory in parallel while in GC.\n\n**G1 GC**\n\nUses multiple threads to scan the system and default garbage collector for Java9 and used for large heap memory size system. It divides the heap memory into regions from 1MB to 32 MB.There is a concurrent global marking phase which marks all the reference objects in heap. After that G1 will start collection object with more empty and release them to get free space.G1 also uses user defined pause time target on the basis of that it selects the number of regions.\n\n**Here with the JVM Garbage Collection configuration**\n\n-Xms, -Xmx: Places boundaries on the heap size to increase the predictability of garbage collection. The heap size is limited in replica servers so that even Full GCs do not trigger SIP retransmissions. -Xms sets the starting size to prevent pauses caused by heap expansion.\n\n-Xmn : Size of young generation.\n\n-XX:PermSize : Initial PermSize\n\nX:MaxPermSize: Max PermSize\n\n-XX:+UseG1GC: Use the Garbage First (G1) Collector.\n\n-XX:+UseSerialGC : Serial GC\n\n-XX:+UseParallelGC: Parallel GC\n\n-XX:+UseConcMarkSweepGC : CMS GC\n\n '}}]);